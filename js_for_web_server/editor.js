// editor.js: CodeMirror handling for Edit views. Used in:
// intramine_editor.pl.
// Load, Save file, manage content resizing.
// March 2022, autolinks (FLASH links) are now supported.

// Remember top line, restore it during and after resize.
let topLineForResize = -999;
// Delay scrolling a little, to help resize preserve first text line number.
let lazyOnScroll;

let isMarkdown = false;

let debouncedAddLinks; 			// See makeDebouncedClearAddLinks() at bottom.
let debouncedOnWindowResize; 	// See makeDebouncedOnWindowResize() at bottom.
let firstMaintainButtonsCall = true;

// Enable/disable beforeUnloadListener
// Turns out enabling this defeats the restore_edits.js approach to auto
// save of unsaved changes, due to clearSavedDiffs() being called. That's
// fine if the Leave/Cancel dialog generated by beforeUnloadListener is
// visible, but it isn't seen on a system restart. So for now
// beforeUnloadListener is disabled, and we rely on restore_edits.js.
let enableBeforeUnload = false;

// Used by DeductFromLineCountForInlineHTML() below.
let topTags = "p|div|h1|h2|h3|h4|h5|h6|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del";

let cmCursorStartPos = {
	line : -1,
	ch : -1
};
let cmCursorEndPos = {
	line : -1,
	ch : -1
};

let cursorFileStartPos = {
	line: 0,
	ch: 0,
};

let cursorFileEndPos = {
		line: 0,
		ch: 1,
	};

cmCursorStartPos = cursorFileStartPos;
cmCursorEndPos = cursorFileEndPos;

let dragInTitle = false;
let titleStartX, titleStartY;
const titleElement = document.getElementById("viewEditTitle");

titleElement.addEventListener('mousedown', (e) => {
    titleStartX = e.pageX;
    titleStartY = e.pageY;
    dragInTitle = false; // Reset flag on mousedown
});

titleElement.addEventListener('mousemove', (e) => {
    // If mouse has moved beyond a small threshold, consider it a drag
    if (Math.abs(e.pageX - titleStartX) > 5 || Math.abs(e.pageY - titleStartY) > 5) {
        dragInTitle = true;
    }
});


// Toggle display of file path between just file name and full path.
// Chevron image changes too.
// pathWithBackslashes and theFileName can change after Save As.
function toggleFilePath(el, expandImage, contractImage) {
	if (dragInTitle)
		{
		dragInTitle = false;
		return;
		}
	
	// el is the "viewEditTitle" span.
	let titleSpanHTML = el.innerHTML;
	if ( titleSpanHTML.indexOf("<img src='" + expandImage + "'>") >= 0
	  || titleSpanHTML.indexOf("<img src=\"" + expandImage + "\">") >= 0 )
		{
		let pathWithBackslashes = thePath.replace(/\//g, "\\"); 
		el.innerHTML = "<img src='contract.jpg'>&nbsp;" + pathWithBackslashes;
		}
	else
		{
		el.innerHTML = "<img src='expand.jpg'>&nbsp;" + theFileName;
		}
}

function getFileExtension(filename) {
	let result = '';
	let extMatch = /\.(\w+)$/.exec(filename);
	if (extMatch !== null)
		{
		result = extMatch[1];
		}
	return (result);
}

function hasClass(el, className) {
	if (el === null || el.nodeName === "#TEXT" || el.nodeName === "#text")
		{
		return false;
		}
	if (el.classList)
		return el.classList.contains(className);
	else
	return(typeof el.className !== 'undefined' && !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)')));
}

function addClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.add(className);
		else if (!hasClass(el, className))
			el.className += " " + className;
		}
}

function removeClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.remove(className);
		else if (hasClass(el, className))
			{
			let reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
			el.className = el.className.replace(reg, ' ');
			}
		}
}

function removeElementsByClass(className) {
	let elements = document.getElementsByClassName(className);
	while (elements.length > 0)
		{
		elements[0].parentNode.removeChild(elements[0]);
		}
}

function lineNumberStrAtTop() {
	let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
	let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
	let lineNumber = parseInt(myStartLine.toString(), 10);
	if (lineNumber > 0)
		{
		lineNumber += 2;
		}
	else
		{
		lineNumber = 1;
		}
	return(lineNumber.toString());
}

function rememberTopLineForResize() {
	let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
	let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
	let lineNumber = parseInt(myStartLine.toString(), 10);
	if (lineNumber > 0)
		{
		lineNumber += 2;
		}
	else
		{
		lineNumber = 1;
		}
	
	topLineForResize = lineNumber.toString();
}

// Try to preserve first displayed line of text while resizing.
function onWindowResize() {
	if (!resizing)
		{
		rememberTopLineForResize();
		}
	
	resizing = true;

	location.hash = topLineForResize;
	restoreColumnWidths();
	lazyMouseUp();
	repositionTocToggle();
}


//window.addEventListener("load", makeDebouncedOnWindowResize);
//window.addEventListener("resize", JD.debounce(onWindowResize, 100));
window.addEventListener("resize", onWindowResize);

//window.addEventListener("load", reJump);
window.addEventListener("load", makeDebouncedClearAddLinks);
//window.addEventListener("resize", JD.debounce(doResize, 100)); // swarmserver.pm#TooltipSource()

function doResize() {
	restoreColumnWidths();

	let rule = document.getElementById("rule_above_editor");
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;

	let windowHeight = window.innerHeight;
	let elHeight = windowHeight - pos.y - ruleHeight - 8;
	// let elHeight = windowHeight - pos.y - 16;
	let newHeightPC = (elHeight / windowHeight) * 100;
	let el = document.getElementById("scrollAdjustedHeight");
	el.style.height = newHeightPC + "%";

	let tocMainElement = document.getElementById("scrollContentsList");
	if (tocMainElement !== null)
		{
		let tocMarginTop =
				parseInt(window.getComputedStyle(tocMainElement).getPropertyValue('margin-top'));
		let tocHeight = elHeight - tocMarginTop;
		if (typeof window.ontouchstart !== 'undefined') // onMobile
			{
			tocHeight -= 20;
			}
		else
			{
			tocHeight -= 16;
			}
		let newTocHeightPC = (tocHeight / elHeight) * 100;
		tocMainElement.style.height = newTocHeightPC + "%";
		}

	updateToggleBigMoveLimit();
}

function setTextViewPosition(rule_id, id) {
	let rule = document.getElementById(rule_id);
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;
	let el = document.getElementById(id);
	let yPos = pos.y + ruleHeight + 8;
	el.style.top = yPos + "px";
}

function positionViewItems() {
	setTextViewPosition("rule_above_editor", cmTextHolderName);
	doResize();
}


let sve = document.getElementById("save-button");
addClass(sve, 'disabled-submit-button');
let btn = document.getElementById("undo-button");
addClass(btn, 'disabled-submit-button');
btn = document.getElementById("redo-button");
addClass(btn, 'disabled-submit-button');

setTextViewPosition("rule_above_editor", cmTextHolderName);

let cfg = new Object();
cfg.lineNumbers = true;
cfg.viewportMargin = Infinity;
cfg.lineWrapping = true;
cfg.extraKeys = {
	"Alt-F" : "findPersistent",
	"Ctrl-Z" : function(cm) {
		cm.undo();
	},
	"Ctrl-Space": function(cm) {
		insertTimeStamp(cm);
	},
	"Shift-Tab" : "indentLess"
};
// cfg.extraKeys = {
// 	"Alt-F" : "findPersistent",
// 	"Ctrl-Z" : function(cm) {
// 		cm.undo();
// 	}
// };

let highlightSelectionMatches = new Object();
highlightSelectionMatches.showToken = false;
highlightSelectionMatches.highlightWordAroundCursor = false;
highlightSelectionMatches.annotateScrollbar = true;
cfg.highlightSelectionMatches = highlightSelectionMatches;
cfg.indentUnit = 4;
cfg.indentWithTabs = true;

cfg.styleActiveLine = {nonEmpty: true};
//cfg.autoMatchParens = true;
cfg.matchBrackets = true;

// Set desired theme.
cfg.theme = selectedTheme;

let cmHolder = document.getElementById(cmTextHolderName);
let myCodeMirror = CodeMirror(cmHolder, cfg);

let xt = getFileExtension(theEncodedPath);
let info = CodeMirror.findModeByExtension(xt);
if (info)
	{
	myCodeMirror.setOption("mode", info.mime);
	CodeMirror.autoLoadMode(myCodeMirror, info.mode);
	}
	
window.addEventListener("load", function() {loadFileIntoCodeMirror(myCodeMirror, theEncodedPath);});

CodeMirror.commands.save = function(cm) {
	saveFile(theEncodedPath);
};

myCodeMirror.on("change", onCodeMirrorChange);

// TEST ONLY - not great. Can get option-Z but not cmd or ctrl. 937/184 for option-Z, shift-option-Z.
// myCodeMirror.on("keypress", testNoticeKeyPress);
// No help on iPad, and doesn't pick up modifiers in keyCode: myCodeMirror.on("keydown", testNoticeKeyPress);

function decodeHTMLEntities(text) {
	let entities =
			[ [ 'amp', '&' ], [ 'apos', '\'' ], [ '#x27', '\'' ], [ '#x2F', '/' ], [ '#39', '\'' ],
					[ '#47', '/' ], [ 'lt', '<' ], [ 'gt', '>' ], [ 'nbsp', ' ' ], [ 'quot', '"' ] ];

	for (let i = 0, max = entities.length; i < max; ++i)
		text = text.replace(new RegExp('&' + entities[i][0] + ';', 'g'), entities[i][1]);

	return text;
}

// Call back to intramine_editor.pl#LoadTheFile() with a req=loadfile request.
// On success, start clean, resize the text area, and add autolinks.
// The rddm=... arg is needed to avoid a reload from stale cache when
// the browser's Back button is used.
async function loadFileIntoCodeMirror(cm, path) {
	let originalPath = path;
	path = encodeURIComponent(path);

	try {
		let theAction = 'http://' + mainIP + ':' + ourServerPort + '/?req=loadfile&file=' + path + '&rddm=' + String(getRandomInt(1, 65000));
		const response = await fetch(theAction);
		if (response.ok)
			{
			startDiffer();
			let text = decodeURIComponent(await response.text());
			// Alas, there is trouble loading an empty file so the workaround
			// is to set the text to a message indicating same, and remove it here.
			if (text === '___THIS_IS_ACTUALLY_AN_EMPTY_FILE___')
				{
				text = '';
				}
			setSavedText(text); // For comparison against edited text
			cm.setValue(text);
			addDragger && addDragger();
			cm.markClean();
			cm.clearHistory();
			// Check for unsaved changes.
			// If so, use the patched text, mark document dirty etc.
			// This only comes into play if user was not asked to cancel
			// when leaving a page with unsaved changes.
			let restoredVersion = textWithEditsRestored();
			if (restoredVersion !== '')
				{
				cm.setValue(restoredVersion);
				adviseUserEditsWereRestored();
				}
			myCodeMirror.display.barWidth = 16;
			cm.setSelection(cursorFileStartPos, cursorFileEndPos, {
				scroll : true
			});

			loadTOC(originalPath);

			initializeSpellCheck();

			getLineNumberForTocEntries();
			// Too soon, see setTimeout below: addAutoLinks();

			doResize();

			updateToggleBigMoveLimit();
			updateTogglePositions();

			setTimeout(function() {
				cmEditorRejumpToAnchor();
				addAutoLinks();
				}, 600);
			lazyOnScroll = JD.debounce(onScroll, 100);
			cm.on("scroll", lazyOnScroll);

			setIsMarkdown();

			hideSpinner();
			}
		else
			{
			// We reached our target server, but it returned an error
			let e1 = document.getElementById(errorID);
			e1.innerHTML = '<p>Error, server reached but it returned an error!</p>';
			hideSpinner();
			}
	}
	catch(error) {
		// There was a connection error of some sort
		let e1 = document.getElementById(errorID);
		e1.innerHTML = '<p>loadFileIntoCodeMirror connection error!</p>';
		hideSpinner();
	}
}

// Get a Table Of Contents.
async function loadTOC(path) {
	if (tocHolderName === '')
		{
		hideSpinner();
		return;
		}
	
	path = encodeURIComponent(path);
	try {
		let theAction = 'http://' + mainIP + ':' + ourServerPort + '/?req=loadTOC&file=' + path;
		const response = await fetch(theAction);
		if (response.ok)
			{
			let text = decodeURIComponent(await response.text());
			let e1 = document.getElementById(tocHolderName);
			e1.innerHTML = text;
			hideSpinner();
			}
		else
			{
			// We reached our target server, but it returned an error
			let e1 = document.getElementById(errorID);
			e1.innerHTML = '<p>Error, server reached but it returned an error!</p>';
			hideSpinner();
			}
	}
	catch(error) {
		// There was a connection error of some sort
		let e1 = document.getElementById(errorID);
		e1.innerHTML = '<p>loadTOC connection error!</p>';
		hideSpinner();
	}
}

function adviseUserEditsWereRestored() {
	let e1 = document.getElementById(errorID);
	e1.innerHTML = "<strong>NOTE unsaved changes have been restored. Revert if you don't want them</strong>";
}

function testNoticeKeyPress(cm, evt) {
	let e1 = document.getElementById(errorID);
	e1.innerHTML = 'KEYPRESS ' + evt.keyCode;
}

// Show a confirmation dialog it user wants to leave without saving changes.
// Note browsers often substitute their own string in place of
// "You have unsaved changes...".
// This isn't 100% reliable, but it's close enough for most uses.
// This listener is only added when needed
// (see https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).
const beforeUnloadListener = (event) => {
  event.preventDefault();
  if (!myCodeMirror.doc.isClean())
	{
	clearSavedDiffs();
	}
  return event.returnValue = "You have unsaved changes. Are you sure you want to leave without saving them? Click Cancel if you want to Save.";
};
let unloadListenerAdded = false;

// Maintain the save/undo etc buttons, and redo autolinks.
function onCodeMirrorChange() {
	let sve = document.getElementById("save-button");
	
	if (firstMaintainButtonsCall)
		{
		firstMaintainButtonsCall = false;
		myCodeMirror.doc.clearHistory();
		myCodeMirror.doc.markClean();
		addClass(sve, 'disabled-submit-button');
		let btn = document.getElementById("undo-button");
		addClass(btn, 'disabled-submit-button');
		btn = document.getElementById("redo-button");
		addClass(btn, 'disabled-submit-button');
		btn = document.getElementById("revert-button");
		addClass(btn, 'disabled-submit-button');
		
		// Note CodeMirror emits a "change" event when text is loaded, we ignore
		// since loadFileIntoCodeMirror() calls addAutoLinks() directly.
		return;
		}
	
	if (!myCodeMirror.doc.isClean())
		{
		removeClass(sve, 'disabled-submit-button');
		let btn = document.getElementById("revert-button");
		removeClass(btn, 'disabled-submit-button');

		let e1 = document.getElementById(errorID);
		e1.innerHTML = '&nbsp;';
		
		if (!unloadListenerAdded)
			{
			unloadListenerAdded = true;
			if (enableBeforeUnload)
				{
				addEventListener("beforeunload", beforeUnloadListener, {capture: true});
				}
			}

		lazySetDiffs(myCodeMirror.doc.getValue());
		}
	else
		{
		addClass(sve, 'disabled-submit-button');
		let btn = document.getElementById("revert-button");
		addClass(btn, 'disabled-submit-button');

		if (unloadListenerAdded)
			{
			unloadListenerAdded = false;
			if (enableBeforeUnload)
				{
				removeEventListener("beforeunload", beforeUnloadListener, {capture: true});
				}
			}
		
		clearSavedDiffs();
		}

	let ur = myCodeMirror.doc.historySize();
	let btn = document.getElementById("undo-button");
	ur.undo ? removeClass(btn, 'disabled-submit-button') : addClass(btn, 'disabled-submit-button');
	btn = document.getElementById("redo-button");
	ur.redo ? removeClass(btn, 'disabled-submit-button') : addClass(btn, 'disabled-submit-button');

	if (!myCodeMirror.doc.isClean())
		{
		// Restore marks when editing pauses for a couple of seconds.
		debouncedAddLinks();
		}
}

//Call back to intramine_editor.pl#Save() with a req=save POST request.
async function saveFile(path) {
	let originalPath = path;
	let e1 = document.getElementById(errorID);
	let sve = document.getElementById("save-button");
	if (hasClass(sve, 'disabled-submit-button'))
		{
		e1.innerHTML = '(nothing to save yet)';
		return;
		}
	else
		{
		e1.innerHTML = '&nbsp;';
		}

	showSpinner();
	let contents = myCodeMirror.doc.getValue();
	let originalContents = contents;
	// '%' needs encoding in contents, to survive the encodeURIComponent() below.
	contents = contents.replace(/%/g, "%25");
	// And the same for path.
	path = path.replace(/%/g, "%25");
	path = encodeURIComponent(path);
	contents = encodeURIComponent(contents);
	contents = encodeURIComponent(contents); // sic

	try {
		let theAction = 'http://' + mainIP + ':' + ourServerPort + '/';

		const response = await fetch(theAction, {
			method: 'POST',
			headers: {
			'Content-Type': 'application/x-www-form-urlencoded',
		  },
		  body: 'req=save&file=' + path + '&contents='
		  + contents
		});
		if (response.ok)
			{
			let resp = await response.text();
			if (resp !== 'OK')
				{
				let e1 = document.getElementById("editor_error");
				e1.innerHTML = '<p>Error, server said ' + resp + '!</p>';
				}
			else
				{
				myCodeMirror.doc.markClean();
				let sve = document.getElementById("save-button");
				addClass(sve, 'disabled-submit-button');
				if (unloadListenerAdded)
					{
					unloadListenerAdded = false;
					if (enableBeforeUnload)
						{
						removeEventListener("beforeunload", beforeUnloadListener, {capture: true});
						}
					}
				
				onCodeMirrorChange();

				setSavedText(originalContents);

				notifyFileChangedAndRememberCursorLine(pathForNotification);

				let lineNum = currentTOCLineNum();
				loadTOC(originalPath);

				myCodeMirror.focus();
				
				//Too soon: scrollTocEntryIntoView(lineNum, false, true);
				setTimeout(function() {
					scrollTocEntryIntoView(lineNum, false, true);
					}, 600);	
				}
			hideSpinner();
			}
		else
			{
			// We reached our target server, but it returned an error
			// TODO make this less offensive.
			let e1 = document.getElementById("editor_error");
			e1.innerHTML = '<p>Error, server reached but it could not save the file!</p>';
			hideSpinner();
			}
	}
	catch(error) {
		// There was a connection error of some sort
		// TODO make this less vague.
		let e1 = document.getElementById("editor_error");
		e1.innerHTML = '<p>Connection error while attempting to save file!</p>';
		hideSpinner();
	}
}

async function saveFileAsWithPicker() {
	showSaveAsFilePicker();
}

function revertFile(path) {
	clearSavedDiffs();
	firstMaintainButtonsCall = true;
	let e1 = document.getElementById(errorID);
	e1.innerHTML = "&nbsp;";
	loadFileIntoCodeMirror(myCodeMirror, path);
}

// WebSockets, send cursor line number and file path on a Save.
// For next load, remember the cursor position.
function notifyFileChangedAndRememberCursorLine(path) {
	// In the Viewer go to the line where the cursor is.
	// Seems more useful than going to the top line displayed in the Editor.
	//let lineNumber = myCodeMirror.getCursor().line.toString();
	// Switching to top line instead of cursor line, we'll see how it goes.
	let lineNumber = lineNumberStrAtTop();

	location.hash = lineNumber;

	if (isMarkdown)
		{
		lineNumber -= ExtraBlankLines(lineNumber);
		}
	// else if (hasTextExtension())
	// 	{
	// 	let deduction = DeductFromLineCountForInlineHTML(lineNumber);
	// 	lineNumber -= deduction;
	// 	}

	// Move displayed Viewer line down 10.
	// if (lineNumber > 10)
	// 	{
	// 	lineNumber -= 10;
	// 	}
	
	
	// Avoid self-triggering a reload, set the save time for use
	// by editor_auto_refresh.js.
	RememberLastEditorUpdateTime();

	// trigger | lineNumber | filePath | timestamp
	let msg = 'changeDetected ' + lineNumber + ' ' + path + '     ' + '0'; // five spaces there
	wsSendMessage(msg);
}

// In the Viewer display of Markdown extra blank lines are not shown
// which throws off the line count when trying to bring the last edit
// position into view. The Viewer counts one extra line for each
// paragraph or header element, but can't see extra blanks.
// Return number of extra blank lines in text, up to lineNumberStr.
// (Eg count 1 for two consecutive blanks, 2 for 3 etc).
function ExtraBlankLines(lineNumberStr) {
	let lineNumber = Number(lineNumberStr);
	let	extraBlankCount = 0;
	let justSawBlank = false;

	for (let i = 1; i < lineNumber; ++i)
		{
		let lineText = myCodeMirror.getLine(i); // or getRange and split on '\n'
		if (lineText === '')
			{
			if (justSawBlank)
				{
				++extraBlankCount;
				}
			justSawBlank = true;
			}
		else
			{
			justSawBlank = false;
			}
		}
	
	return(extraBlankCount.toString());
}

// Return positive count of excess lines, for each inline HTML chunk
// the contribution is number of lines in this editor minus one.
function DeductFromLineCountForInlineHTML(lineNumberStr) {
	let lineNumber = Number(lineNumberStr);
	let extraLineCount = 0;
	let currentChunkLineCount = 0;
	let inChunk = false;
	let blockTag = '';
	let regex = new RegExp('^!<([^>]+)');
	let currentResult = {};

	for (let i = 1; i < lineNumber; ++i)
		{
		let lineText = myCodeMirror.getLine(i); // or getRange and split on '\n'
		if (!inChunk)
			{
			if ((currentResult = regex.exec(lineText)) !== null)
				{
				blockTag = currentResult[1];
				if (topTags.indexOf(blockTag) >= 0)
					{
					inChunk = true;
					currentChunkLineCount = 1; 
					}
				}
			}
		else
			{
			if (lineText.indexOf("</" + blockTag + ">") === 0)
				{
				++currentChunkLineCount;
				extraLineCount += currentChunkLineCount;
				inChunk = false;
				}
			else
				{
				++currentChunkLineCount;
				}
			}
		}

	return(extraLineCount);
}

function setIsMarkdown() {
	isMarkdown = false;
	let fileName = theEncodedPath.split(/[\\/]/).pop();
	let extPos = fileName.lastIndexOf(".");
	if (extPos > 1)
		{
		let ext = fileName.slice(extPos + 1);
		if (ext === "md" || ext === "MD" || ext === "mkd" || ext === "MKD" || ext === "markdown" || ext === "MARKDOWN")
			{
			// .md files don't have line numbers and need special handling
			// when inserting links and glossary popups - see addAutoLinks().
			isMarkdown = true;
			}
		}
}

function hasTextExtension() {
	let result = false;
	let extPos = theEncodedPath.lastIndexOf(".");
	if (extPos > 1)
		{
		let ext = theEncodedPath.slice(extPos + 1);
		if (ext === "txt" || ext === "TXT")
			{
			result = true;
			}
		}
	
	return(result);
}

function makeDebouncedClearAddLinks() {
	debouncedAddLinks = JD.debounce(clearAndAddAutoLinks, 2000);
}

function makeDebouncedOnWindowResize() {
	debouncedOnWindowResize = JD.debounce(onWindowResize, 200);
}

function addClickHandler(id, fn) {
	let el = document.getElementById(id);
	if (el !== null)
		{
		el.addEventListener('click', fn, false);
		}
}

// Eg "Sun Sep 10 2023 08:37:40".
// Currently fired by Ctrl-Space.
function insertTimeStamp(cm) {
	let dateTimeStr = Date().toLocaleString();
	let gmtIndex = dateTimeStr.indexOf(" GMT");
	if (gmtIndex > 0)
		{
		dateTimeStr = dateTimeStr.substring(0, gmtIndex);
		}
	cm.replaceSelection(dateTimeStr);
}

function editorUndo(e) {
	// e.preventDefault();
	// myCodeMirror.focus();
	myCodeMirror.doc.undo();
	// Remove error notice if unsaved edits were restored at start.
	let e1 = document.getElementById(errorID);
	e1.innerHTML = '&nbsp;';
	onCodeMirrorChange();
}

function editorRedo(e) {
	// e.preventDefault();
	// myCodeMirror.focus();
	myCodeMirror.doc.redo();
	onCodeMirrorChange();
}

function showSearch(e) {
	// CodeMirror.commands.findPersistent(myCodeMirror);
	CodeMirror.commands.find(myCodeMirror);
}

function pasteDateTimeOnF4() {
	window.addEventListener("keydown", (e) => {
		if (e.key === "F4" && myCodeMirror.hasFocus()) {
			let dateTimeString = nowDateTime();
			insertInCodeMirror(dateTimeString);
		}
}, false);
}

//Pad given value to the left with "0"
function AddZero(num) {
    return (num >= 0 && num < 10) ? "0" + num : num + "";
}

const monthNames = ["January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
];
const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];


function nowDateTime() {
    let now = new Date();
	let amPm = 'AM';
	let hours = now.getHours();
	if (hours >= 12)
		{
		if (hours > 12)
			{
			hours -= 12;
			}
		amPm = 'PM';
		}
	else if (hours == 0)
		{
		hours = 12;
		}
	let strDateTime = hours + ":" + AddZero(now.getMinutes()) + " " + amPm +
						" " + days[now.getDay()] + ", " + monthNames[now.getMonth()] +
						" " + AddZero(now.getDate()) + ", " + now.getFullYear();
    return(strDateTime);
}


function insertInCodeMirror(textToInsert) {
    var doc = myCodeMirror.getDoc();
    var cursor = doc.getCursor();

    var pos = {
        line: cursor.line,
        ch: cursor.ch
    }

    doc.replaceRange(textToInsert, pos);
}

function cmEditorRejumpToAnchor() {
	let anchor = location.hash;
	if (anchor.length > 1)
		{
		anchor = anchor.replace(/^#/, '');
		// Remove any trailing '&rddm=1234' type stuff.
		anchor = anchor.replace(/\&.+$/, '');
		anchor = anchor.replace(/ /g, '_');
		anchor = anchor.replace(/\%20/g, '_');
		anchor = anchor.replace(/\(\)$/, '');

		let result = cmEditorRejumpToHeading(anchor);
		if (!result && !isNaN(anchor))
			{
			let lineNum = parseInt(anchor, 10);
			cmEditorRejumpToLine(lineNum);
			}
		}
}

function cmEditorRejumpToHeading(h) {
	h = decodeURIComponent(h);
	let result = false;

	let lineNum = lineNumberForAnchor(h);

	if (lineNum >= 0)
		{
		cmEditorRejumpToLine(lineNum);
		result = true;
		}

	return(result);
}

function cmEditorRejumpToLine(lineNum) {
	if (lineNum > 0)
		{
		--lineNum; // off by one, cm line numbers are 0-based for API calls.
		}

	let t = myCodeMirror.charCoords({
		line : lineNum,
		ch : 0
	}, "local").top;
	myCodeMirror.scrollTo(null, t);
}

function codeMirrorIsDirty() {
	return(!myCodeMirror.doc.isClean());
}

pasteDateTimeOnF4();
addClickHandler("undo-button", editorUndo);
addClickHandler("redo-button", editorRedo);
addClickHandler("search-button", showSearch);
addClickHandler("spellcheck-button", toggleSpellCheck);

window.addEventListener("load", initSaveAsDialog);
