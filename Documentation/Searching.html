<!doctype html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-touch-fullscreen" content="yes" />
<meta name="google" content="notranslate">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>Searching</title>
<style>
/* main.css: the place where failure to plan goes to die. */

h1 {
	font-size: 1.5em;
}

.shimclear {
	height: 2px;
	float: none;
}

/*#help {display:none;}*/

/* ipadfix out overflow: hidden; in width: 100%*/
html, body {
    overflow: hidden;
	height: 100%;
   /* width: 100%*/
}

body {
	background: #fafafa;
	font: normal .8em/1.5em Arial, Helvetica, sans-serif;
	min-width: 800px;
	margin-left: 1%;
	margin-right: 0.5%;
	margin-top: 0;
	margin-bottom: 0;
	/* Experimental, trying to get word breaks on iPad Pro */
	/* Doesn't help: overflow-wrap: break-word; */
	/* Works, but breaks on everything: word-break: break-all; */
}

/* ipadfix adding a wrapper around entire body */
#bodywrapper {
	position: fixed; height:100%; width:100%; top:0; left:0;
}

#pageContent {
	height: 100%;
}

a {
text-decoration: none;
}

a:link {
color: Black;
border-bottom: 1px solid #AAA;
}

a:visited {
color: #333;
border-bottom: 1px solid #AAA;
}

a:hover {
color: #333;
border-bottom: 1px solid #333;
}

#scrollContentsList a:link {
	border-bottom: 0;
}

/* File tree displays, suppress underlines on links. */
UL.jqueryFileTree A {
	border-bottom: none;
}

/* ipadfix adding wrapper around fixed top part */
#fixed_header {
	position: absolute; top:0; left:0; width:100%; height: 200px; z-index:10;
	}

#nav {
	position: relative;
	display: block;
	margin: 0;
	margin-top: 2px;
	padding: 7px 6px 0;
	line-height: 100%;
	border-radius: .4em;

	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);

	/*background: -webkit-gradient(linear, left top, left bottom, from(#a9a9a9), to(#7a7a7a));*/
	background: -webkit-gradient(linear, left top, left bottom, from(#999999), to(#333333));

	border: solid 1px #6d6d6d;
	min-width:770px;
}
#nav li {
	margin: 0 5px;
	/*padding: 0 0 8px;*/
	padding: 0;
	float: left;
	position: relative;
	list-style: none;
}
/* main level link */
#nav a {
	font-weight: bold;
	color: #e7e5e5;
	text-decoration: none;
	border-bottom: none;
	display: block;
	/*padding:  8px 15px;*/
	padding: 4px 8px;
	margin: 0;
	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .3);
}
/* main level link hover */
#nav .current a, #nav li:hover > a {
	background: -webkit-gradient(linear, left top, left bottom, from(#ebebeb), to(#a1a1a1)); /* for webkit browsers */
	border-top: solid 1px #f8f8f8;
	-webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	-moz-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	text-shadow: 0 1px 0 rgba(255, 255, 255, .8);
}

#nav li:hover > a {
	color: #444;
}

#nav .current a, #nav .current:hover > a {
	color: #008000; /*#31540c*/
}

/* sub levels link hover */
#nav ul li:hover a, #nav li:hover li a {
	background: none;
	border: none;
	color: #666;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
}
#nav ul a:hover {
	background: -webkit-gradient(linear, left top, left bottom, from(#04acec), to(#0186ba)) !important; /* for webkit browsers */

	color: #fff !important;
	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .1);
}
/* level 2 list */
#nav ul {
	background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#cfcfcf)); /* for webkit browsers */

	display: none;
	margin: 0;
	padding: 0;
	width: 185px;
	position: absolute;
	top: 35px;
	left: 0;
	border: solid 1px #b4b4b4;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
}
/* dropdown */
#nav li:hover > ul {
	display: block;
}
#nav ul li {
	float: none;
	margin: 0;
	padding: 0;
}
#nav ul a {
	font-weight: normal;
	text-shadow: 0 1px 1px rgba(255, 255, 255, .9);
}
/* level 3+ list */
#nav ul ul {
	left: 181px;
	top: -3px;
}
/* rounded corners for first and last child */
#nav ul li:first-child > a {
	-webkit-border-top-left-radius: 9px;
	-moz-border-radius-topleft: 9px;
	-webkit-border-top-right-radius: 9px;
	-moz-border-radius-topright: 9px;
}
#nav ul li:last-child > a {
	-webkit-border-bottom-left-radius: 9px;
	-moz-border-radius-bottomleft: 9px;
	-webkit-border-bottom-right-radius: 9px;
	-moz-border-radius-bottomright: 9px;
}
/* clearfix */
#nav:after {
	content: ".";
	display: block;
	clear: both;
	visibility: hidden;
	line-height: 0;
	height: 0;
}
#nav {
	display: inline-block;
}
html[xmlns] #nav {
	display: block;
}

* html #nav {
	height: 1%;
}

/* For changing "ToDo" in the Nav bar. See todoFlash.js. */
#nav li > a.flashOn {
	background-color: black;
    color: lightgreen;
}

.navDisabled {
	opacity: 0.4;
	cursor: default;
}

.navHidden {
	display: none;
}

#nav li > a.noIntraMine {
	background-color: black;
	color: red;
}

#spinnerParent {
	position: relative;
	display: inline-block;
	width: 43.4px;
	/*height: 36px;*/
	height: 24px;
	/*margin: 0;*/
	/*margin-top: -4px;*/
	padding: 0;
	/*margin-top: 4px;*/
}
#spinner {
	position: absolute;
	display: inline-block;
	margin: 0;
	padding: 0;
	top: 0;
	left: 0;
	/*top: -4px;*/
	cursor: pointer;
}

#details tr {
	margin: 0;
	padding: 0;
}
#details td {
	margin: 0;
	font-size: 1.0em;
	padding: 0;
}

#details caption {
	font-size: 1.2em;
	font-weight: bold;
}
.yebal, .openingbal {
	font-weight: bold;
	background-color: #CCCCCC;
}
.yebalneg {
	font-weight: bold;
	background-color: #FFCCCC;
}
.monthlybal {
	background-color: #EEEEEE;
}
.monthlybalneg {
	/*font-weight: bold;*/
	background-color: #FFAAAA;
}

.unsupported {
	color: #aaaaaa;
}

/* Scroll support */

/* Transition to new names for scroll support NOTE some classes are now ids */
#headingAboveContents { /* Replaces #searchWhat */
	margin-top: 10px;
	font-size: 1.2em;
}

#scrollAdjustedHeight, #scrollAdjustedHeightDirPicker {
	display: flex;
	width: 100%;
	height: 60%;
	overflow: hidden;
}

#scrollContentsList {
	width: 22.5%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	font-family: helvetica, arial, sans-serif;
	font-size: 1.2em;
	line-height: 1.3em;
	margin-top: 20px;
}

#scrollContentsList a {
	text-decoration: none;
}

#scrollContentsList li, #scrollContentsList ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

#scrollContentsList li {
	margin-bottom: 6px;
}

#scrollContentsList a:hover {
	color: blue;
	cursor: pointer;
}

#scrollTextRightOfContents {
	flex: auto;
	padding-left: 0; /* was 1em */
	overflow: auto;
	-moz-tab-size: 4;
	tab-size: 4;
}

#scrollText {
	float: left;
	width: 100%;
	-moz-tab-size: 4;
	tab-size: 4;
}

#scrollTextRightOfContents h1, #scrollTextRightOfContents h2, #scrollTextRightOfContents h3, #scrollTextRightOfContents h4, #scrollTextRightOfContents h5, #scrollTextRightOfContents h6 {
	display: inline;
}

#scrollTextRightOfContents h5, #scrollTextRightOfContents h6 {
	padding-top: 6px;
	padding-bottom: 3px;
}

#scrollContentsList .h1 {
	font-size: 1.3em;
}

#scrollContentsList .h2 {
	font-size: 1.1em;
}

#scrollContentsList .h3 {
	font-size: 1.0em;
	font-style: italic;
	font-variant: normal;
}


#scrollContentsList .h4 {
	font-size: .9em;
}

#scrollContentsList .h2Disabled {
	font-size: 1.1em;
	color: #889988;
}

#scrollContentsList .h2 a:before {
	font-size: 0.6em;
	content: "\00a0";
	padding-left: 0;
}

#scrollContentsList .h3 a:before {
	font-size: 0.6em;
	content: "\00a0\00a0";
	padding-left: 8px;
}

#scrollContentsList .h4 a:before {
	font-size: 0.4em;
	content: "\00a0\00a0\00a0";
	padding-left: 24px;
}


/* section marker */
/*
#scrollContentsList .h2 a:before {
	font-size: 0.6em;
	content: "\25B0  ";
	padding-left: 0;
	color: #667766;
}


#scrollContentsList .h3 a:before {
	font-size: 0.6em;
	content: "\25B0  ";
	padding-left: 8px;
	color: #889988;
}

#scrollContentsList .h4 a:before {
	font-size: 0.4em;
	content: "\25B0  ";
	padding-left: 24px;
	color: #889988;
}
*/

#details {
	height: 100%;
}

/* Circled letters, for table of contents display by intramine_viewer.pl. */
.circle_red {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #FAA;
	border: 1px solid #FAA;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}
  .circle_green {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #7E7;
	border: 1px solid #7E7;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}
  .circle_blue {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #CCF;
	border: 1px solid #CCF;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}


/* A bit of formatting for text. */
.Comment_Normal {color: #004221;}
.Comment_POD {color: #004221;}
.Directive {color: #000000;}
.Label {color: #000000;}
.Quote {color: #8A0808;}
.String {color: #8A0808;}
.Subroutine {color: #000000;}
.Variable_Scalar {color: #0101DF;}
.Variable_Array {color: #0101DF;}
.Variable_Hash {color: #0101DF;}
.Variable_Typeglob {color: #0101DF;}
/*.Whitespace {color: #000000;}*/
.Character {color: #000000;}
.Keyword {color: #A020F0;}
.Builtin_Function {color: #000000;}
.Builtin_Operator {color: #000000;}
.Operator {color: #000000;}
.Bareword {color: #000000;}
.Package {color: #000000;}
.Number {color: #000000;}
.Symbol {color: #000000;}
.CodeTerm {color: #000000;  font-weight: bold;}
.DATA {color: #000000;}

/* OLDER SCROLL SUPPORT, still valid but not for use with ace editor displays */
#searchresults, #cmdresults {
	height: 60%;
}
#jumpsandtext {
	height: 85%;
	font-family: monospace;
	font-size: 1.2em;
}

.jumplist {
	float: left;
	width: 23%;
	overflow: auto;
	height: 100%;
	padding: 4px;
}

.jumplist a {
	text-decoration: none;
	font-size: 1.1em;
	line-height: 1.2em;
}

.jumplist li, .jumplist ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

.jumplist li {
	margin-bottom: 6px;
}

.jumplist .h2 a:before {
	font-size: 1.2em;
	content: "\25B0";
}

.jumplist .h3 a:before {
	font-size: 1.2em;
	content: "\25B0\25B0";
}

.jumplist a:hover {
	color: blue;
}

.theTextWithJumpList {
	float: left;
	width: 75%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	padding-right: 0;
}

#theTextWithoutJumpList {
	float: left;
	width: 98%;
	overflow: auto;
	height: 100%;
	padding: 4px;
}

.theText {
	font-family: Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	font-size: 9pt;
	line-height: 12pt;
	float: none;
	width: 100%;
}

#searchWhat {
	margin-top: 10px;
	font-size: 1.2em;
}

/* Non-CodeMirror line gutter. */
.line_number {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em;
	display: inline-block;
}

/* CodeMirror line gutter. */
.CodeMirror-linenumbers {
	min-width: 3em;
}

a.embedded_image {
	text-decoration: none;
}

.notabene {
	color: Crimson;
	font-size: 0.9em;
}

.textSymbol {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.1em;
}

.textSymbolSmall {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.0em;
}

/* A "line break" for long URLs */
.noshow {
	display: inline-block;
	width: 0px;
}

/* Up down left right triangles for navigation. */
.arrow-left {
	display: inline-block;
	width: 0; 
	height: 0;
	margin-left: 16px;
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent; 
	border-right:16px solid #6aa436;
	position: relative;
	top: 10px;
}

.arrow-up {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
 	border-bottom: 16px solid #6aa436;
	position: relative;
	top: -14px;
	left: 8px;
}

.arrow-down {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
	border-top: 16px solid #6aa436;
	position: relative;
	top: 18px;
	left: -24px;
}

.arrow-right {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent;
	border-left: 16px solid #6aa436;
	position: relative;
	top: 10px;
	left: -16px;
}

.img-arrow-left {
	display: inline;
	margin-left: 16px;
	position: relative;
	top: 10px;
}

.img-arrow-up {
	display: inline;
	position: relative;
	top: -24px;
	left: 0;
}

.img-arrow-down {
	display: inline;
	position: relative;
	top: 40px;
	left: -68px;
}

.img-arrow-right {
	display: inline;
	position: relative;
	top: 10px;
	left: -64px;
}

#title-block {
	display: inline-block;
	max-height: 60px;
	overflow: hidden;
	text-align: right;
}


#viewEditTitle {
	margin-right: 12px;
	display: inline-block;
	font-size: 1.2em;
	font-weight: bold;
}

#viewEditDateSize {
	margin-right: 12px;
}

#title-blockTR {
	max-height: 60px;
	overflow: hidden;
}

#title-blockTD {
	max-height: 60px;
	overflow: hidden;
}

#button-block {
	display: inline-block;
	vertical-align: top;
	/*margin-top: 20px;*/
}

/* For the Status page main status tables. */
#tablePageServerStatus th {
	cursor: pointer;
}

#tableBackgroundServerStatus th {
	cursor: pointer;
}

.divAlignCenter {
	display: inline-block;
	vertical-align: middle;
}

#editor_error {
	display: inline-block;
	font-size: 0.8em;
}

/* For the "edit" pencil image, a bit of space on the left. */
.edit_img {
	display: inline-block;
	margin-left: 6px;
}

.brace-highlight {
	color: green;
	background-color: rgb(200, 255, 200);
	font-weight: bold;
}

.CodeMirror-matchingbracket {
	background-color: rgb(200, 255, 200);
	font-weight: bold;
}

/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
#theTextWithoutJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.theTextWithJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.jumplist {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollText {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollTextRightOfContents {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollContentsList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
}
</style>
<style>
/* non_cm_test.css: formatting for non-CodeMirror displays presented by the Viewer service. */

#scrollTextRightOfContents {
	padding-right: 0;
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	top: 0; right: 0; bottom: 0;

	/* https://css-tricks.com/snippets/css/prevent-long-urls-from-breaking-out-of-container/*/
	
	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollText { /* Replaces #theTextWithoutJumpList */
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;

	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollTextRightOfContents img, #scrollText img{
	max-width: 100%;
}

/* TOC shrink/expand element */
#tocShrinkExpand {
	position: absolute;
	display: inline-block;
	cursor: pointer;
	margin-right: 5px;
	margin-bottom: 5px;
}

.marker-highlight {
	background-color: lightgreen
}

.scroll-hilite {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: green;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

.initial-scroll-h1 {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: green;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}


.initial-hits-highlight {
	background-color: #ffcccc;
}

.initial-scroll-hl {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: #990000;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

div#indicator {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.75%;
    opacity: .5;
    width: 2px;
    height: 20px;
    background-color: #888;
    border: none;
    margin: 0;
    padding: 0;
	pointer-events: none;
}

div#indicatorPC {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.74%;
    /*opacity: .5;*/
    width: 9px;
    height: 20px;
    background-color: #ffdb58; /* #ffe958 or mustard, #ffdb58 */
    border: 1px solid gray; /*none;*/
    margin: 0;
    padding: 0;
	pointer-events: none;
}

/* Some special treatment for index.html files that hold a table of contents.
See intramine_fileviewer_cm.pl#GetPrettyText(). */
#specialScrollTextRightOfContents {
	padding-right: 0;
	position: absolute;
	top: 0; left: 2%; right: 0; bottom: 0;
	overflow: auto;
	/*background-image: url("Coffee-Paper-Texture4.jpg");*/
	-webkit-background-size: cover;
	-moz-background-size: cover;
	-o-background-size: cover;
}

#toc-line {
	font: normal 28px "Baskerville BT", serif;
}

#special-index-wrapper {
	padding-top: 20px;
	height: 100%;
	font: normal 24px "Baskerville BT", serif;
	/*background-color: #E8E3C5;*/
}

#special-index-wrapper th {
	text-align: center;
}

#special-index-wrapper td:not(:first-child) {
	padding-left: 80px;
}

#special-index-wrapper td:nth-child(1) {
	/*background-color: #E8E3C5;*/
	background: transparent;
}

#special-index-wrapper a {
	text-decoration: none;
}

#special-index-wrapper a:link {
	color: Black;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:visited {
	color: #333;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:hover {
	color: #333;
	border-bottom: 1px solid #333;
	background-color: #ECF6CE;
}

/* Glossary links, for glossary popups shown in standalone Gloss HTML files. */
.glossary:link {
	border-bottom: 1px dotted #666;
}

.glossary:link:hover {
	border-bottom: 1px dotted #666;
}

.glossary:link:visited {
	border-bottom: 1px dotted #666;
}

/* Second and subsequent glossary tooltips in Gloss HTML standalone files, suppress underline. */
.term-seen:link {
	border-bottom: 1px dotted #CCC;
}

.term-seen:hover {
	border-bottom: 1px dotted #666;
}

.term-seen:visited {
	border-bottom: 1px dotted #CCC;
}

/* Table of Contents highlight for current item. */
.tocitup {
	background-color: lightgreen;
}

/* Gloss standalone HTML, alignment for "inlined" images. */
.valigntop {
	vertical-align: top;
}
and the entry name in a span with
.inlinespan {
	display:inline-block;
}

#bottomShim {
	margin: 0;
	height: 3px;
	}

/* For Gloss display of *!* wrapped code bits. */
code {
	background-color:#ECF6CE;
}

/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
	#scrollTextRightOfContents {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
	#scrollText {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
}

</style>
<style>
/* non_cm_tables.css: for non-CodeMirror table display by the Viewer service. */

table {
	tab-size: 4;
	white-space: pre-wrap;
}

table, tr, td {
	margin: 0;
	border: none;
	border-spacing: 0;
	padding: 0;
}

td {
	vertical-align: top;
	padding-left: 4px;
	/*overflow-wrap: break-word;*/
}

thead {
	overflow-wrap: break-word;
	word-wrap: normal;
	-ms-word-break: normal;
	word-break: normal;
}

/* vertical align middle */
td.vam {
	vertical-align: middle;
}

td:nth-child(1) {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em; /* enough for 99999 one hopes */
}

th {
	text-align: left;
}

/* Avoid copy of line numbers in the first column.
<td n='$lineNum'></td>
*/
td:first-child:after, th:first-child:after {
    content: attr(n);
}

td:first-child.brace-line-highlight:after, th:first-child.brace-line-highlight:after {
    background-color: rgb(200, 255, 200);
}



h1, h2, h3, h4 {
	font-family: helvetica, arial, sans-serif;
	text-shadow: #9C9C9C 1px 1px 1px;
	color: #002000;
}

h1 {
	color: #305030;
	font-size: 2em;
	line-height: 2em;
	margin: 0;
	padding: 2px;
}

h3 {
	font-style: italic;
}

/* Unordered list items. */
.outdent-unordered {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.outdent-unordered-sub {
	margin: 0;
	padding: 0;
	text-indent: -1.3em;
	padding-left: 2.9em;
	}

.outdent-unordered-continued {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.outdent-unordered-sub-continued {
	margin: 0;
	padding: 0;
	padding-left: 2.9em;
	}

/* Ordered lists, with one or two digits in the main item or sub item, and their
continuation paragraphs. There are twelve possibilities.
Naming: "ol-1-2-c" = ordered list - one digit top level - two digits second - continuation
paragraph (ie not the first paragraph in the item).
"ol-2" = ordered list - two digits top level, no second level, first paragraph.
*/
.ol-1 {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.ol-1-c {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.ol-1-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 4.2em;
	}

.ol-1-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.2em;
	}

.ol-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 2.3em;
	}

.ol-2-c {
	margin: 0;
	padding: 0;
	padding-left: 2.3em;
	}

.ol-1-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.7em;
	padding-left: 4.6em;
	}

.ol-1-2-c {
	margin: 0;
	padding: 0;
	padding-left: 4.6em;
	}

.ol-2-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.6em;
	padding-left: 4.9em;
}

.ol-2-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.9em;
	}

.ol-2-2 {
	margin: 0;
	padding: 0;
	text-indent: -3.2em;
	padding-left: 5.6em;
}

.ol-2-2-c {
	margin: 0;
	padding: 0;
	padding-left: 5.6em;
	}


/* Data tables in text */
.bordered {
    border: solid #ccc 1px;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 1px 1px #ccc; 
    -moz-box-shadow: 0 1px 1px #ccc; 
    box-shadow: 0 1px 1px #ccc;
    margin-bottom: 4px;    
}

.bordered tr:hover {
    background: #fbf8e9;
    -o-transition: all 0.1s ease-in-out;
    -webkit-transition: all 0.1s ease-in-out;
    -moz-transition: all 0.1s ease-in-out;
    -ms-transition: all 0.1s ease-in-out;
    transition: all 0.1s ease-in-out;     
}    
    
.bordered td, .bordered th {
    border-left: 1px solid #ccc;
    border-top: 1px solid #ccc;
    padding-top: 2px;
    padding-bottom: 2px;
    text-align: left;    
}

.bordered th {
    background-color: #dce9f9;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#ebf3fc), to(#dce9f9));
    background-image: -webkit-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:    -moz-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:     -ms-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:      -o-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:         linear-gradient(top, #ebf3fc, #dce9f9);
    -webkit-box-shadow: 0 1px 0 rgba(255,255,255,.8) inset; 
    -moz-box-shadow:0 1px 0 rgba(255,255,255,.8) inset;  
    box-shadow: 0 1px 0 rgba(255,255,255,.8) inset;        
    border-top: none;
    text-shadow: 0 1px 0 rgba(255,255,255,.5); 
}

.bordered td:first-child, .bordered th:first-child {
    border-left: none;
    border-top: none;
    background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em;
}

.bordered th:first-child {
    -moz-border-radius: 6px 0 0 0;
    -webkit-border-radius: 6px 0 0 0;
    border-radius: 6px 0 0 0;
}

.bordered th:last-child {
    -moz-border-radius: 0 6px 0 0;
    -webkit-border-radius: 0 6px 0 0;
    border-radius: 0 6px 0 0;
}

.bordered th:only-child{
    -moz-border-radius: 6px 6px 0 0;
    -webkit-border-radius: 6px 6px 0 0;
    border-radius: 6px 6px 0 0;
}

.bordered tr:last-child td:first-child {
    -moz-border-radius: 0 0 0 6px;
    -webkit-border-radius: 0 0 0 6px;
    border-radius: 0 0 0 6px;
}

.bordered tr:last-child td:last-child {
    -moz-border-radius: 0 0 6px 0;
    -webkit-border-radius: 0 0 6px 0;
    border-radius: 0 0 6px 0;
}

.bordered td:not(:first-child), .bordered th:not(:first-child) {
	padding-left: 4px;
	padding-right: 4px;
}

.bordered td.centered_cell, .bordered th.centered_cell {
	text-align: center;
}

.bordered td.left_cell, .bordered th.left_cell {
	text-align: left;
}

.bordered td.right_cell, .bordered th.right_cell {
	text-align: right;
}

.shrunkrow {
	height: 3pt;
	}
	
.reallyshrunkrow {
	background: #888;
}

.reallyshrunkrow td {
	height: 1px;
	border: none;
	padding: 0;
	}

</style>
<style>
/* tooltip.css: for popup hints and images, see also tooltip.js. */

#hintbox{ /*CSS for pop up hint box */
position:absolute;
top: 0;
background-color: #FFFFF4;
/*width: 150px; Default width of hint.*/ 
padding: 0; /* was 6px */
/*border:1px solid black;*/
font:normal 13px Verdana;
line-height:18px;
z-index:100;
/*border-right: 3px solid black;
border-bottom: 3px solid black;*/
visibility: hidden;
	
overflow: auto;
overflow-wrap: break-word;
word-wrap: break-word;
-ms-word-break: break-all;
word-break: break-word;

border: none;
box-shadow: 0 1px 1px rgba(0,0,0,0.08), 0 2px 2px rgba(0,0,0,0.12), 0 4px 4px rgba(0,0,0,0.16), 0 8px 8px rgba(0,0,0,0.20);
}

.hintanchor{ /*CSS for link that shows hint onmouseover (no longer used)*/
font-weight: bold;
color: navy;
margin: 3px 8px;
}
.plainhintanchor { /* looks like ordinary text */
	text-decoration: none;
	font-family: arial, helvetica, sans-serif; font-size:100%;
	color: black;
}
.hintanchor:hover {
    border-top-style: hidden;
}
.plainhintanchor:hover {
    border-top-style: hidden;
}
.invisiblehintanchor:hover {
	border-top-style: hidden;
}

.showHintAnchorClass:hover {
	background-color: lavender;
}

/* For hints showing links to definitions. */
.defhint {
	background-color: #f9f3ff !important;
}

/* Additions for Gloss display of tooltips. */

#hintbox td:nth-child(1) {
	background-color: #FFFFF4;
	color: #000;

	min-width: auto;
	text-align: left;
}

/* hintgloss.css, temp CSS for showhint with Gloss */
/* gloss_tables.css: for table display by the ToDo service. */

#hintbox table {
	tab-size: 4;
	white-space: pre-wrap;
}

#hintbox table, #hintbox tr, #hintbox td {
	margin: 0;
	border: none;
	border-spacing: 0;
	padding: 0;
}

#hintbox td {
	vertical-align: top;
	padding-left: 4px;
	/*overflow-wrap: break-word;*/
}

#hintbox thead {
	overflow-wrap: break-word;
	word-wrap: normal;
	-ms-word-break: normal;
	word-break: normal;
}

/* vertical align middle */
#hintbox td.vam {
	vertical-align: middle;
}


#hintbox th {
	text-align: left;
}


#hintbox h1, #hintbox h2, #hintbox h3, #hintbox h4 {
	font-family: helvetica, arial, sans-serif;
	text-shadow: #9C9C9C 1px 1px 1px;
	color: #002000;
}

#hintbox h1 {
	color: #305030;
	font-size: 2em;
	line-height: 2em;
	margin: 0;
	padding: 2px;
}

#hintbox h3 {
	font-style: italic;
}

/* Unordered list items. */
#hintbox .outdent-unordered {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

#hintbox .outdent-unordered-sub {
	margin: 0;
	padding: 0;
	text-indent: -1.3em;
	padding-left: 2.9em;
	}

#hintbox .outdent-unordered-continued {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

#hintbox .outdent-unordered-sub-continued {
	margin: 0;
	padding: 0;
	padding-left: 2.9em;
	}

/* Ordered lists, with one or two digits in the main item or sub item, and their
continuation paragraphs. There are twelve possibilities.
Naming: "ol-1-2-c" = ordered list - one digit top level - two digits second - continuation
paragraph (ie not the first paragraph in the item).
"ol-2" = ordered list - two digits top level, no second level, first paragraph.
*/
#hintbox .ol-1 {
	margin: 0;
	padding: 0;
	text-indent: -1.2em;
	padding-left: 1.2em;
	}

#hintbox .ol-1-c {
	margin: 0;
	padding: 0;
	padding-left: 1.2em;
	}

#hintbox .ol-1-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.4em;
	padding-left: 3.6em;
	}

#hintbox .ol-1-1-c {
	margin: 0;
	padding: 0;
	padding-left: 3.0em;
	}

#hintbox .ol-2 {
	margin: 0;
	padding: 0;
	text-indent: -1.7em;
	padding-left: 1.7em;
	}

#hintbox .ol-2-c {
	margin: 0;
	padding: 0;
	padding-left: 1.7em;
	}

#hintbox .ol-1-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.1em;
	padding-left: 3.3em;
	}

#hintbox .ol-1-2-c {
	margin: 0;
	padding: 0;
	padding-left: 3.3em;
	}

#hintbox .ol-2-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.2em;
	padding-left: 3.8em;
	}

#hintbox .ol-2-1-c {
	margin: 0;
	padding: 0;
	padding-left: 3.8em;
	}

#hintbox .ol-2-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.8em;
	padding-left: 4.5em;
	}

#hintbox .ol-2-2-c {
	margin: 0;
	padding: 0;
	padding-left: 4.5em;
	}


/* Data tables in text */
#hintbox .bordered {
    border: solid #ccc 1px;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 1px 1px #ccc; 
    -moz-box-shadow: 0 1px 1px #ccc; 
    box-shadow: 0 1px 1px #ccc;
    margin-bottom: 4px;    
}

#hintbox .bordered td:first-child:hover, #hintbox .bordered tr:hover {
    background: #fbf8e9;
    -o-transition: all 0.1s ease-in-out;
    -webkit-transition: all 0.1s ease-in-out;
    -moz-transition: all 0.1s ease-in-out;
    -ms-transition: all 0.1s ease-in-out;
    transition: all 0.1s ease-in-out;     
}    
    
#hintbox .bordered td, .bordered th {
    border-left: 1px solid #ccc;
    border-top: 1px solid #ccc;
    padding-top: 2px;
    padding-bottom: 2px;
    text-align: left;    
}

#hintbox .bordered th {
    background-color: #dce9f9;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#ebf3fc), to(#dce9f9));
    background-image: -webkit-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:    -moz-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:     -ms-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:      -o-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:         linear-gradient(top, #ebf3fc, #dce9f9);
    -webkit-box-shadow: 0 1px 0 rgba(255,255,255,.8) inset; 
    -moz-box-shadow:0 1px 0 rgba(255,255,255,.8) inset;  
    box-shadow: 0 1px 0 rgba(255,255,255,.8) inset;        
    border-top: none;
    text-shadow: 0 1px 0 rgba(255,255,255,.5); 
}


#hintbox .bordered th:first-child {
    -moz-border-radius: 6px 0 0 0;
    -webkit-border-radius: 6px 0 0 0;
    border-radius: 6px 0 0 0;
}

#hintbox .bordered th:last-child {
    -moz-border-radius: 0 6px 0 0;
    -webkit-border-radius: 0 6px 0 0;
    border-radius: 0 6px 0 0;
}

#hintbox .bordered th:only-child{
    -moz-border-radius: 6px 6px 0 0;
    -webkit-border-radius: 6px 6px 0 0;
    border-radius: 6px 6px 0 0;
}

#hintbox .bordered tr:last-child td:first-child {
    -moz-border-radius: 0 0 0 6px;
    -webkit-border-radius: 0 0 0 6px;
    border-radius: 0 0 0 6px;
}

#hintbox .bordered tr:last-child td:last-child {
    -moz-border-radius: 0 0 6px 0;
    -webkit-border-radius: 0 0 6px 0;
    border-radius: 0 0 6px 0;
}


#hintbox .bordered td.centered_cell, #hintbox .bordered th.centered_cell {
	text-align: center;
}

#hintbox .bordered td.left_cell, #hintbox .bordered th.left_cell {
	text-align: left;
}

#hintbox .bordered td.right_cell, #hintbox .bordered th.right_cell {
	text-align: right;
}

#hintbox .shrunkrow {
	height: 3pt;
	}
	
#hintbox .reallyshrunkrow {
	background: #888;
}

#hintbox .reallyshrunkrow td {
	height: 1px;
	border: none;
	padding: 0;
	}

#hintbox .codehere {
	background-color: #ECF6CE; /*#dce9f9 light blue,  #F7F8E0 light yellow, #E1F5A9 light green, #ECF6CE lighter green*/
}

#hintbox td {
	padding-bottom: 8px;
}

</style>
<style>
/* dragTOC.css: CSS for the panes-separator in the Viewer, allowing width of
Table of Contents to be changed by dragging. */

.panes-separator {
    width: 3px;
    background: #aaaaaa;
    cursor: col-resize;
    }

.dragCursor {
    cursor: col-resize;
    }

</style>
<style>
/* Custom CSS for lolight syntax highlighting of code blocks.
Used in IntraMine by gloss2html.pl to style CODE/ENDCODE blocks.
Some attempt has been made to coordinate the colors with
highlightjs default.min.css.
*/

pre {
    overflow: visible;
    word-wrap: anywhere;
    white-space: pre-wrap;
    padding-left: 0.5em;
	margin: 0;
	background: #f3f3f3;
  }

.ll-nam { /* words */
    color: black;
}
.ll-num { /* numbers */
    color: #800;
}
.ll-str { /* strings */
    color: #800;
}
.ll-rex { /* regular expressions */
    color: #ab5656;
}
.ll-pct { /* operators, punctation */
    color: #ab5656;
}
.ll-key { /* keywords */
    color: #444;
    font-weight: bold;
}
span.ll-com { /* comments */
    color: #050;
    font-style: normal;
}

</style>
</head>
<body>
<!-- added for touch scrolling, an indicator -->
<div id="indicator"></div>
<hr id="rule_above_editor" />
<div id='scrollAdjustedHeight'>
<div id='scrollContentsList'><li class='h2' im-text-ln='1'><a href='#top-of-document'>TOP</a></li>
<ul>
<li class='h1' im-text-ln='1'><a href='#Searching'>Searching</a></li></ul></div><div id='scrollTextRightOfContents'><table><span id='top-of-document'></span><tr id='R1'><td n='1'></td><td><h1 id="Searching">Searching</h1></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R3'><td n='3'></td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA5AAAAKPCAIAAACU2bKJAAAAAXNSR0IArs4c6QAAAARnQU1BAACx
jwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAASdEVYdFNvZnR3YXJlAEdyZWVuc2hvdF5VCAUA
AP19SURBVHhe7P0NeFVFnu+L5/yf+/zPc+8959y5c/qczjNzz7nM8dwe5vq/V+bMnCE9M91NbFsJ
CAaxNYKK8Y2OL60R3yIIpm3FtK0YFSEgiKFb26BgwEYDApKAaFSQgCIBRKNidxDU+DqeGf3/fvWr
Vatqve21d3aSnezv59kUtWvVqvrVy6r67lq1Vkq+BgAAAAAAoICBYAUAAAAAAAUNBCsAAAAAACho
UgnWfwIAAAAAAEWDloAFQ5JgFYu/+uqrLwAAAAAAQNFA8k90oBaFQ02sYCUTv/zyy88+++yTTz75
8MMPjx492gsAAAAAAEY0JPlI+JH8IxFIUrBANGusYCVxTbbu2LHjvvvumzVr1lUAAAAAAKAIIOFH
8o9EIElBEoSFoFljBevHH3+8evXqurq6X/3qVw8++OBiAAAAAABQBJDwI/lHIpCkIAnCQtCssYJ1
+/btN910E+nrhQsXkt1w4cKFCxcuXLhwi8dtbGwkzUqC8JNPPvnyyy+1QBwiYgUrWTl//vz777//
gQcegAsXLly4cOHChVts7h133EGCsLe397PPPhvaRdZYwTpr1qwFCxaQlcR9990nHgJ+AX4BfgF+
AX4BfgF+AX4BfmF4+UkKkiB89913P/nkk6+++kprxKEgVrBeddVVZCUAAAAAAChaSBDu37//ww8/
HNqdrEmC9de//vXdd98NFy5cuHDhwoULtzhdEoT79u07evRo4QrWu+6661ce8AvwC/AL8AvwC/AL
8AvwC/ALw9dPgvCNN97o7e0tXMF6p0dDQ4P2RflXrVq1f//+Tz/99PPhDNlPpaCymHIJ8AvwC/AL
8AvwC/AL8AvwCyPGT4Lw9ddfL2jBekcKXn75ZSrDsWPHyB3uSCmoRLpsAAAAAADDhNsV+kv+GAaC
9bbbbvvlL3+Z4K5bt44K8Ic//OEDjxHgpxJRuRJKDRcuXLhw4cKFW0Au/bvtF7fzf7/ggF+Qax3t
nzsMBGt9Jvbs2fP++++/9957I8ylcukSAgAAAAAULLfe+stfzLnvlzNX3Prj39x8UvNN/+/Ds/9x
Yf35d9TfRMd0nP4xDATrvETmzp379ttvv/POOz0eI8ZP5aLS6XICAAAAABQet86bc/e8mb+b+zfP
zvk3bTf/6w2z+cOeOf/LU/WjH6g//xfzbtZR+8EwEKy3JDJ79uzDIxcqnS4nAAAAAECBMXfO7Lvm
VK+u/383//I/bPnln26+zfr88k833fan637xXxrnnD3vljp9Qq4MA8F68803k26Lc2+66aZDhw4d
PHhwRLpUuoSyw4ULFy5cuHDhDpU7++a6+Tdf2jLvb7ct+C/bF/zFlrv+Ytl1/+n6qj+77szvPHz1
f2z/9f/5wr1/sX3Bf3nyl38zf/bFkSmkd4eBYCXRlsANN9zQPXKh0ulyAgAAAAAUErNvuOb+usnt
9//1K8v+ZkfTXzfd/HcXnH3q1MrTzx7//brKP3tq9n/uXDLmleV/88KSsYtuq7r5xln6tJwYBoL1
+uuvJ90mhP3XXXfdm2++uW/fvhHpzpo1SwpLJNeDkOC//tEXD7///gfO562XHr3udy+9Rf7XN1KM
tr0U+NaLj+eUvvYNnn+DsVZ47EVdEPLHnOuckil9Juy/fuMeyuXwi49KIJFbOkJu/g17ItpRIhC5
pSkMnV/1vcDnrRd/1680h4f/ug3co7wPNaU+lD4d1R8KpQ/IBRL6dG3UUZz414UHpT1tFJ6QvvYN
kT8wir6+IZc6L4QxRLBHktzKIhS4X+Y4+6PmO44TNS16k4j0ZG++8Poq9+SEvLRvYPwyx7mfobRH
+6+65N5rftDZPG7vEz95fvlpC26ddt1111LwjdfPuvVnk39Xd9KrK/7x9SdPfa3ltJX3nHtL3TV8
Sq55DQPBSpKUdBu5QsB/7bXXUgGIvXv3iofI7N/2q1NuLSmRz12/ej6rc9P6f/tzlfjWXM7Vfipd
Qtm1L53/8hXb36L+vfPJqqqqc845h9zp06dfccUVy7cdon6/Z/3Pfv7zZ16jCIfaf3vNNRS/P3kN
gv/qq5/ZLdZefbWEPOwVRGKGz/VPUQU04UIaPzXHz9bvplze2rac/Do0+3T646+trV37Go1TB9sX
UjNyOz61i0euvW21Okb/0h8SPzUN972Dzy9WJaJynXvuuRdeeCEVNuc0CeOngX5v29C0V7L/UTUD
vbaGCs14TalNTZOO1x8O7XjkijTxB9RPnpqammnTplFZVu/UvZT8559//s9//nOJQ5j4VzzywiFv
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
"  /></td></tr>
<tr id='R4'><td n='4'></td><td></td></tr>
<tr id='R5'><td n='5'></td><td>Searching with IntraMine's Search page is I hope easy enough without long-winded descriptions. Here's a brief summary of the search fields.</td></tr>
<tr id='R6'><td n='6'></td><td><strong>Search for</strong> accepts plain text, and also $ @ and % characters (mainly for Perl).</td></tr>
<tr id='R7'><td n='7'></td><td><strong>Match Exact Phrase</strong> means the words typed must match exactly and in sequence, as stated, but the match is not case sensitive.</td></tr>
<tr id='R8'><td n='8'></td><td><strong>Directory</strong>, the three dots, <strong>Subdirectories too</strong> allows you to limit searching to a single directory and optionally all subdirectories contained therein. Hit the three dots ... to pick a directory, or you can type it in.</td></tr>
<tr id='R9'><td n='9'></td><td><strong>Language / Extension</strong> is a dropdown allowing you to limit searches to one or more languages or extensions (though you can't mix the two).</td></tr>
<tr id='R10'><td n='10'></td><td>And finally, the <strong>Sort by:</strong> dropdown will affect all searches done on your particular Search page until you refresh it. You can change the sort after a search or before.</td></tr>
<tr id='R11'><td n='11'></td><td></td></tr>
<tr id='R12'><td n='12'></td><td>For more on Search see <a href="./Search.html" target="_blank">"Search.txt"</a>.</td></tr>
<tr id='R13'><td n='13'></td><td></td></tr>
<tr id='R14'><td n='14'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R15'><td n='15'></td><td><a href="./contents.html" target="_blank">contents.txt</a></td></tr>
<tr id='R16'><td n='16'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr></table><p id='bottomShim'></p></div></div>
<script>
let thePath = 'C:/perlprogs/IntraMine/Documentation/Searching.txt';
let theEncodedPath = 'C:/perlprogs/IntraMine/Documentation/Searching.txt';
let usingCM = false;
let cmTextHolderName = 'scrollTextRightOfContents';
let specialTextHolderName = 'specialScrollTextRightOfContents';
let theMainPort = '99999';
let mainIP = '99999';
let ourServerPort = '99999';
let peeraddress = '99999';	// ip address of client
let weAreRemote = false;
let errorID = "editor_error";
let highlightItems = [];
let b64ToggleImage = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAYCAYAAAC8/X7cAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFLMAABSzATFtOXUAAAQZSURBVFhH1ZZfTFtVHMd/91/L7VY6/hVG4xgymWUIY5ENkq0jy4wGN3EjMmpI9mCcb0s0PvnnzfiyZCb6YqI+mJCUoRkmc7onXeYSBcxWZkfDMjYR6Ua7Au0dXLn33Hs8pz3BdC1QQpvUT/+l39/J70/POb/+ONggTX1SrQkwBEg/FBgAhcmborEX7CBKvxgAJ4L9+n0mZwXPPrPC/bpwQLTDb3I5NJtWkJi8aagv6rOI+KYxmJwVWRfg9krdWyv4n1s9zU7BSjZuiRlyAfFFfbZ6mpw0Bo3FLOuSVQF7vNK7jh384BHPS/KBbT1MzT3tJb3Q4Tkq01g0JpPXZM0Cmk+DSBx9Xu6Wzr3Q3sXvsrWBai4wa+5ZMmJQbzsIR9uO8WXPiudobJoDM2dk1UvsPgnFgiwNulrkF9t2dUKJ6EroGlbh4vUvITZleEDgYglxsxjY4agRrnUffBMkrighRdE0DN+9AiG/eoU0jJ7VGkbGAnb3WZ6yivj7mlZHU7PrMMicg1kAdFLA9ftDoEYxU3KDXMbBodpuEDkrU8iOkN2+FboKU6PKrWXEHZvo16aZaYW0Ahp6xX0WO3eprq20uq5kH3FoYZYkmDz+MR+vfMslRbydJJSakm4uw+T8Dbg3PB/SFHx8fADdYKYEKasbeqTjshN8dfsrtlTZaomyoS6bNzCYMLs4CZOj0UU1DN7xQf0SM/1XAGldZ4td3PmalhLBLpUztbBQtAhM+RcMZQa/Pe7TP6Ma19EBQni7eL60XjhbWW8DiU9eokJFN1WYvaPC3ITxqfMheodr8IpDlXvFV+0uPu38FSr0Hioz5Fj50Xc8xjCmxck7fZKz9n940VxpzjR34VHAvErO/rS2CJ1bKnmBK/BNwCT/Wb+hK3+ZZ0hH+kSgYiRg3ty2kx9R58yurVW8lUuohYepA4RGkaJG4MTtAfQt1VJ+78ZT4l6xmLtcvV+oFuXC2gqkYgiNGCEUxy8HLiA/k9NvbaPXsoMvwpe3Py80Wh2FUcRyDMOD343Ass51PvlvnDHDei84LKJ0sapFOGJzpi9ZiuC8jBK2igyxwhge3jR+0pB+8o4P0mavVX/inafBYtOlryr2CH2OmtRl4T+MvAxzzudSL19sCkPkttG/JOlv/Pk1aExOYdUCGJz7lPhR6TPCe2W7yVjBVtMC4ve0svFvYC6pbI6G16C0+GlLdKUAsrnRCRPP3zU+Jp3mw6SSmfWGHRy8gN6fmzTOkNaFaAvLN6xNIhLzLZL8B1RKWjKT1bQW9KEv4jO4KzSMHtNWli8SbXIEKfEQfoXGZPKaZD1uBgf0H8jFPfz3r+iBoTIxhyDik/pWH+GOoE//kcnrsqF5mc7i+gLXvhjGY7wAOdsL6ot0mzHq+8l5f20A/gW9of8+fiHTAwAAAABJRU5ErkJggg==';
let selectedTocId = 'tocitup';
let doubleClickTime = 500;
let useLolight = true;
//let weAreStandalone = true;
</script>
<script>
	// Call fn when ready.
	function ready(fn) {
	  if (document.readyState != 'loading'){
	    fn();
	  } else {
	    document.addEventListener('DOMContentLoaded', fn);
	  }
	}

	function getRandomInt(min, max) {
  		return Math.floor(Math.random() * (max - min + 1) + min);
		}
</script>
<script>
function loadAndShowHint(hintContents, obj, e, tipwidth, isAnImage, shouldDecode) {
	hintContents = loadCachedImages(hintContents); // popup_image_cache.js
	showhint(hintContents, obj, e, tipwidth, isAnImage, shouldDecode);
}
</script>
<script type="text/javascript">
/**
 * debounce.js: //debounce() is (ultimately) from http://underscorejs.org/#debounce.
 */

let JD = {};

JD.debounce = function(func, wait, immediate) {
	let timeout;
	return function() {
		let context = this, args = arguments;
		let later = function() {
			timeout = null;
			if (!immediate)
				{
				func.apply(context, args);
				}
		};
		let callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait || 200);
		if (callNow)
			{
			func.apply(context, args);
			}
	};
};

</script>
<script type="text/javascript">
// tooltip.js: show a "tooltip" with text or an image, the main call is showhint().
/**********************************************************************************************
 * Show Hint script- (c) Dynamic Drive (www.dynamicdrive.com) 
 * This notice MUST stay intact for legal use 
 * Visit http://www.dynamicdrive.com/ for this script and 100s more.
 **********************************************************************************************/
// (Modified from the original 2018-19 and 2023-4 for use with IntraMine.)
// IntraMine use, see eg showhint() calls in
// intramine_linker.pl#GetImageFileRep(), intramine_boilerplate.pl#ThePage().

// Cursor position, updated when hintbox is showing.
let cursor_x = -1;
let cursor_y = -1;

// Where to place the hint, relative to cursor position.
const DIRECTION_BELOW = 0;
const DIRECTION_ABOVE = 1;
const DIRECTION_RIGHT = 2;
const DIRECTION_LEFT = 3;

let anchorClassName = "showHintAnchorClass"; 	// applied while mouse over element
let hitAnchorClassName = "invisiblehintanchor"; // applied if not present in element, permanently
let definitionClassName = 'defhint'; // When showing links to a definition

let overAnchorTimer = null;
let shMainPort = 0; // See setMainPort() just below.
let shOurServerPort = (typeof ourServerPort !== 'undefined') ? ourServerPort: 0;
let shOnMobile = (typeof window.ontouchstart !== 'undefined') ? true : false;
let hintElement = {}; // The HTML element holding the hint
let hintParams = {};  // hint HTML, position, width, whether it's an image


// Set the main IntraMine port, 81 by default.
function setMainPort() {
	shMainPort = (typeof theMainPort !== 'undefined') ? theMainPort: 0;
	}

window.addEventListener("load", setMainPort);


function hasClass(el, className) {
	if (el === null || el.nodeName === "#TEXT" || el.nodeName === "#text")
		{
		return false;
		}
	if (el.classList)
		return el.classList.contains(className);
	else
		return(typeof el.className !== 'undefined' && !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)')));
}

function addClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.add(className);
		else if (!hasClass(el, className))
			el.className += " " + className;
		}
}

function removeClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.remove(className);
		else if (hasClass(el, className))
			{
			let reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
			el.className = el.className.replace(reg, ' ');
			}
		}
}

function isDescendant(parent, child) {
	var node = child.parentNode;
	while (node != null) {
		if (node == parent) {
			return true;
		}
		node = node.parentNode;
	}
	return false;
}

// Helper function to get an element's exact position.
function getPosition(el) {
	"use strict";
	let rect = el.getBoundingClientRect();
	let yPos = rect.top;
	let xPos = rect.left;
	let xScrollTOTAL = 0;
	let yScrollTOTAL = 0;

	while (el)
		{
		if (el.tagName === "BODY")
			{
			// deal with browser quirks with body/window/document and page scroll
			let xScroll = el.scrollLeft || document.documentElement.scrollLeft;
			let yScroll = el.scrollTop || document.documentElement.scrollTop;
			xScrollTOTAL += xScroll;
			yScrollTOTAL += yScroll;
			}
		else
			{
			// for all other non-BODY elements
			xScrollTOTAL += el.scrollLeft;
			yScrollTOTAL += el.scrollTop;
			}

		el = el.offsetParent;
		}
	return {
		x : xPos,
		y : yPos,
		sx : xScrollTOTAL,
		sy : yScrollTOTAL
	};
}


function positionAndShowHint() {
	"use strict";
	let hintContents = hintParams.hintContents;
	let x = hintParams.x;
	let y = hintParams.y;
	let tipwidth = hintParams.tipWidth;
	let isAnImage = hintParams.isAnImage;
	let haveImageWidth = true;
	let gap = 10; // gap between cursor and tip
	let windowHeight = window.innerHeight - gap;
	let windowWidth = window.innerWidth - gap;
	let hintWidth = tipwidth; //450;
	let hintHeight = hintParams.tipHeight; //hintElement.offsetHeight;
	if (isAnImage)
		{
		try
			{
			hintWidth = hintParams.theImage.width;
			hintHeight = hintParams.theImage.height;
			}
		catch(e)
			{
			haveImageWidth = false;
			}
		}
	else
		{
		if (tipwidth !== "")
			{
			hintWidth = parseInt(tipwidth, 10);
			}
		}

	// Calculate tip all four ways, pick the way that produces least shrinkage.
	// Preference order below, above, right, left.
	let ds = bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight);
	let bestDirection = ds.bestDirection;
	let scaleFactor = ds.scaleFactor;
	
	// Scale image down to fit in window.
	if (isAnImage)
		{
		if (scaleFactor < 1.0)
			{
			let finalScaleFactor = scaleFactor * 0.95; //temp[bestDirection] * 0.95;
			hintWidth = Math.floor(hintWidth * finalScaleFactor);
			hintHeight = Math.floor(hintHeight * finalScaleFactor);
			}
		}
	
	// Position tip (and scale if image).
	// Try to keep tip close to mouse x,y position.
	let tl = tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap);

	hintElement.style.top = tl.top;
	hintElement.style.left = tl.left;
	
	// Scale image if it's really needed and we have good width and height.
	if (isAnImage)
		{
		hintElement.style.width = hintWidth + "px";
		hintElement.style.height = hintHeight + "px";
		}
	// For text, shrink the height to fit within window if necessary.
	else
		{
		hintElement.style.width = "650px";
		if (tl.top + hintHeight > windowHeight)
			{
			let reducedHeight = windowHeight - tl.top;
			hintElement.style.height = reducedHeight + "px";
			}
		else
			{
			hintElement.style.height = "auto";
			}
		}

	hintElement.innerHTML = hintContents;

	setTimeout(function() {
		hintElement.style.visibility = "visible";
		}, 100);

}

// Calculate tip all four ways, pick the way that produces least shrinkage.
// Preference order: below, above, right, left.
function bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight) {
	// Below:
	let heightAvailable = windowHeight - y;
	let widthAvailable = windowWidth;
	let belowScaleFactor = heightAvailable / hintHeight;
	if (belowScaleFactor > widthAvailable / hintWidth)
		{
		belowScaleFactor = widthAvailable / hintWidth;
		}
	// Above:
	heightAvailable = y;
	let aboveScaleFactor = heightAvailable / hintHeight;
	if (aboveScaleFactor > widthAvailable / hintWidth)
		{
		aboveScaleFactor = widthAvailable / hintWidth;
		}
	// Right:
	heightAvailable = windowHeight;
	widthAvailable = windowWidth - x;
	let rightScaleFactor = heightAvailable / hintHeight;
	if (rightScaleFactor > widthAvailable / hintWidth)
		{
		rightScaleFactor = widthAvailable / hintWidth;
		}
	// Left:
	widthAvailable = x;
	let leftScaleFactor = heightAvailable / hintHeight;
	if (leftScaleFactor > widthAvailable / hintWidth)
		{
		leftScaleFactor = widthAvailable / hintWidth;
		}
	
	// Largest scaleFactor wins, preferring in order below, above, right, left where
	// there's a tie or values are above 1.0.
	let directionalScale = [];
	directionalScale[DIRECTION_BELOW] = (belowScaleFactor > 1.0) ? 1.0 : belowScaleFactor;
	directionalScale[DIRECTION_ABOVE] = (aboveScaleFactor > 1.0) ? 1.0 : aboveScaleFactor;
	directionalScale[DIRECTION_RIGHT] = (rightScaleFactor > 1.0) ? 1.0 : rightScaleFactor;
	directionalScale[DIRECTION_LEFT] = (leftScaleFactor > 1.0) ? 1.0 : leftScaleFactor;
	// bestDirection:
	// 0 == show hint below cursor x,y
	// 1 == show hint above
	// 2 == show hint to right of cursor
	// 3 == show hint to left of cursor
	let bestDirection = -1;
	let i = 0;
	for (i = directionalScale.length - 1; i >= 0; i -= 1)
		{
		if (directionalScale[i] >= 1.0)
			{
			bestDirection = i;
			}
		}
	
	if (bestDirection < 0) // all directionalScale[] are < 1.0
		{
		let curValue = directionalScale[0];
		bestDirection = 0;
		for (i = 1; i < directionalScale.length; i++)
			{
			if (directionalScale[i] > curValue)
				{
				curValue = directionalScale[i];
				bestDirection = i;
				}
			}
		}

	let ds = {};
	ds.bestDirection = bestDirection;
	ds.scaleFactor = directionalScale[bestDirection];
	return(ds);
}

// Position tip (and scale if image).
// Try to keep tip close to mouse x,y position.
function tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap) {
	let left = 0;
	let top = 0;
	
	if (bestDirection === DIRECTION_BELOW) // below
		{
		top = y + 2*gap; // Double the gap to move tip down slightly.
		left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? 0 : left;
		}
	else if (bestDirection === DIRECTION_ABOVE) // above
		{
		if (y - hintHeight - gap >= 0)
			{
			top = y - hintHeight - gap;
			}
		else
			{
			top = 0;
			}
		let left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? 0 : left;
		}
	else if (bestDirection === DIRECTION_RIGHT) // right
		{
		left = x + gap;
		let top =
			(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight - gap;
		top = (top < 0) ? 0 : top;
		}
	else
		// if (bestDirection === DIRECTION_LEFT) // left
		{
		if (x - hintWidth - gap >= 0)
			{
			left = x - hintWidth - gap;
			}
		else
			{
			left = 0;
			}
		let top =
			(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight - gap;
		top = (top < 0) ? 0 : top;
		}

	// Some fine-tuning to keep as much of the tip visible as possible.
	// Top left portion preferred.
	if (top + hintHeight > windowHeight)
		{
		let offBottom = top + hintHeight - windowHeight;
		top -= offBottom;
		}
	if (top < 0)
		{
		top = 0;
		}
	if (left + hintWidth > windowWidth)
		{
		let offRight = left + hintWidth - windowWidth;		
		left -= offRight;
		}
	if (left < 0)
		{
		left = 0;
		}

	if (top > 0)
		{
		top += "px";
		}
	if (left > 0)
		{
		left += "px";
		}
	
	let topLeft = {};
	topLeft.top = top;
	topLeft.left = left;

	return(topLeft);
}

// The main event.
function showhint(hintContents, obj, e, tipwidth, isAnImage, shouldDecode) {
	"use strict";

	if (shouldDecode === undefined)
		{
		shouldDecode = false;
		}

	if (typeof shouldDecode === "string")
		{
		if (shouldDecode.toLowerCase() === "true")
			{
			shouldDecode = true;
			}
		else
			{
			shouldDecode = false;
			}
		}

	if (typeof isAnImage === "string")
		{
		if (isAnImage.toLowerCase() === "true")
			{
			isAnImage = true;
			}
		else
			{
			isAnImage = false;
			}
		}
	
	if (shouldDecode)
		{
		setTimeout(function() {
			showWithFreshPort(decodeHint(hintContents), obj, e, tipwidth, isAnImage);
			}, 100);
		}
	else
		{
		setTimeout(function() {
			showWithFreshPort(hintContents, obj, e, tipwidth, isAnImage);
			}, 100);
		}
	}

function decodeHint(text) {
	text = decodeURIComponent(text);
	
	return(text);
}

// Special handling for some images: if hintContents looks like
//<img src="http://192.168.1.132:81/Viewer/imagefile.png">
// then we take what's in the "81" position as IntraMine's Main port, and what's in
// the "Viewer" spot as a Short name. Then call back to the Main port requesting a free
// port for the Short name, and replace the "81" in hintContents with the free port number.
// Also strip out the Short name, it was needed only to tell Main which server we wanted.
// For other img src values, just pass them along to showhinAfterDelay unchanged.
// (The fancy footwork with the port is an attempt to get the port number of a service that is
// running and not under maintenance. This allows showhint to show the image if there are two
// or more instances of a service running, even if one is doing maintenance.)
async function showWithFreshPort(hintContents, obj, e, tipwidth, isAnImage) {
	let hintShown = false;
	let image_url = "";

	if (isAnImage)
		{
		image_url = srcURL(hintContents);

		if (image_url !== "")
			{
			// Match eg http://192.168.1.132:81/Viewer/...
			let urlMatch = /^http\:\/\/([0-9\.]+)\:(\d+)\/([A-Za-z_]+)\/(.+?)$/.exec(image_url);
			if (urlMatch !== null)
				{
				let ip = urlMatch[1];
				let port = urlMatch[2];
				let shortName = urlMatch[3];
				let path = urlMatch[4];
				
				if (port === shMainPort) // Request good port number from shMainPort
					{
					hintShown = true; // Give up if we can't show it here.
					// However, if we're on an iPad (shOnMobile), try to use our current server's
					// port rather than asking Main to supply a fresh one - Apple really doesn't
					// like any hanky panky with the port number.
					if (shOnMobile && port === shMainPort && shOurServerPort !== 0)
						{
						let rePort = new RegExp(port);
						hintContents = hintContents.replace(rePort, shOurServerPort);
						let reName = new RegExp(shortName + "\/");
						hintContents = hintContents.replace(reName, "");
						showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
						}
					else
						{
						try {
							let theAction = 'http://' + ip + ':' + port + '/' +
							shortName + '/?req=portNumber';

							const response = await fetch(theAction);
							if (response.ok)
								{
								let resp = await response.text(); 

								if (!isNaN(resp))
									{
									// Replace port with resp in hintContents. And remove
									// server short name.
									let rePort = new RegExp(port);
									hintContents = hintContents.replace(rePort, resp);
									let reName = new RegExp(shortName + "\/");
									hintContents = hintContents.replace(reName, "");
									showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
									}
								}
							}
						catch(error) {
							console.log('Connection error in showWithFreshPort!');
							}
						}
					}
				}
			}
		}
	
	if (!hintShown)
		{
		hintContents = updateImagePortInHintContent(hintContents);
		showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
		}
	}

function updateImagePortInHintContent(hintContent) {
	if (typeof ourSSListeningPort !== 'undefined')
	{
	// src="
	const regex = new RegExp("src=\"http://" + mainIP + ":" + theMainPort + "\/[^\/]+", "g");
	hintContent = hintContent.replace(regex, "src=\"http://" + mainIP + ":" + ourSSListeningPort);
	// src='
	const regex2 = new RegExp("src='http://" + mainIP + ":" + theMainPort + "\/[^\/]+", "g");
	hintContent = hintContent.replace(regex2, "src='http://" + mainIP + ":" + ourSSListeningPort);
	// src=&quot; because you never know....
	const regex3 = new RegExp("src=&quot;http://" + mainIP + ":" + theMainPort + "\/[^\/]+", "g");
	hintContent = hintContent.replace(regex3, "src=\&quot;http://" + mainIP + ":" + ourSSListeningPort);
	}

	return(hintContent);
}
	
function showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage) {
	"use strict";
	
	if (overAnchorTimer !== null)
		{
		window.clearTimeout(overAnchorTimer);
		overAnchorTimer = null;
		}

	if (document.getElementById("hintbox") !== null)
		{
		hintElement = document.getElementById("hintbox");

		hintElement.innerHTML = hintContents;
		if (isAnImage)
			{
			hintElement.style.width = 'auto';
			}
		else
			{
			hintElement.style.width = "650px";
			}

		setTimeout(function() {
			showhintAtferSettingHTML(hintContents, obj, e, tipwidth, isAnImage);
			}, 200);
		}
}

function showhintAtferSettingHTML(hintContents, obj, e, tipwidth, isAnImage) {
	let rect = hintElement.getBoundingClientRect();
	rect = hintElement.getBoundingClientRect(); // sic
	let currentWidth = rect.width;
	let currentHeight = rect.height;
	tipwidth = currentWidth;
	hintParams.tipWidth = currentWidth;
	hintParams.tipHeight = currentHeight;
	
	if (!hasClass(obj, hitAnchorClassName))
		{
		addClass(obj, hitAnchorClassName);
		}

	removeClass(hintElement, definitionClassName);
	
	hideTipJustInCase(obj);
	
	addClass(obj, anchorClassName);

	// Check if mouse is still over element (which must have
	// class hintanchor or plainhintanchor)
	let stillOver = mouseStillOverTipOwner(obj);

	if (!stillOver)
		{
		hintElement.style.visibility = "hidden";
		hintElement.style.left = "-500px";
		removeClass(obj, anchorClassName);
		return;
		}

	hintElement.style.left = "-500px";
	hintElement.style.top = "-500px";
	if (tipwidth === "")
		{
		tipwidth = "300px";
		}
	hintElement.widthobj = hintElement.style;

	// Horrible hack
	hintContents = hintContents.replace(/__IMSPC__/g, "%20");

	hintParams.hintContents = hintContents;
	hintParams.x = e.clientX;
	
	let viewportOffset = obj.getBoundingClientRect();
	if (viewportOffset.top !== 0)
		{
		hintParams.y = viewportOffset.top;
		}
	else
		{
		// Soldier on, use the cursor position.
		hintParams.y = e.pageY;
		// Change the background color: mostly this will be triggered
		// for a hint showing links to definitions.
		addClass(hintElement, definitionClassName);
		}
	
	hintParams.isAnImage = isAnImage;
	
	// Note we re-get the image_url since it might have changed.
	let image_url = srcURL(hintContents); // Stubbed out, always returns ""
	if (image_url !== "")
		{
		let my_image = new Image();
		my_image.onload = function() {
			positionAndShowHint();
		};
		my_image.src = image_url;
		hintParams.theImage = my_image;
		}
	else
		{
		positionAndShowHint();
		}

	document.addEventListener('mousemove', recordMousePosition);
	document.documentElement.addEventListener('mouseleave', handleMouseLeave);

	if (typeof window.ontouchstart === 'undefined')
		{
		overAnchorTimer = window.setTimeout(function() {
			hideTipIfMouseHasLeft(obj);
		}, 500);
		}
}


function handleMouseLeave() {
	hideTip();
}

// If see src="something", return something, else "".
// The something should be in single or double quotes of some sort.
// Stubbed out, not needed at the moment.
function srcURL(hintContents) {
	let image_url = "";
	// TEST ONLY
	return("");
	
	let arrayMatch = null;

	if ((arrayMatch = /src='([^']+?)'/.exec(hintContents)) ||
		(arrayMatch = /src="([^"]+?)"/.exec(hintContents)) ||
		(arrayMatch = /src=\&quot\;(.+?)\&quot\;/.exec(hintContents)) ||
		(arrayMatch = /src=\&apos\;(.+?)\&apos\;/.exec(hintContents)) )
		{
		image_url = arrayMatch[1];
		}

	return(image_url);
}

function hideTipIfMouseHasLeft(obj) {
	if (mouseStillOverTipOwner(obj) || mouseStillOverHintbox())
		{
		overAnchorTimer = window.setTimeout(function() {
			hideTipIfMouseHasLeft(obj);
		}, 500);
		}
	else
		{
		hideTip();
		}
}

function hideTipJustInCase(obj) {
	hideTip();
}

function mouseStillOverTipOwner(obj) {
	let stillOver = false;

	let anks = document.getElementsByClassName(anchorClassName);
	let el = null;
	if (anks.length > 0)
		{
		el = anks[0];
		}
	else
		{
		el = obj;
		}

	if (el !== null)
		{
		let c = window.getComputedStyle(el).getPropertyValue('border-top-style');
		stillOver = (c === 'hidden') ? true : false;
		if (!stillOver)
			{
			let hoveredElement = document.querySelectorAll(':hover');
			hoveredElement = hoveredElement[hoveredElement.length - 1];
			if (typeof(hoveredElement) !== 'undefined' && typeof(hoveredElement.innerHTML) !== 'undefined' && hoveredElement.innerHTML === obj.innerHTML)
				{
				stillOver = true;
				}
			}
		}

	return (stillOver);
}

function mouseStillOverHintbox() {
	let stillOver = false;

	let elements = document.elementsFromPoint(cursor_x, cursor_y);

	for (var i = 0; i < elements.length; i++) {
		let elementId = elements[i].id;
		if (elementId === "hintbox")
			{
			stillOver = true;
			break;
			}
		}

	return(stillOver);
}

function recordMousePosition(evt) {
	cursor_x = evt.pageX;
	cursor_y = evt.pageY;
}

function hideTip(e) {
	hintElement.style.visibility = "hidden";
	hintElement.innerHTML = '';
	hintElement.style.left = "-500px";
	hintElement.style.width = "auto";
	hintElement.style.height = "auto";
	let anks = document.getElementsByClassName(anchorClassName);
	if (anks.length > 0)
		{
		for (i = anks.length - 1; i >= 0; --i)
			{
			removeClass(anks[i], anchorClassName);
			}
		}

	
	document.removeEventListener('mousemove', recordMousePosition);
	document.removeEventListener('mouseleave', handleMouseLeave);
}

function touchhidetip(e) {
	hintElement.style.visibility = "hidden";
	hintElement.style.left = "-500px";
}

function createhintbox() {
	let divblock = document.createElement("div");
	divblock.setAttribute("id", "hintbox");
	document.body.appendChild(divblock);

	hintElement = document.getElementById("hintbox");
	if (hintElement === null)
		{
		console.log("tooptip.js#createhintbox cannot create hintbox!");
		return;
		}
	hintElement.style.visibility = "hidden";
	hintElement.style.left = "-500px";
	
	if (shOnMobile)
		{
		hintElement.addEventListener("touchstart", function(e) {touchhidetip();});
		}
}

// For remote iPad "debugging" since remotedebug_ios_webkit_adapter has stopped working.
// For Viewer, errorID element is up near the top of the window.
// (iPad has been abandoned, too hard to debug.)
function writeMessageToWindow(str) {
	let errorElem = document.getElementById(errorID);
	if (errorElem !== null)
		{
		errorElem.innerHTML = "<p>" + str + "</p>";
		}
}

if (window.addEventListener)
	window.addEventListener("load", createhintbox, false);
else if (window.attachEvent)
	window.attachEvent("onload", createhintbox);
else if (document.getElementById)
	window.onload = createhintbox;

</script>
<script type="text/javascript">

// Whitespace (or punctuation) checker. Copied from somewhere, and it works.
function isW(s) {
	return /[ \t\uFFE5\^\+=`~<>{}\[\]|\u3000-\u303F!-#%-\x2A,-/:;\x3F@\x5B-\x5D\x7B}\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/.test(s);
	
	
// return /[ \f\n\r\t\v\u00A0\u2028\u2029]/.test(s);
}

</script>
<script type="text/javascript">
/*!***************************************************
* mark.js v9.0.0
* https://markjs.io/
* Copyright (c) 20142018, Julian Khnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Mark=t()}(this,function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var i=
/* */
function(){function e(n){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5e3;t(this,e),this.ctx=n,this.iframes=r,this.exclude=o,this.iframesTimeout=i}return r(e,[{key:"getContexts",value:function(){var e=[];return(void 0!==this.ctx&&this.ctx?NodeList.prototype.isPrototypeOf(this.ctx)?Array.prototype.slice.call(this.ctx):Array.isArray(this.ctx)?this.ctx:"string"==typeof this.ctx?Array.prototype.slice.call(document.querySelectorAll(this.ctx)):[this.ctx]:[]).forEach(function(t){var n=e.filter(function(e){return e.contains(t)}).length>0;-1!==e.indexOf(t)||n||e.push(t)}),e}},{key:"getIframeContents",value:function(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};try{var o=e.contentWindow;if(n=o.document,!o||!n)throw new Error("iframe inaccessible")}catch(e){r()}n&&t(n)}},{key:"isIframeBlank",value:function(e){var t="about:blank",n=e.getAttribute("src").trim();return e.contentWindow.location.href===t&&n!==t&&n}},{key:"observeIframeLoad",value:function(e,t,n){var r=this,o=!1,i=null,a=function a(){if(!o){o=!0,clearTimeout(i);try{r.isIframeBlank(e)||(e.removeEventListener("load",a),r.getIframeContents(e,t,n))}catch(e){n()}}};e.addEventListener("load",a),i=setTimeout(a,this.iframesTimeout)}},{key:"onIframeReady",value:function(e,t,n){try{"complete"===e.contentWindow.document.readyState?this.isIframeBlank(e)?this.observeIframeLoad(e,t,n):this.getIframeContents(e,t,n):this.observeIframeLoad(e,t,n)}catch(e){n()}}},{key:"waitForIframes",value:function(e,t){var n=this,r=0;this.forEachIframe(e,function(){return!0},function(e){r++,n.waitForIframes(e.querySelector("html"),function(){--r||t()})},function(e){e||t()})}},{key:"forEachIframe",value:function(t,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},a=t.querySelectorAll("iframe"),s=a.length,c=0;a=Array.prototype.slice.call(a);var u=function(){--s<=0&&i(c)};s||u(),a.forEach(function(t){e.matches(t,o.exclude)?u():o.onIframeReady(t,function(e){n(t)&&(c++,r(e)),u()},u)})}},{key:"createIterator",value:function(e,t,n){return document.createNodeIterator(e,t,n,!1)}},{key:"createInstanceOnIframe",value:function(t){return new e(t.querySelector("html"),this.iframes)}},{key:"compareNodeIframe",value:function(e,t,n){if(e.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_PRECEDING){if(null===t)return!0;if(t.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING)return!0}return!1}},{key:"getIteratorNode",value:function(e){var t=e.previousNode();return{prevNode:t,node:null===t?e.nextNode():e.nextNode()&&e.nextNode()}}},{key:"checkIframeFilter",value:function(e,t,n,r){var o=!1,i=!1;return r.forEach(function(e,t){e.val===n&&(o=t,i=e.handled)}),this.compareNodeIframe(e,t,n)?(!1!==o||i?!1===o||i||(r[o].handled=!0):r.push({val:n,handled:!0}),!0):(!1===o&&r.push({val:n,handled:!1}),!1)}},{key:"handleOpenIframes",value:function(e,t,n,r){var o=this;e.forEach(function(e){e.handled||o.getIframeContents(e.val,function(e){o.createInstanceOnIframe(e).forEachNode(t,n,r)})})}},{key:"iterateThroughNodes",value:function(e,t,n,r,o){for(var i,a,s,c=this,u=this.createIterator(t,e,r),l=[],h=[];s=void 0,s=c.getIteratorNode(u),a=s.prevNode,i=s.node;)this.iframes&&this.forEachIframe(t,function(e){return c.checkIframeFilter(i,a,e,l)},function(t){c.createInstanceOnIframe(t).forEachNode(e,function(e){return h.push(e)},r)}),h.push(i);h.forEach(function(e){n(e)}),this.iframes&&this.handleOpenIframes(l,e,n,r),o()}},{key:"forEachNode",value:function(e,t,n){var r=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},i=this.getContexts(),a=i.length;a||o(),i.forEach(function(i){var s=function(){r.iterateThroughNodes(e,i,t,n,function(){--a<=0&&o()})};r.iframes?r.waitForIframes(i,s):s()})}}],[{key:"matches",value:function(e,t){var n="string"==typeof t?[t]:t,r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.oMatchesSelector||e.webkitMatchesSelector;if(r){var o=!1;return n.every(function(t){return!r.call(e,t)||(o=!0,!1)}),o}return!1}}]),e}(),a=
/* */
function(){function e(n){t(this,e),this.opt=o({},{diacritics:!0,synonyms:{},accuracy:"partially",caseSensitive:!1,ignoreJoiners:!1,ignorePunctuation:[],wildcards:"disabled"},n)}return r(e,[{key:"create",value:function(e){return"disabled"!==this.opt.wildcards&&(e=this.setupWildcardsRegExp(e)),e=this.escapeStr(e),Object.keys(this.opt.synonyms).length&&(e=this.createSynonymsRegExp(e)),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),this.opt.diacritics&&(e=this.createDiacriticsRegExp(e)),e=this.createMergedBlanksRegExp(e),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.createJoinersRegExp(e)),"disabled"!==this.opt.wildcards&&(e=this.createWildcardsRegExp(e)),e=this.createAccuracyRegExp(e),new RegExp(e,"gm".concat(this.opt.caseSensitive?"":"i"))}},{key:"sortByLength",value:function(e){return e.sort(function(e,t){return e.length===t.length?e>t?1:-1:t.length-e.length})}},{key:"escapeStr",value:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}},{key:"createSynonymsRegExp",value:function(e){var t=this,n=this.opt.synonyms,r=this.opt.caseSensitive?"":"i",o=this.opt.ignoreJoiners||this.opt.ignorePunctuation.length?"\0":"";for(var i in n)if(n.hasOwnProperty(i)){var a=Array.isArray(n[i])?n[i]:[n[i]];a.unshift(i),(a=this.sortByLength(a).map(function(e){return"disabled"!==t.opt.wildcards&&(e=t.setupWildcardsRegExp(e)),e=t.escapeStr(e)}).filter(function(e){return""!==e})).length>1&&(e=e.replace(new RegExp("(".concat(a.map(function(e){return t.escapeStr(e)}).join("|"),")"),"gm".concat(r)),o+"(".concat(a.map(function(e){return t.processSynonyms(e)}).join("|"),")")+o))}return e}},{key:"processSynonyms",value:function(e){return(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),e}},{key:"setupWildcardsRegExp",value:function(e){return(e=e.replace(/(?:\\)*\?/g,function(e){return"\\"===e.charAt(0)?"?":""})).replace(/(?:\\)*\*/g,function(e){return"\\"===e.charAt(0)?"*":""})}},{key:"createWildcardsRegExp",value:function(e){var t="withSpaces"===this.opt.wildcards;return e.replace(/\u0001/g,t?"[\\S\\s]?":"\\S?").replace(/\u0002/g,t?"[\\S\\s]*?":"\\S*")}},{key:"setupIgnoreJoinersRegExp",value:function(e){return e.replace(/[^(|)\\]/g,function(e,t,n){var r=n.charAt(t+1);return/[(|)\\]/.test(r)||""===r?e:e+"\0"})}},{key:"createJoinersRegExp",value:function(e){var t=[],n=this.opt.ignorePunctuation;return Array.isArray(n)&&n.length&&t.push(this.escapeStr(n.join(""))),this.opt.ignoreJoiners&&t.push("\\u00ad\\u200b\\u200c\\u200d"),t.length?e.split(/\u0000+/).join("[".concat(t.join(""),"]*")):e}},{key:"createDiacriticsRegExp",value:function(e){var t=this.opt.caseSensitive?"":"i",n=this.opt.caseSensitive?["a","A","c","C","d","D","e","E","i","I","l","L","n","N","o","O","r","R","s","S","t","T","u","U","y","Y","z","Z"]:["aA","cC","dD","eE","iI","lL","nN","oO","rR","sS","tT","uU","yY","zZ"],r=[];return e.split("").forEach(function(o){n.every(function(n){if(-1!==n.indexOf(o)){if(r.indexOf(n)>-1)return!1;e=e.replace(new RegExp("[".concat(n,"]"),"gm".concat(t)),"[".concat(n,"]")),r.push(n)}return!0})}),e}},{key:"createMergedBlanksRegExp",value:function(e){return e.replace(/[\s]+/gim,"[\\s]+")}},{key:"createAccuracyRegExp",value:function(e){var t=this,n=this.opt.accuracy,r="string"==typeof n?n:n.value,o="string"==typeof n?[]:n.limiters,i="";switch(o.forEach(function(e){i+="|".concat(t.escapeStr(e))}),r){case"partially":default:return"()(".concat(e,")");case"complementary":return i="\\s"+(i||this.escapeStr("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")),"()([^".concat(i,"]*").concat(e,"[^").concat(i,"]*)");case"exactly":return"(^|\\s".concat(i,")(").concat(e,")(?=$|\\s").concat(i,")")}}}]),e}(),s=
/* */
function(){function n(e){t(this,n),this.ctx=e,this.ie=!1;var r=window.navigator.userAgent;(r.indexOf("MSIE")>-1||r.indexOf("Trident")>-1)&&(this.ie=!0)}return r(n,[{key:"log",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"debug",r=this.opt.log;this.opt.debug&&"object"===e(r)&&"function"==typeof r[n]&&r[n]("mark.js: ".concat(t))}},{key:"getSeparatedKeywords",value:function(e){var t=this,n=[];return e.forEach(function(e){t.opt.separateWordSearch?e.split(" ").forEach(function(e){e.trim()&&-1===n.indexOf(e)&&n.push(e)}):e.trim()&&-1===n.indexOf(e)&&n.push(e)}),{keywords:n.sort(function(e,t){return t.length-e.length}),length:n.length}}},{key:"isNumeric",value:function(e){return Number(parseFloat(e))==e}},{key:"checkRanges",value:function(e){var t=this;if(!Array.isArray(e)||"[object Object]"!==Object.prototype.toString.call(e[0]))return this.log("markRanges() will only accept an array of objects"),this.opt.noMatch(e),[];var n=[],r=0;return e.sort(function(e,t){return e.start-t.start}).forEach(function(e){var o=t.callNoMatchOnInvalidRanges(e,r),i=o.start,a=o.end;o.valid&&(e.start=i,e.length=a-i,n.push(e),r=a)}),n}},{key:"callNoMatchOnInvalidRanges",value:function(e,t){var n,r,o=!1;return e&&void 0!==e.start?(r=(n=parseInt(e.start,10))+parseInt(e.length,10),this.isNumeric(e.start)&&this.isNumeric(e.length)&&r-t>0&&r-n>0?o=!0:(this.log("Ignoring invalid or overlapping range: "+"".concat(JSON.stringify(e))),this.opt.noMatch(e))):(this.log("Ignoring invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)),{start:n,end:r,valid:o}}},{key:"checkWhitespaceRanges",value:function(e,t,n){var r,o=!0,i=n.length,a=t-i,s=parseInt(e.start,10)-a;return(r=(s=s>i?i:s)+parseInt(e.length,10))>i&&(r=i,this.log("End range automatically set to the max value of ".concat(i))),s<0||r-s<0||s>i||r>i?(o=!1,this.log("Invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)):""===n.substring(s,r).replace(/\s+/g,"")&&(o=!1,this.log("Skipping whitespace only range: "+JSON.stringify(e)),this.opt.noMatch(e)),{start:s,end:r,valid:o}}},{key:"getTextNodes",value:function(e){var t=this,n="",r=[];this.iterator.forEachNode(NodeFilter.SHOW_TEXT,function(e){r.push({start:n.length,end:(n+=e.textContent).length,node:e})},function(e){return t.matchesExclude(e.parentNode)?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},function(){e({value:n,nodes:r})})}},{key:"matchesExclude",value:function(e){return i.matches(e,this.opt.exclude.concat(["script","style","title","head","html"]))}},{key:"wrapRangeInTextNode",value:function(e,t,n){var r=this.opt.element?this.opt.element:"mark",o=e.splitText(t),i=o.splitText(n-t),a=document.createElement(r);return a.setAttribute("data-markjs","true"),this.opt.className&&a.setAttribute("class",this.opt.className),a.textContent=o.textContent,o.parentNode.replaceChild(a,o),i}},{key:"wrapRangeInMappedTextNode",value:function(e,t,n,r,o){var i=this;e.nodes.every(function(a,s){var c=e.nodes[s+1];if(void 0===c||c.start>t){if(!r(a.node))return!1;var u=t-a.start,l=(n>a.end?a.end:n)-a.start,h=e.value.substr(0,a.start),f=e.value.substr(l+a.start);if(a.node=i.wrapRangeInTextNode(a.node,u,l),e.value=h+f,e.nodes.forEach(function(t,n){n>=s&&(e.nodes[n].start>0&&n!==s&&(e.nodes[n].start-=l),e.nodes[n].end-=l)}),n-=l,o(a.node.previousSibling,a.start),!(n>a.end))return!1;t=a.end}return!0})}},{key:"wrapGroups",value:function(e,t,n,r){return r((e=this.wrapRangeInTextNode(e,t,t+n)).previousSibling),e}},{key:"separateGroups",value:function(e,t,n,r,o){for(var i=t.length,a=1;a<i;a++){var s=e.textContent.indexOf(t[a]);t[a]&&s>-1&&r(t[a],e)&&(e=this.wrapGroups(e,s,t[a].length,o))}return e}},{key:"wrapMatches",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){t.nodes.forEach(function(t){var o;for(t=t.node;null!==(o=e.exec(t.textContent))&&""!==o[a];){if(i.opt.separateGroups)t=i.separateGroups(t,o,a,n,r);else{if(!n(o[a],t))continue;var s=o.index;if(0!==a)for(var c=1;c<a;c++)s+=o[c].length;t=i.wrapGroups(t,s,o[a].length,r)}e.lastIndex=0}}),o()})}},{key:"wrapMatchesAcrossElements",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){for(var s;null!==(s=e.exec(t.value))&&""!==s[a];){var c=s.index;if(0!==a)for(var u=1;u<a;u++)c+=s[u].length;var l=c+s[a].length;i.wrapRangeInMappedTextNode(t,c,l,function(e){return n(s[a],e)},function(t,n){e.lastIndex=n,r(t)})}o()})}},{key:"wrapRangeFromIndex",value:function(e,t,n,r){var o=this;this.getTextNodes(function(i){var a=i.value.length;e.forEach(function(e,r){var s=o.checkWhitespaceRanges(e,a,i.value),c=s.start,u=s.end;s.valid&&o.wrapRangeInMappedTextNode(i,c,u,function(n){return t(n,e,i.value.substring(c,u),r)},function(t){n(t,e)})}),r()})}},{key:"unwrapMatches",value:function(e){for(var t=e.parentNode,n=document.createDocumentFragment();e.firstChild;)n.appendChild(e.removeChild(e.firstChild));t.replaceChild(n,e),this.ie?this.normalizeTextNode(t):t.normalize()}},{key:"normalizeTextNode",value:function(e){if(e){if(3===e.nodeType)for(;e.nextSibling&&3===e.nextSibling.nodeType;)e.nodeValue+=e.nextSibling.nodeValue,e.parentNode.removeChild(e.nextSibling);else this.normalizeTextNode(e.firstChild);this.normalizeTextNode(e.nextSibling)}}},{key:"markRegExp",value:function(e,t){var n=this;this.opt=t,this.log('Searching with expression "'.concat(e,'"'));var r=0,o="wrapMatches";this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),this[o](e,this.opt.ignoreGroups,function(e,t){return n.opt.filter(t,e,r)},function(e){r++,n.opt.each(e)},function(){0===r&&n.opt.noMatch(e),n.opt.done(r)})}},{key:"mark",value:function(e,t){var n=this;this.opt=t;var r=0,o="wrapMatches",i=this.getSeparatedKeywords("string"==typeof e?[e]:e),s=i.keywords,c=i.length;this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),0===c?this.opt.done(r):function e(t){var i=new a(n.opt).create(t),u=0;n.log('Searching with expression "'.concat(i,'"')),n[o](i,1,function(e,o){return n.opt.filter(o,t,r,u)},function(e){u++,r++,n.opt.each(e)},function(){0===u&&n.opt.noMatch(t),s[c-1]===t?n.opt.done(r):e(s[s.indexOf(t)+1])})}(s[0])}},{key:"markRanges",value:function(e,t){var n=this;this.opt=t;var r=0,o=this.checkRanges(e);o&&o.length?(this.log("Starting to mark with the following ranges: "+JSON.stringify(o)),this.wrapRangeFromIndex(o,function(e,t,r,o){return n.opt.filter(e,t,r,o)},function(e,t){r++,n.opt.each(e,t)},function(){n.opt.done(r)})):this.opt.done(r)}},{key:"unmark",value:function(e){var t=this;this.opt=e;var n=this.opt.element?this.opt.element:"*";n+="[data-markjs]",this.opt.className&&(n+=".".concat(this.opt.className)),this.log('Removal selector "'.concat(n,'"')),this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT,function(e){t.unwrapMatches(e)},function(e){var r=i.matches(e,n),o=t.matchesExclude(e);return!r||o?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},this.opt.done)}},{key:"opt",set:function(e){this._opt=o({},{element:"",className:"",exclude:[],iframes:!1,iframesTimeout:5e3,separateWordSearch:!0,acrossElements:!1,ignoreGroups:0,each:function(){},noMatch:function(){},filter:function(){return!0},done:function(){},debug:!1,log:window.console},e)},get:function(){return this._opt}},{key:"iterator",get:function(){return new i(this.ctx,this.opt.iframes,this.opt.exclude,this.opt.iframesTimeout)}}]),n}();return function(e){var t=this,n=new s(e);return this.mark=function(e,r){return n.mark(e,r),t},this.markRegExp=function(e,r){return n.markRegExp(e,r),t},this.markRanges=function(e,r){return n.markRanges(e,r),t},this.unmark=function(e){return n.unmark(e),t},this}});

</script>
<script type="text/javascript">
// wordAtInsertionPt.js
// See https://stackoverflow.com/questions/2444430/how-to-get-a-word-under-cursor-using-javascript 
// soln by Drakes https://stackoverflow.com/users/1938889/drakes
// (Modified from the original.)
// In IntraMine, getFullWord() is called by viewerStart.js#expandSelectionToWordIfPossible(),
// the goal being to select a whole word with one click when in a non-Editable view of a file.

// Get the full word the cursor is over regardless of span breaks
function getFullWord(event) {
let i, begin, end, range, textNode, offset;

// Internet Explorer
if (document.body.createTextRange) {
   try {
	 range = document.body.createTextRange();
	 range.moveToPoint(event.clientX, event.clientY);
	 range.select();
	 range = getTextRangeBoundaryPosition(range, true);
  
	 textNode = range.node;
	 offset = range.offset;
   } catch(e) {
   return(document.createRange()); // Sigh, IE
   }
}

// Firefox, Safari
// REF: https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint
else if (document.caretPositionFromPoint) {
  range = document.caretPositionFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.offsetNode;
	  offset = range.offset;
	  }
  else
	  {
	  return(document.createRange());
	  }

  // Chrome
  // REF: https://developer.mozilla.org/en-US/docs/Web/API/document/caretRangeFromPoint
} else if (document.caretRangeFromPoint) {
  range = document.caretRangeFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.startContainer;
	  offset = range.startOffset;
	  }
  else
	  {
	  return(document.createRange());
	  }
}

// Only act on text nodes
if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
	return(document.createRange());
}

let data = textNode.textContent;

// Sometimes the offset can be at the 'length' of the data.
// It might be a bug with this 'experimental' feature - 
// compensate for this below
if (offset >= data.length) {
  offset = data.length - 1;
}

// Scan behind the current character until whitespace or punct is found, or beginning
i = begin = end = offset;
// Don't scan behind if we're at the end of a line and last char is not a word char.
let blockedAtLineEnd = ( offset === data.length - 1 && isW(data[offset]) );
if (!blockedAtLineEnd)
	{
	while ( previousCharIsAWordChar(data, i - 1) ) {
	  //while (i > 0 && !isW(data[i - 1])) {
	  i--;
	  }
	}
begin = i;

// Scan ahead of the current character until whitespace or punct is found, or end
// unless char at offset is not a word char.
i = offset;
let offsetIsWordChar = nextCharIsAWordChar(data, offset);
if (nextCharIsAWordChar(data, i))
	{
	while ( nextCharIsAWordChar(data, i + 1) ) {
	//while (i < data.length - 1 && !isW(data[i + 1])) {
	  i++;
	}
	}
end = i;

// This is our temporary word
let word = data.substring(begin, end + 1);

// If at a node boundary, cross over and see what 
// the next word is and check if this should be added to our temp word
if (end === data.length - 1 || begin === 0) {

  let nextNode = getNextNode(textNode);
  let prevNode = getPrevNode(textNode);

  // Get the next node text
  if (end == data.length - 1 && nextNode) {
  let nextText = nextNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = 0;
	while ( nextCharIsAWordChar(nextText, i) ) {
	  word += nextText[i++];
	}

  } else if (begin === 0 && prevNode) {
	// Get the previous node text
  let prevText = prevNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = prevText.length - 1;
	while ( previousCharIsAWordChar(prevText, i) ) {
	  word = prevText[i--] + word;
	}
  }
}

// Sometimes a bad last char is tacked on?
if (word.length)
	{
	word = remove_linebreaks(word);
//	if (isW(word[ word.length - 1]))
//		{
//		word = word.substring(0, word.length - 1);
//		}
	}

// Return the word, and its start and end offsets. Kill selection of '.' or other non-word
// if click happened past end of line and the line ends in non-word char such as '.'.
if (blockedAtLineEnd)
	{
	word = '';
	begin = end;
	}
else
	{
	if (offsetIsWordChar)
		{
		++end;
		}
	}

let obj = {
		theWord: word,
		theBegin: begin,
		theEnd: end
		};

return(obj);

//return word;
} // getFullWord()


// Helper functions

function remove_linebreaks(str ) { 
return str.replace( /[\r\n]+/gm, "" ); 
} 

// Looking in the forward direction, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the following char is not white or punctuation.
function nextCharIsAWordChar(theText, i) {
	let result = ( i < theText.length 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && (i+1) < theText.length && !isW(theText[i+1])))
		  );
	return(result);
	}

// Looking in reverse, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the previous char is not white or punctuation.
function previousCharIsAWordChar(theText, i) {
	let result = ( i >= 0 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && i > 0 && !isW(theText[i-1])))
		  );
	return(result);
	}


// Barrier nodes are BR, DIV, P, PRE, TD, TR, ... 
function isBarrierNode(node) {
return node ? /^(BR|DIV|P|PRE|TD|TR|TABLE)$/i.test(node.nodeName) : true;
}

// Try to find the next adjacent node
function getNextNode(node) {
let n = null;
// Does this node have a sibling?
if (node.nextSibling) {
n = node.nextSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.nextSibling) {
n = node.parentNode.nextSibling;
}
return isBarrierNode(n) ? null : n;
}

// Try to find the prev adjacent node
function getPrevNode(node) {
var n = null;

// Does this node have a sibling?
if (node.previousSibling) {
n = node.previousSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.previousSibling) {
n = node.parentNode.previousSibling;
}
return isBarrierNode(n) ? null : n;
}

// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getChildIndex(node) {
var i = 0;
while( (node = node.previousSibling) ) {
i++;
}
return i;
}

// All this code just to make this work with IE, OTL
// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getTextRangeBoundaryPosition(textRange, isStart) {
var workingRange = textRange.duplicate();
workingRange.collapse(isStart);
var containerElement = workingRange.parentElement();
var workingNode = document.createElement("span");
var comparison, workingComparisonType = isStart ?
"StartToStart" : "StartToEnd";

var boundaryPosition, boundaryNode;

// Move the working range through the container's children, starting at
// the end and working backwards, until the working range reaches or goes
// past the boundary we're interested in
do {
containerElement.insertBefore(workingNode, workingNode.previousSibling);
workingRange.moveToElementText(workingNode);
} while ( (comparison = workingRange.compareEndPoints(
workingComparisonType, textRange)) > 0 && workingNode.previousSibling);

// We've now reached or gone past the boundary of the text range we're
// interested in so have identified the node we want
boundaryNode = workingNode.nextSibling;
if (comparison == -1 && boundaryNode) {
// This must be a data node (text, comment, cdata) since we've overshot.
// The working range is collapsed at the start of the node containing
// the text range's boundary, so we move the end of the working range
// to the boundary point and measure the length of its text to get
// the boundary's offset within the node
workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

boundaryPosition = {
  node: boundaryNode,
  offset: workingRange.text.length
};
} else {
// We've hit the boundary exactly, so this must be an element
boundaryPosition = {
  node: containerElement,
  offset: getChildIndex(workingNode)
};
}

// Clean up
workingNode.parentNode.removeChild(workingNode);

return boundaryPosition;
}

</script>
<script type="text/javascript">
// LightRange.js - A simple and lightweight selection, range and caret information library in native JavaScript, with an additional selection save & restore system. - https://github.com/n457/LightRange.js
// Version 2.2.0
// MIT License - Copyright (c) 2015 Bertrand Vignaud-Lerouge / n457 - https://github.com/n457
var LightRange=function(){};
LightRange.prototype.getSelectionInfo=function(){var a={};if(window.getSelection){var b=window.getSelection(),e=document.body.scrollTop,f=document.body.scrollLeft;if(0<b.rangeCount){var d=b.getRangeAt(0).cloneRange(),c=d.getBoundingClientRect();0===c.height&&(c=d.getClientRects()[0]);c&&(a.width=c.width,a.height=c.height,a.xStart=c.left+f,a.yStart=c.top+e);a.text=b.toString();a.charStart=d.startOffset;a.charEnd=d.endOffset;d.collapse(!1);if(c=d.getClientRects()[0])a.xEnd=c.left+f,a.yEnd=c.top+e}}else if(document.selection)b=
document.selection.createRange(),e=document.documentElement.scrollTop,f=document.documentElement.scrollLeft,a.width=b.boundingWidth,a.height=b.boundingHeight,a.xStart=b.boundingLeft+f,a.yStart=b.boundingTop+e,a.text=b.text,b.collapse(!1),a.xEnd=b.boundingLeft+f,a.yEnd=b.boundingTop+e;else return null;a.text?(a.characters=a.text.replace(/\s/g,"").length,a.charactersAll=a.text.replace(/[\n\r]/g,"").length):(a.characters=0,a.charactersAll=0);return a};
LightRange.prototype.saveSelection=function(){if(window.getSelection){var a=window.getSelection();if(a.getRangeAt&&a.rangeCount)return a.getRangeAt(0)}else return document.selection&&document.selection.createRange?document.selection.createRange():null};LightRange.prototype.restoreSelection=function(a){if(a){if(window.getSelection){var b=window.getSelection();b.removeAllRanges();b.addRange(a)}else if(document.selection&&a.select)a.select();else return null;return a}};var lightrange=new LightRange;

</script>
<script type="text/javascript">
// commonEnglishWords.js: top one hundred or so English words.
// Wanted when deciding what to highlight, common words can take too long in a large file.
// See viewerStart.js for use.

let commonEnglishWords = new Object();


function isCommonEnglishWord(wrd) {
	return(wrd.toLowerCase() in commonEnglishWords);
	}

// This started out as roughly the 200 commonest words, but many have been commented out
// because they're of some interest to developers.
function loadCommonestEnglishWords() {
	commonEnglishWords['I'] = 1;
	commonEnglishWords['a'] = 1;
	commonEnglishWords['about'] = 1;
	commonEnglishWords['after'] = 1;
	commonEnglishWords['again'] = 1;
	commonEnglishWords['against'] = 1;
	commonEnglishWords['all'] = 1;
	commonEnglishWords['also'] = 1;
	commonEnglishWords['an'] = 1;
	commonEnglishWords['and'] = 1;
	commonEnglishWords['another'] = 1;
	commonEnglishWords['any'] = 1;
	commonEnglishWords['around'] = 1;
	commonEnglishWords['as'] = 1;
	commonEnglishWords['ask'] = 1;
	commonEnglishWords['at'] = 1;
	commonEnglishWords['back'] = 1;
	commonEnglishWords['be'] = 1;
	commonEnglishWords['because'] = 1;
	commonEnglishWords['become'] = 1;
	commonEnglishWords['before'] = 1;
	commonEnglishWords['begin'] = 1;
	commonEnglishWords['between'] = 1;
	commonEnglishWords['both'] = 1;
	commonEnglishWords['but'] = 1;
	commonEnglishWords['by'] = 1;
	commonEnglishWords['call'] = 1;
	commonEnglishWords['can'] = 1;
	commonEnglishWords['change'] = 1;
	commonEnglishWords['child'] = 1;
	commonEnglishWords['come'] = 1;
	commonEnglishWords['consider'] = 1;
	commonEnglishWords['could'] = 1;
	commonEnglishWords['course'] = 1;
	commonEnglishWords['day'] = 1;
	//commonEnglishWords['develop'] = 1;
	commonEnglishWords['do'] = 1;
	//commonEnglishWords['down'] = 1;
	commonEnglishWords['during'] = 1;
	commonEnglishWords['each'] = 1;
	commonEnglishWords['early'] = 1;
	commonEnglishWords['end'] = 1;
	commonEnglishWords['even'] = 1;
	commonEnglishWords['eye'] = 1;
	commonEnglishWords['face'] = 1;
	commonEnglishWords['fact'] = 1;
	commonEnglishWords['feel'] = 1;
	commonEnglishWords['few'] = 1;
	//commonEnglishWords['find'] = 1;
	//commonEnglishWords['first'] = 1;
	commonEnglishWords['follow'] = 1;
	commonEnglishWords['for'] = 1;
	//commonEnglishWords['form'] = 1;
	commonEnglishWords['from'] = 1;
	//commonEnglishWords['general'] = 1;
	commonEnglishWords['get'] = 1;
	commonEnglishWords['give'] = 1;
	commonEnglishWords['go'] = 1;
	commonEnglishWords['good'] = 1;
	commonEnglishWords['govern'] = 1;
	commonEnglishWords['great'] = 1;
	commonEnglishWords['group'] = 1;
	commonEnglishWords['hand'] = 1;
	commonEnglishWords['have'] = 1;
	commonEnglishWords['he'] = 1;
	//commonEnglishWords['head'] = 1;
	commonEnglishWords['help'] = 1;
	commonEnglishWords['her'] = 1;
	commonEnglishWords['here'] = 1;
	commonEnglishWords['high'] = 1;
	commonEnglishWords['him'] = 1;
	commonEnglishWords['his'] = 1;
	commonEnglishWords['hold'] = 1;
	commonEnglishWords['home'] = 1;
	commonEnglishWords['house'] = 1;
	commonEnglishWords['how'] = 1;
	commonEnglishWords['however'] = 1;
	commonEnglishWords['if'] = 1;
	commonEnglishWords['in'] = 1;
	//commonEnglishWords['increase'] = 1;
	//commonEnglishWords['interest'] = 1;
	//commonEnglishWords['into'] = 1;
	commonEnglishWords['it'] = 1;
	commonEnglishWords['its'] = 1;
	commonEnglishWords['just'] = 1;
	//commonEnglishWords['keep'] = 1;
	commonEnglishWords['know'] = 1;
	//commonEnglishWords['large'] = 1;
	//commonEnglishWords['last'] = 1;
	commonEnglishWords['late'] = 1;
	//commonEnglishWords['lead'] = 1;
	commonEnglishWords['leave'] = 1;
	commonEnglishWords['let'] = 1;
	commonEnglishWords['lets'] = 1;
	commonEnglishWords['life'] = 1;
	//commonEnglishWords['like'] = 1;
	//commonEnglishWords['line'] = 1;
	commonEnglishWords['little'] = 1;
	//commonEnglishWords['long'] = 1;
	commonEnglishWords['look'] = 1;
	//commonEnglishWords['make'] = 1;
	commonEnglishWords['man'] = 1;
	//commonEnglishWords['many'] = 1;
	commonEnglishWords['may'] = 1;
	commonEnglishWords['me'] = 1;
	//commonEnglishWords['mean'] = 1;
	commonEnglishWords['might'] = 1;
	commonEnglishWords['more'] = 1;
	commonEnglishWords['most'] = 1;
	//commonEnglishWords['move'] = 1;
	commonEnglishWords['much'] = 1;
	commonEnglishWords['must'] = 1;
	commonEnglishWords['my'] = 1;
	commonEnglishWords['nation'] = 1;
	commonEnglishWords['need'] = 1;
	commonEnglishWords['never'] = 1;
	//commonEnglishWords['new'] = 1;
	commonEnglishWords['no'] = 1;
	commonEnglishWords['not'] = 1;
	//commonEnglishWords['now'] = 1;
	//commonEnglishWords['number'] = 1;
	commonEnglishWords['of'] = 1;
	//commonEnglishWords['off'] = 1;
	commonEnglishWords['old'] = 1;
	commonEnglishWords['on'] = 1;
	//commonEnglishWords['one'] = 1;
	commonEnglishWords['only'] = 1;
	//commonEnglishWords['open'] = 1;
	commonEnglishWords['or'] = 1;
	commonEnglishWords['order'] = 1;
	commonEnglishWords['other'] = 1;
	//commonEnglishWords['our'] = 1;
	//commonEnglishWords['out'] = 1;
	commonEnglishWords['over'] = 1;
	//commonEnglishWords['own'] = 1;
	commonEnglishWords['part'] = 1;
	commonEnglishWords['people'] = 1;
	commonEnglishWords['person'] = 1;
	commonEnglishWords['place'] = 1;
	commonEnglishWords['plan'] = 1;
	commonEnglishWords['play'] = 1;
	//commonEnglishWords['point'] = 1;
	//commonEnglishWords['possible'] = 1;
	commonEnglishWords['present'] = 1;
	//commonEnglishWords['problem'] = 1;
	//commonEnglishWords['program'] = 1;
	//commonEnglishWords['public'] = 1;
	//commonEnglishWords['real'] = 1;
	//commonEnglishWords['right'] = 1;
	//commonEnglishWords['run'] = 1;
	//commonEnglishWords['same'] = 1;
	//commonEnglishWords['say'] = 1;
	commonEnglishWords['school'] = 1;
	commonEnglishWords['see'] = 1;
	commonEnglishWords['seem'] = 1;
	//commonEnglishWords['set'] = 1;
	commonEnglishWords['she'] = 1;
	//commonEnglishWords['should'] = 1;
	commonEnglishWords['show'] = 1;
	commonEnglishWords['since'] = 1;
	//commonEnglishWords['small'] = 1;
	commonEnglishWords['so'] = 1;
	//commonEnglishWords['some'] = 1;
	commonEnglishWords['stand'] = 1;
	//commonEnglishWords['state'] = 1;
	commonEnglishWords['still'] = 1;
	commonEnglishWords['such'] = 1;
	//commonEnglishWords['system'] = 1;
	commonEnglishWords['take'] = 1;
	//commonEnglishWords['tell'] = 1;
	commonEnglishWords['than'] = 1;
	commonEnglishWords['that'] = 1;
	commonEnglishWords['the'] = 1;
	commonEnglishWords['their'] = 1;
	commonEnglishWords['them'] = 1;
	commonEnglishWords['then'] = 1;
	commonEnglishWords['there'] = 1;
	commonEnglishWords['these'] = 1;
	commonEnglishWords['they'] = 1;
	commonEnglishWords['thing'] = 1;
	commonEnglishWords['think'] = 1;
	//commonEnglishWords['this'] = 1;
	commonEnglishWords['those'] = 1;
	commonEnglishWords['through'] = 1;
	//commonEnglishWords['time'] = 1;
	commonEnglishWords['to'] = 1;
	commonEnglishWords['too'] = 1;
	commonEnglishWords['turn'] = 1;
	commonEnglishWords['two'] = 1;
	commonEnglishWords['under'] = 1;
	commonEnglishWords['up'] = 1;
	commonEnglishWords['us'] = 1;
	//commonEnglishWords['use'] = 1;
	commonEnglishWords['very'] = 1;
	commonEnglishWords['want'] = 1;
	commonEnglishWords['way'] = 1;
	commonEnglishWords['we'] = 1;
	commonEnglishWords['well'] = 1;
	commonEnglishWords['what'] = 1;
	commonEnglishWords['when'] = 1;
	commonEnglishWords['where'] = 1;
	commonEnglishWords['which'] = 1;
	//commonEnglishWords['while'] = 1;
	commonEnglishWords['who'] = 1;
	commonEnglishWords['why'] = 1;
	commonEnglishWords['will'] = 1;
	commonEnglishWords['with'] = 1;
	commonEnglishWords['without'] = 1;
	commonEnglishWords['word'] = 1;
	commonEnglishWords['work'] = 1;
	commonEnglishWords['world'] = 1;
	commonEnglishWords['would'] = 1;
	//commonEnglishWords['write'] = 1;
	//commonEnglishWords['year'] = 1;
	commonEnglishWords['you'] = 1;
	commonEnglishWords['your'] = 1;
	}


</script>
<script type="text/javascript">
/* glossstubs.js: stubs for functions that gloss2html.pl doesn't need.
*/

function addAutoLinks() {
}

let isMarkdown = false;
function setIsMarkdown() {
}

async function showDefinitionHint(term, event) {
}

</script>
<script type="text/javascript">
// showHideTOC.js: shrink/expand the Table Of Contents via a "#tocShrinkExpand" element
// at top of the Table Of Contents. The TOC isn't shrunk away to nothing, a bit is left
// visible (which reminds one that it's there, and makes the design easier:).
// TODO this is a bit fragile, scrollContentsList and scrollTextRightOfContents are hard-coded.
// However, any ambitious person who changes those has bought the rights to full maintenance.
// This is used in the Viewer (intramine_file_viewer_cm.pl) when a view has a table of contents,
// and in gloss2html.pl (which generates HTML from .txt, and there is always a table of contents).

// Shrink/expand the Table Of Contents when the "#tocShrinkExpand" element is clicked.
// If toggleElem is null then shrinkIt will be false and the TOC will expand. This is
// currently called with null by dragTOC.js#addDragger() since for some unknown reason the
// TOC pane is coming up too narrow.
function toggleTOC(toggleElem) {
	// Avoid spurious highlighting after TOC toggle causes redraw.
	if (document.activeElement !== null)
		{
		document.activeElement.blur();
		}

	rememberLocation();
	
	let elementToAdjust = document.getElementById('scrollContentsList');
	let textElement = document.getElementById('scrollTextRightOfContents');
	if (elementToAdjust === null || textElement === null)
		{
		console.log("showHideTOC.js#toggleTOC top elements are missing!");
		return (false);
		}
	let divContainer = elementToAdjust.parentElement;
	if (elementToAdjust !== null && textElement !== null)
		{
		let widthStrTOC = window.getComputedStyle(elementToAdjust, null).getPropertyValue('width');
		let widthStrParent = window.getComputedStyle(divContainer, null).getPropertyValue('width');
		let widthTOC = parseFloat(widthStrTOC);
		let widthParent = parseFloat(widthStrParent);
		let oldTocWidthPC = 100 * widthTOC / widthParent;
		let paneSeparator = document.getElementById('panes-separator');;
		let widthPaneSep = 3; // pixels
		if (paneSeparator !== null)
			{
			let widthStrSep = window.getComputedStyle(paneSeparator, null).getPropertyValue('width');
			widthPaneSep = parseFloat(widthStrSep); // pixels
			}
		let newWidthPaneSep = widthPaneSep / widthParent * 100;
		
		let shrinkIt = (oldTocWidthPC < 10) ? false : true;
		if (toggleElem === null)
			{
			shrinkIt = false;
			}
		let newWidthTOCPC, newWidthTextPC;
		if (shrinkIt)
			{
			newWidthTOCPC = 5;
			}
		else
			{
			newWidthTOCPC = 23;
			}
		newWidthTextPC = 100 - newWidthPaneSep - newWidthTOCPC;

		elementToAdjust.style.width = newWidthTOCPC + "%";
		textElement.style.width = newWidthTextPC + "%";

		location.hash = topLineNumber;

		if (usingCM)
			{
			// Especially for CodeMirror, force a recalc.
			myCodeMirror.refresh();
			cmQuickRejumpToLine();
			}
		else
			{
			reJumpToLineNumber(topLineNumber);
			///// was restoreTopPosition(textElement, theTopPos);
			}

		// Redo initial scrollbar markers
		if (initialSearchHitsAreShowing)
			{
			removeInitialHighlights();
			highlightInitialItems();
			}

		// Also redo scroll bar markers for selection hits in the scroll bar.
		if (!usingCM)
			{
			removeAllScrollbarHighlights(scrollMarkerClass);
			markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
			}
		
		// Remember current TOC width in pixels.
		if (toggleElem !== null) // Not first call
			{
			let leftPaneStr = elementToAdjust.style.width;
			let leftPanePC = parseFloat(leftPaneStr);
			let leftPanePixels = leftPanePC * widthParent / 100;
			let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
			localStorage.setItem(leftPaneWidthKey, leftPanePixels);
			}
		}

	return (false);
}

function addTocToggle(idToggle) {
	let scrollContentsElement = document.getElementById('scrollContentsList');
	if (scrollContentsElement !== null)
		{
		// Add in the shrink/expand element at top of Table Of Contents.
		let toggleElem;
		if (b64ToggleImage !== '')
			{
			toggleElem = createElementFromHTML("<img src=\"data:image/png;base64,"
						+ b64ToggleImage + "\" id='" + idToggle + "'>");
			}
		else
			{
			toggleElem = createElementFromHTML("<img src='707788g4.png' id='" + idToggle + "'>");
			}
		
		document.body.insertBefore(toggleElem, document.body.firstChild);
		toggleElem.addEventListener('click', function() {
			toggleTOC(toggleElem);
		});

		// Default position is absolute relative to the page. We want to set the top so that it
		// nestles down in the Table of Contents at the top, where 20px of margin has been
		// left for it. Top should be just below the horizontal rule that divides upper part
		// of page from content proper.
		let rule = document.getElementById("rule_above_editor");
		let pos = getPosition(rule);
		let toggleTop = pos.y + 4;

		toggleElem.style.top = toggleTop + "px";
		}
}

// If the nav bar wraps and grows taller, or shrinks back down,
// it's nice to reposition the green double-headed arrow.
function repositionTocToggle() {
	let toggleElem = document.getElementById("tocShrinkExpand");
	let rule = document.getElementById("rule_above_editor");
	if (toggleElem === null || rule === null)
		{
		//console.log("showHideTOC.js#repositionTocToggle elements are missing!");
		return;
		}
	let pos = getPosition(rule);
	let toggleTop = pos.y + 4;

	toggleElem.style.top = toggleTop + "px";
}

// Get line number of first visible line in text.
// For non-codemirror, look for table row with bounding rect top that is
// >= elem bounding rect top. On that row, <td n="(\d+)" gives the line number.
function firstVisibleLineNumber(elem) {
	let topPos = 0;
	//let undefCounter = 0;

	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let firstVisibleLineNum = myCodeMirror.lineAtHeight(rect.top, "window");
		topPos = firstVisibleLineNum;
		}
	else
		{
		topPos = quickGetPosition(elem, true);
		}

	return (topPos);
}

// For non-CodeMirror files, the text of the document is in one or more consecutive <table>s.
// - find first table whose top is too far, look at the one before that - or if top
// is dead on, use that one.
// - check every 100th or 10th entry for element that is too far or dead on
// - if checked 100, now check every 10th starting from the "100" row just found
// - step through from there to find the exact number, skipping shrunk rows that have no number.
// "elem" is the main text holder, having tables as direct children (at least one).
function quickGetPosition(elem, getTop) {
	if (elem === null)
		{
		return;
		}
	let topPos = 0;
	let undefCounter = 0;
	let enclosingRect = elem.getBoundingClientRect();
	let enclosingRectTopOrBot = (getTop) ? enclosingRect.top : enclosingRect.bottom;
	
	let kids = null;
	for (; undefCounter < 100; ++undefCounter)
		{
		if (typeof(elem.children) !== 'undefined')
			{
			kids = elem.children;
			break;
			}
		}
	
	if (typeof(elem.children) === 'undefined')
		{
		//console.log("ERROR could not get children!");
		return(0);
		}
	
	//let done = false;
	
	// If "kids" doesn't have a table, try going down one more level - this is needed
	// with "index.txt" for example, which has a "special-index-wrapper" holding its one table
	if (!elementHasTableAsChild(kids))
		{
		kids = elem.children[0].children;
		}
	
	// - find first table whose BOTTOM is past the top or bottom of the view.
	let table = wantedTableForPosition(kids, enclosingRectTopOrBot, getTop);
	
	if (table !== null)
		{
		let tableBody = getTableBody(table);
		
		if (tableBody !== null)
			{
			let rowNum = getRowCandidateAbovePosition(table, 100, 10, enclosingRectTopOrBot);
			topPos = rowTopPosition(table, rowNum, 10, enclosingRectTopOrBot);
			}
		}
	
	return (topPos);
}

function getTableBody(table) {
	let tableBody = null;
	
	if (table !== null)
		{
		let tableKids = table.children; // there should be only one TBODY
		for (let m = 0; m < tableKids.length; ++m)
			{
			if (tableKids[m].nodeName === "TBODY")
				{
				tableBody = tableKids[m];
				break;
				}
			}
		}
	
	return(tableBody);
}

//Look at last row bottom in each table body, return current table if its bottom is
// at or past enclosingRectTopOrBot.
// // Sometimes rounding errors get in the way, hence the "Math.ceil()"
function wantedTableForPosition(topChildren, enclosingRectTopOrBot, getTop) {
	let wantedTable = null;
	
	
	//enclosingRectTopOrBot -= 1;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		if (!getTop)
			{
			//console.log("Checking table " + i);
			}
		
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = getTableBody(topChildren[i]);
			
			if (tableBody !== null)
				{
				let rows = tableBody.children;
				if (rows.length > 0)
					{
					let rowToCheck = rows.length - 1;
					let bounding = rows[rowToCheck].getBoundingClientRect();
					let bottomCeiling = Math.ceil(bounding.bottom);
					
					if (!getTop)
						{
						//console.log("Checking table " + i + " row " + rowToCheck + " bottom " + bottomCeiling + " of " + rows.length + " against " + enclosingRectTopOrBot);
						}
					
					if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			} // if (tagName === "TABLE")
		}
		
	if (wantedTable === null)
		{
		if (!getTop)
			{
			//console.log("Did NOT find bottom!");
			}
		
		if (topChildren.length > 0)
			{
			if (getTop)
				{
				for (let i = 0; i < topChildren.length; ++i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			else // bottom
				{
				for (let i = topChildren.length - 1; i >= 0; --i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			}
		else
			{
			//console.log("ERROR no tables in document!");
			}
		}
	
	return(wantedTable);
}

function elementHasTableAsChild(topChildren) {
	let result = false;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			result = true;
			break;
			}
		}
	
	return(result);
}

// We are looking for a row with bottom above or at enclosingRectTopOrBot.
// 
// Starting at table bottom, look upwards rowInc at a time for the row bottom
// that is <= enclosingRectTopOrBot. If none found, the default 0 is returned.
// There are two passes, crude (100 row jumps) and fine (10 row jumps).
function getRowCandidateAbovePosition(table, majorInc, minorInc, enclosingRectTopOrBot) {
	let wantedRow = 0;
	//let lastRowCheckedInFirstPass = 0;
	let tableBody = getTableBody(table);
	
	if (tableBody !== null)
		{
		let rows = tableBody.children;
		let rowToCheck = rows.length - 1;
		
		// Look backwards in big jumps, from end of table.
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= majorInc;
				}
			}
		
		// Look backwards in small jumps, from wantedRow just found plus majorInc.
		rowToCheck = wantedRow + majorInc;
		if (rowToCheck > rows.length - 1)
			{
			rowToCheck = rows.length - 1;
			}
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= minorInc;
				}
			}
		}
	
	return(wantedRow);
}

// startRow should have a bottom that is <= enclosingRectTopOrBot, and not be too far
// above one that's >. Look down from startRow for a row with bottom >= enclosingRectTopOrBot.
// Try to adjust down slightly from that to a row with TOP >= enclosingRectTopOrBot.
// On a complete fail, which can happen when scrolling to bottom of document, take
// the last line number in the table. What can I say, it works.
function rowTopPosition(table, startRow, minorInc, enclosingRectTopOrBot) {
	let topPos = 0;
	let tableBody = getTableBody(table);
	
	enclosingRectTopOrBot = Math.ceil(enclosingRectTopOrBot);
	
	if (tableBody !== null)
		{
		let foundIt = false;
		let rows = tableBody.children;
		let lastToCheck = startRow + minorInc + 1;
		if (lastToCheck > rows.length)
			{
			lastToCheck = rows.length;
			}
		
		for (let j = startRow; j < lastToCheck; ++j)
			{
			let bounding = rows[j].getBoundingClientRect();
			let bottomCeiling = Math.ceil(bounding.bottom);
			if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
				{
				let lastToCheck_K =  j + 3;
				if (lastToCheck_K > rows.length)
					{
					lastToCheck_K = rows.length;
					}
				for (let k = j; k < lastToCheck_K; ++k)
					{
					let bounding_K = rows[k].getBoundingClientRect();
					let bottomCeiling_K = Math.ceil(bounding_K.bottom);
					if (bottomCeiling_K > enclosingRectTopOrBot)
						{
						let contents = rows[k].innerHTML;
						let lineNumMatch = /^<td n="(\d+)/.exec(contents);
						if (lineNumMatch !== null)
							{
							topPos = parseInt(lineNumMatch[1], 10);
							foundIt = true;
							break;
							}
						}
					}
				
				// For the very last line, it's possible that the bottom of the last row
				// won't be visible (perhaps by only a pixel or so) or that it's a shrunk
				// row with no line number. If so, look up starting at row j for a row
				// with visible top and a line number.
				if (!foundIt)
					{
					for (let k = j; k < lastToCheck_K; ++k)
						{
						let bounding_K = rows[k].getBoundingClientRect();
						if (bounding_K.top >= enclosingRectTopOrBot)
							{
							let contents = rows[k].innerHTML;
							let lineNumMatch = /^<td n="(\d+)/.exec(contents);
							if (lineNumMatch !== null)
								{
								topPos = parseInt(lineNumMatch[1], 10);
								foundIt = true;
								break;
								}
							}
						}
					}
				
				break;
				}
			}
		
		if (!foundIt)
			{
			// Find last row with a line number.
			let k = rows.length - 1;
			while (k >= 0)
				{
				let contents = rows[k].innerHTML;
				let lineNumMatch = /^<td n="(\d+)/.exec(contents);
				if (lineNumMatch !== null)
					{
					topPos = parseInt(lineNumMatch[1], 10);
					foundIt = true;
					break;
					}
				--k;
				}
			}
		} // if (tableBody !== null)
	
	return (topPos);
}

function lastVisibleLineNumber(elem) {
	let bottomPos = 0;
	//let undefCounter = 0;
	
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let lastVisibleLineNum = myCodeMirror.lineAtHeight(rect.bottom, "window");
		bottomPos = lastVisibleLineNum;
		}
	else
		{
		bottomPos = quickGetPosition(elem, false);
		}

	return (bottomPos);
}

function restoreTopPosition(elem, topPos) {
	if (usingCM)
		{
		jumpToLine(topPos + 2, false);
		}
	else
		{
		restoreTopPositionNonCM(elem, topPos);
		}
}

// Find <tr> in elem with <td n="topPos"..., scroll it into view.
function restoreTopPositionNonCM(elem, topPos) {
	let children = elem.children;
	let done = false;

	for (let i = 0; i < children.length; ++i)
		{
		let tagName = children[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = children[i].children;
			for (let k = 0; k < tableBody.length; ++k)
				{
				let tableChildren = tableBody[k].children;
				for (let j = 0; j < tableChildren.length; ++j)
					{
					let contents = tableChildren[j].innerHTML;
					let lineNumMatch = /^<td n="(\d+)/.exec(contents);
					if (lineNumMatch !== null)
						{
						let currentLine = lineNumMatch[1];
						if (currentLine == topPos)
							{
							tableChildren[j].scrollIntoView();
							// Set top of nav to zero, fixes an iPad scroll problem where nav
							// goes off the top.
							let nav = document.getElementById("nav"); // nope nav.style.top = 0;
							if (nav !== null)
								{
								nav.parentNode.scrollTop = 0;
								}
							done = true;
							break;
							}
						}
					}
				if (done)
					{
					break;
					}
				}
			}
		if (done)
			{
			break;
			}
		}
}

// Handle Table of Contents (TOC) width in views. The goal is to keep the
// same TOC width in pixels as much as possible.

function rememberTocWidthPixels() {
	let leftPane = document.getElementById('scrollContentsList'); // TOC column
	if (leftPane === null)
		{
		return;
		}
	let leftPaneWidthStr = window.getComputedStyle(leftPane, null).getPropertyValue('width');
	let widthLeftPane = parseFloat(leftPaneWidthStr);
	let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
	localStorage.setItem(leftPaneWidthKey, widthLeftPane);
}

// Return width in pixels of table of contents column from localStorage,
// also set localStorage value if that hasn't been done yet.
function getTocWidthPixels() {
	let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
	let widthLeftPane; // pixels
	if (!localStorage.getItem(leftPaneWidthKey))
		{
		rememberTocWidthPixels(); // sets leftPaneWidthKey in localStorage
		}
	
	let leftPaneWidthStr = localStorage.getItem(leftPaneWidthKey);
	widthLeftPane = parseFloat(leftPaneWidthStr);
	if (widthLeftPane < 50)
		{
		//leftPaneWidthStr = "100.0";
		widthLeftPane = 100.0;
		}
	

	return(widthLeftPane);
}

// Use width in pixels of table of contents column as last save
// to set widths of table of contents and text in percentages.
function restoreColumnWidths() {	
	let leftPane = document.getElementById('scrollContentsList'); // TOC column
	let panesContainer = document.getElementById('scrollAdjustedHeight');
	let paneSep = document.getElementById('panes-separator');
	if (leftPane === null || panesContainer === null || paneSep === null)
		{
		return;
		}

	let widthLeftPane = getTocWidthPixels();
	let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
	let widthPanesContainer = parseFloat(panesContainerWidthStr);
	let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
	let paneSepWidth = parseFloat(paneSepWidthStr);
	//let paneSepInfo = paneSep.getBoundingClientRect();
	//let paneSepWidth = paneSepInfo.width;
	let separatorPercent = paneSepWidth / widthPanesContainer * 100;
	let leftPanePC = widthLeftPane / widthPanesContainer * 100;
	leftPane.style.width = leftPanePC + '%';
	let right = (100-leftPanePC-separatorPercent);
	rightPane.style.width = right + '%';

	//TEST ONLY
	// console.log("widthLeftPane: " + widthLeftPane);
	// console.log("panesContainerWidthStr: " + panesContainerWidthStr);
	// //console.log("paneSepWidthStr: " + paneSepWidthStr);
	// console.log("paneSepWidth: " + paneSepWidth);
	// console.log("separatorPercent: " + separatorPercent);
	// console.log("leftPanePC: " + leftPanePC);
	// console.log("right: " + right);
}

function markdownCurrentHeaderID() {
	let currentHeaderID = '';
	let currentHeaderElement = null;
	let el = document.getElementById("scrollTextRightOfContents");
	if (el === null)
		{
		return(currentHeaderID);
		}
	let enclosingRect = el.getBoundingClientRect();
	let enclosingRectTop = enclosingRect.top;
	let enclosingRectBottom = enclosingRect.bottom;
	// Get h1 h2 etc elements.
	let headerNodes = new Array();
	for (let i=1; i<=6; ++i)
		{
		let headers = document.getElementsByTagName('h'+i);
		for (let j = 0; j < headers.length; ++j)
			{
			headerNodes.push(headers[j]);
			}
		}
	
	let highestBottomCeiling = 9999;
	for (let i = 0; i < headerNodes.length; ++i)
		{
		let bounding = headerNodes[i].getBoundingClientRect();
		let bottomCeiling = Math.ceil(bounding.bottom);
		if (bottomCeiling >= enclosingRectTop && bottomCeiling <= enclosingRectBottom)
			{
			if (highestBottomCeiling > bottomCeiling)
				{
				highestBottomCeiling = bottomCeiling;
				currentHeaderElement = headerNodes[i];
				}
			}
		}
	
	if (currentHeaderElement !== null)
		{
		currentHeaderID = currentHeaderElement.id;
		}

	return(currentHeaderID);
}

window.addEventListener("load", function() {
	addTocToggle('tocShrinkExpand');
});

</script>
<script type="text/javascript">
// viewerStart.js: used for non-CodeMirror views in intramine_viewer.pl.
// Manage layout changes on resize, jump to an anchor
// Put highlight hits in text and on scrollbar.
// Show/hide any initial search hits provided in highlightitems.
// Preserve user selection when marking, by remembering selection range, removing selected
// text before marking, then restoring text and selection range after marking (patent not pending).

const delay = ms => new Promise(res => setTimeout(res, ms));

let markerMainElement = document.getElementById(cmTextHolderName);
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById("scrollText");
	}
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById(specialTextHolderName);
	}

let tocMainElement = document.getElementById("scrollContentsList");

let onMobile = false; // Set below, true if we have touch events.
if (typeof window.ontouchstart !== 'undefined')
	{
	onMobile = true;
	}

window.addEventListener("load", reJumpAndHighlight);
window.addEventListener("resize", JD.debounce(doResize, 100));

// Adjust some element heights so scrolling works properly.
function doResize() {
	restoreColumnWidths();

	let rule = document.getElementById("rule_above_editor");
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;

	let windowHeight = window.innerHeight;
	let elHeight = windowHeight - pos.y - ruleHeight - 8;
	let newHeightPC = (elHeight / windowHeight) * 100;
	let el = document.getElementById("scrollAdjustedHeight");
	el.style.height = newHeightPC + "%";

	if (tocMainElement !== null)
		{
		let tocMarginTop =
				parseInt(window.getComputedStyle(tocMainElement).getPropertyValue('margin-top'));
		let tocHeight = elHeight - tocMarginTop;
		if (onMobile)
			{
			tocHeight -= 20;
			}
		else
			{
			tocHeight -= 16;
			}
		let newTocHeightPC = (tocHeight / elHeight) * 100;
		tocMainElement.style.height = newTocHeightPC + "%";
		}

	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		highlightInitialItems();
		}

	if (!onMobile)
		{
		scrollIndicator();
		}
	else
		{
		scrollMobileIndicator(); // if mobile
		}
	
	reJump();
	
	updateToggleBigMoveLimit();

	repositionTocToggle();
}

// On "load", scroll any location.hash position into view, and put highlights on any
// words that formed part of a search that produced this file as a hit.
// See intramine_viewer.pl#InitialHighlightItems().
function reJumpAndHighlight() {
	addDragger && addDragger(); // dragTOC.js#addDragger()
	
	reJump(100); // "100" adds a slight delay before line number scrollIntoView().
	updateToggleBigMoveLimit();
	updateTogglePositions();
	highlightInitialItems();

	setIsMarkdown();
	if (isMarkdown)
		{
		addAutoLinksForMarkdown();
		}
	else
		{
		addAutoLinks();
		}
}

// Set top of nav to zero, fixes an iPad scroll problem where nav goes off the top.
function resetTopNavPosition() {
	let nav = document.getElementById("nav"); // nope nav.style.top = 0;
	if (nav !== null)
		{
		nav.parentNode.scrollTop = 0;
		}
}

// Scroll element into view, based on ID named in location.hash.
function reJump(delayMsec) {
	// Markdown is special since it has no line numbers.
	// We look at localStorage for a line number, if found
	// attempt to count through the elements in the contents
	// and jump. False if no jump.
	if (jumpToMarkdownLineFromStorage())
		{
		return;
		}
	
	if (delayMsec === undefined)
		{
		delayMsec = 0;
		}
	
	let h = location.hash;
	if (h.length > 1)
		{
		// strip leading '#'
		h = h.replace(/^#/, '');
		h = decodeURIComponent(h);
		
		if (isNaN(h))
			{
			let el = getElementForHash(h);
			if (el === null)
				{
				let simplerHCopy = h.toLowerCase();
				simplerHCopy = simplerHCopy.replace(/\W/g, '');
				el = document.getElementById(simplerHCopy);
				}		
			
			if (el !== null)
				{
				el.scrollIntoView();
				resetTopNavPosition();
				if (!onMobile)
					{
					scrollIndicator();
					}
				else
					{
					scrollMobileIndicator(); // if mobile
					}
				}
			}
		else
			{
			reJumpToLineNumber(h, delayMsec);
			}
		}
}

// Retrieve line number to scroll to from localStorage.
// Count up through the elements in the HTML until line number is reached,
// scroll to that element.
// Each P, H1..H6, HR counts as two lines.
//
function jumpToMarkdownLineFromStorage() {
	let markdownLineNumberKey = thePath + '?' + "markdownline";
	let markdownLineNumberStr = localStorage.getItem(markdownLineNumberKey);
	if (markdownLineNumberStr === null)
		{
		return(false);
		}
	let markdownLineNumber = Number(markdownLineNumberStr);
	++markdownLineNumber;

	// TEST ONLY
	//console.log("jumpToMarkdownLineFromStorage looking for " + markdownLineNumberStr);


	localStorage.removeItem(markdownLineNumberKey);
	const textDiv = document.getElementById("scrollTextRightOfContents");
	if (textDiv === null)
		{
		return(false);
		}
	if (typeof(textDiv.children) === 'undefined')
		{
		return(false);
		}
	
	const kids = textDiv.children;
	if (kids.length === 0)
		{
		return(false);
		}

	let preHeight = preLineHeight();
	let el = null; // the goal element
	let lineNumber = 1;
	let done = false;
	let isSubElement = false;
	let textDivOffset = textDiv.offsetTop;
	let parentElementOffset = 0;
	let elementOffset = 0;
	for (let i = 0; i < kids.length; ++i)
		{
		let kidsName = kids[i].nodeName;

		// TEST ONLY
		//console.log("NODENAME: " + kidsName + " at i " + i);

		if ( kidsName === 'P' || kidsName === 'DIV' || kidsName === 'H1'
				|| kidsName === 'H2' || kidsName === 'H3' || kidsName === 'H4'
				|| kidsName === 'H5' || kidsName === 'H6' || kidsName === 'HR'
				|| kidsName === 'CODE' )
			{
			++lineNumber;
			++lineNumber; // sic, HTML puts in a blank line with margin on bottom
			if (lineNumber >= markdownLineNumber)
				{
				el = kids[i];
				break;
				}

			const paraKids = kids[i].children;
			for (j = 0; j < paraKids.length; ++j)
				{
				let paraKidsName = paraKids[j].nodeName;
				if (paraKidsName === 'IMG')
					{
					++lineNumber;
					if (lineNumber >= markdownLineNumber)
						{
						el = kids[i];
						done = true;
						break;
						}		
					}
				}
			}
		else if (kidsName === 'TABLE')
			{
			const rows = kids[i].rows;
			if (rows.length === 0)
				{
				continue;
				}
			for (let j = 0; j < rows.length; ++j)
				{
				++lineNumber;
				if (j === 0)
					{
					++lineNumber; // for the | :---- row at top of table
					}
				if (lineNumber >= markdownLineNumber)
					{
					if (j > 1)
						{
						el = rows[j-1];
						}
					else
						{
						el = rows[j];
						}
					isSubElement = true;
					parentElementOffset = kids[i].offsetTop - textDivOffset;
					elementOffset = rows[j].offsetTop;
					//el = kids[i];
					done = true;
					break;
					}
				}
			}
		else if (kidsName === 'UL' || kidsName === 'OL')
			{
			const listItems = kids[i].children;
			if (listItems.length === 0)
				{
				continue;
				}

			//++lineNumber;
			
			for (let j = 0; j < listItems.length; ++j)
				{
				++lineNumber;
				if (lineNumber >= markdownLineNumber)
					{
					el = listItems[j];
					isSubElement = true;
					parentElementOffset = kids[i].offsetTop - textDivOffset;
					// TEST ONLY
					//console.log("j " + j);

					elementOffset = j * el.offsetHeight; // odd hack, but it works
					//el = kids[i];
					done = true;
					break;
					}
				}
			}
		else if (kidsName === 'PRE')
			{
			let preLength = kids[i].textContent.split('\n').length;
			lineNumber += preLength;
			if (lineNumber >= markdownLineNumber)
				{
				el = kids[i];
				// Another hack
				isSubElement = true;
				parentElementOffset = kids[i].offsetTop - textDivOffset;
				let lineDiff = lineNumber - markdownLineNumber;
				elementOffset = -lineDiff * preHeight; // scroll back from bottom
				done = true;
				break;
				}
			}
		else
			{
			//console.log("UNHANDLED: " + kidsName + "ca line " + lineNumber);
			++lineNumber;
			}
		
		if (done)
			{
			break;
			}
		} // for (let i = 0; i < kids.length; ++i)

	let result = false;
	if (el !== null)
		{
		// TEST ONLY
		//const elemName = el.nodeName;
		//console.log("FOUND " + elemName + " on line " + lineNumber + " vs wanted " + markdownLineNumber);
		//console.log("|" + el.innerHTML + "|");

		if (isSubElement)
			{
			// TEST ONLY
			//console.log("Scrolling to subelement.");
			//el.style.backgroundColor = "yellow";

			// TEST ONLY
			//const elemName = el.nodeName;
			//console.log(elemName + " " + parentElementOffset + " " + elementOffset);

			textDiv.scrollTo({
				top: parentElementOffset + elementOffset
				});
			}
		else
			{
			//el.style.backgroundColor = "lightblue";
			el.scrollIntoView();
			}
		
		resetTopNavPosition();
		if (!onMobile)
			{
			scrollIndicator();
			}
		else
			{
			scrollMobileIndicator(); // if mobile
			}
		result = true;
		}

	return(result);
}

function preLineHeight() {
	const preElement = document.querySelector('pre');
	const computedStyle = window.getComputedStyle(preElement);
	const lineHeight = computedStyle.lineHeight;

	let lineHeightInPixels;
	if (lineHeight.endsWith('px')) {
		lineHeightInPixels = parseFloat(lineHeight);
	} else if (lineHeight === 'normal') {
		// If line-height is "normal", you'll need to estimate based on the font-size
		const fontSize = parseFloat(computedStyle.fontSize);
		lineHeightInPixels = fontSize * 1.2; // common default for "normal" line-height
	} else {
		// For other units like 'em', you'll need to convert to pixels
		const fontSize = parseFloat(computedStyle.fontSize);
		if (lineHeight.endsWith('em')) {
			lineHeightInPixels = parseFloat(lineHeight) * fontSize;
		} else {
			// handle other units as needed
			lineHeightInPixels = 17; // Set to null or handle appropriately
		}
	}

	//console.log("PRE height: " + lineHeightInPixels); // Typ. around 17
	return (lineHeightInPixels);
}

// Progressively shorten 'h' word by word as necessary until an anchor id is found. If the
// remaining part of 'h' is a number, though, jump to that line. If an anchor id is found,
// return the corresponding element in the html text.
//
// This "shortening" approach is needed because 'h' may be too long, if it was part of a link
// in a text file where the link was not quoted: when making the link, we didn't know where
// the hash stopped, and just grabbed a hundred or so characters after the '#'.
// [See intramine_file_viewer_cm.pl#RememberTextOrImageFileMention().]
function getElementForHash(h) {
	let hCopy = h;
	hCopy = hCopy.replace(/ /g, '_');
	hCopy = hCopy.replace(/\%20/g, '_');
	hCopy = hCopy.replace(/\(\)$/, '');
	let el = document.getElementById(hCopy);
	if (el === null)
		{
		let simplerHCopy = h.toLowerCase();
		simplerHCopy = simplerHCopy.replace(/\W/g, '');
		el = document.getElementById(simplerHCopy);
		}
	
	while(el === null && h.length > 0)
		{
		let lastIndexOfSpace = h.lastIndexOf(" ");
		let lastIndexOfPct = h.lastIndexOf("%");
		let trimIndex = (lastIndexOfSpace > lastIndexOfPct) ? lastIndexOfSpace: lastIndexOfPct;
		if (trimIndex > 0)
			{
			h = h.substring(0, trimIndex);
			let hCopy = h;
			hCopy = hCopy.replace(/ /g, '_');
			hCopy = hCopy.replace(/\%20/g, '_');
			el = document.getElementById(hCopy);
			if (el === null)
				{
				if (!isNaN(hCopy))
					{
					reJumpToLineNumber(hCopy);
					break;
					}
				}
			}
		else
			{
			break;
			}
		}
	
	return(el);
}

// Scroll a line into view, based on line number. Synch the TOC too.
async function reJumpToLineNumber(h, delayMsec) {
	if (delayMsec === undefined)
		{
		delayMsec = 0;
		}

	let lineNum = parseInt(h, 10) - 1;
	if (lineNum < 0)
		{
		//console.log("reJumpToLineNumber negative line number received: |" + h + "|");
		lineNum = 0;
		}
	
	// For Markdown, interpret h as scrollTop.
	// if (isMarkdown)
	// 	{
	// 	const myDiv = document.getElementById("scrollTextRightOfContents");
	// 	myDiv.scrollTop = h + 1;
	// 	}
	// Look for row number lineNum.
	let rows = markerMainElement.getElementsByTagName('tr');
	if (lineNum >= rows.length)
		{
		lineNum = rows.length - 1;
		}
	
	if (lineNum >= 0)
		{
		let el = rows[lineNum];
		if (el === null)
			{
			// Currently the Editor saves and shows blank lines at the bottom
			// but some Viewers suppress them. Back up the lineNum until
			// we hit an actual existing row. This probably isn't needed
			// thanks to the limit on lineNum above, but I've left it in.
			let revCounter = 0;
			while (el === null && ++revCounter <= 100 && --lineNum >= 0)
				{
				el = rows[lineNum];
				if (el !== null)
					{
					break;
					}
				}
			}
		
		if (lineNum < 0)
			{
			lineNum = 0;
			}
		
		if (el !== null)
			{
			if (delayMsec > 0)
				{
				await delay(delayMsec);
				}
			el.scrollIntoView(true);
			resetTopNavPosition();
			if (!onMobile)
				{
				scrollIndicator();
				}
			else
				{
				scrollMobileIndicator(); // if mobile
				}
			}

		// Restore Table of Contents scrolled position and highlight.
		restoreTocSelection(lineNum);
		}
}

// Just for Markdown files, go straight to an id.
function mdJump(tocid, lineNum) {
	location.hash = '#' + tocid;
}

// Adust the top of "id" (the main text holder) so scrolling will work properly etc.
function setTextViewPosition(rule_id, id) {
	let el = document.getElementById(id);
	if (el === null)
		{
		return;
		}
	let rule = document.getElementById(rule_id);
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;
	let yPos = pos.y + ruleHeight + 8;
	el.style.top = yPos + "px";
}

// Position the main text-holding element.
function positionViewItems() {
	let viewElement = document.getElementById(cmTextHolderName);
	if (viewElement !== null)
		{
		setTextViewPosition("rule_above_editor", cmTextHolderName);
		}
	else
		{
		viewElement = document.getElementById(specialTextHolderName);
		if (viewElement !== null)
			{
			setTextViewPosition("rule_above_editor", specialTextHolderName);
			}
		}
	doResize();
}

function finishStartup() {
	if (thePath.match(/\.(txt|log|bat)$/))
		{
		// use lolight highlighting
		putInLolightElements();
		}

	hideIt("search-button");
	hideIt("small-tip");
	positionViewItems();
	loadCommonestEnglishWords(); // See commonEnglishWords.js.
	setImagesButtonText();
	reJump();
}

// Code block highlighting with lolight, used
// by intramine_viewer.pl and gloss2html.pl.
function putInLolightElements() {
	document.querySelectorAll('td').forEach((el) => {
		putInLolightPreAndClass(el);
	});
}

function putInLolightPreAndClass(el) {
	let text = el.innerHTML;
	let codeMarkerPosition = text.indexOf('_STARTCB_');
	if (codeMarkerPosition == 0)
		{
		// FL = First/Last line of a code block. These are
		// shrunk down, emptied out, and colored gray.
		// Other rows starting with 'STARTCB_' are given
		// a class of 'lolight', and lolight JS styles
		// them up when the document is ready.
		if (text.indexOf('_STARTCB_FL_') == 0)
			{
			el.innerHTML = '';
			el.parentNode.classList.add("reallyshrunkrow");
			el.parentNode.firstElementChild.removeAttribute("n");
			el.style.backgroundColor = "#d0d0d0";
			}
		else
			{
			text = text.substring(9);
			el.innerHTML = '<pre class="lolight">' + text + '</pre>';
			el.style.backgroundColor = "#f3f3f3";
			}
		}
}

function createElementFromHTML(htmlString) {
	let div = document.createElement('div');
	div.innerHTML = htmlString.trim();

	// Change this to div.childNodes to support multiple top-level nodes
	return div.firstChild; // or div.firstElementChild?
}

function hideIt(id) {
	let el = document.getElementById(id);
	if (el !== null)
		{
		el.style.display = 'none';
		}
}

// Set up for highlighting text, with marks in scrollbar, keeping user's selection
// or expanding it to a word. mark.js (mark.min.js) does the actual marking.
// Marks are used for both the initial highlight items and a user text selection.
let markerInstance = null;
let mouseEvt;

let textMarkerClass = "marker-highlight";
let scrollMarkerClass = "scroll-hilite";
let initialHitsTextMarkersClass = "initial-hits-highlight";
let initialHitsScrollMarkerClass = "initial-scroll-hl";
let toggleHitsButtonID = "sihits";
let initialSearchHitsAreShowing = false;
let currentTextForHighlighting = '';
let justUpdateScrollbar = false;


// Selection management: on a single click, expand to a word. If selection is on one row,
// the <td> holding it is removed before marking, and then restored, complete with selection.
// Done because marking the current selection will collapse it to an insertion point.
let theSelection = {};
theSelection.selectionIsTooBig = false;
theSelection.isDoubleClick = false;
theSelection.doingDoubleClick = false;
theSelection.userDragged = false;
//For LightRange.min.js range representing text selection.
theSelection.ltRange = null;
theSelection.currentSelectionElem = null; // Hide/show this element when marking
theSelection.currentSelPreviousSibling = null; // The target for re-insertion of currentSelectionElem
theSelection.selChildren = []; // Contents of TD containing current selection
theSelection.startNodeIndexes = [];
theSelection.startNodeOffset = 0;
theSelection.endNodeIndexes = [];
theSelection.endNodeOffset = 0;
theSelection.topStartNode = null;
theSelection.topEndNode = null;

let linkClicked = false;
let hintboxClicked = false;
let cmCursorPos = {
	line : -1,
	ch : -1
};

// mark.js mark/unmark options, "done" is fired at the end of the mark/unmark. Normally
// one calls unmark, with unmarkOptions "done" calling the mark function.
let markerOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
	}
};
let markerOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(initialHitsTextMarkersClass, initialHitsScrollMarkerClass);
	}
};

let unmarkOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"done" : function() {
		removeAllScrollbarHighlights(scrollMarkerClass);
		markCurrentSelection();
	}
};
let unmarkOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"done" : function() {
		removeAllScrollbarHighlights(initialHitsScrollMarkerClass);
	}
};

if (markerMainElement !== null)
	{
	markerInstance = new Mark(markerMainElement);
	}

// After a click, update markers in text and scroll corresponding TOC element into view.
function delayedUpdateMarkersAndTOC(evt) {
	let doubleClickDelay = doubleClickTime + 100; // milliseconds
	setTimeout(function() {
		updateMarkers(evt);
	}, doubleClickDelay);
	
	scrollTocEntryIntoView(evt, false);
}

// Highlight user's selection, unless it was a click on a link or in the scrollbar, or the
// first click in a double-click, or there's too much text selected to be worth higlighting.
function updateMarkers(evt) {
	if (linkClicked)
		{
		return;
		}
	if (theSelection.isDoubleClick)
		{
		theSelection.isDoubleClick = false;
		theSelection.doingDoubleClick = true;
		return;
		}
	if (markerMainElement === null || evtIsInScrollbar(evt))
		{
		return;
		}

	// No marking if selection is "too big" (spreads over more than one line).
	theSelection.selectionIsTooBig = selectionIsTooBig();
	
	if (!justUpdateScrollbar && currentSelectionTouchesLink())
		{
		theSelection.doingDoubleClick = false;
		return;
		}

	mouseEvt = evt;
	
	theSelection.userDragged = false;

	// full highlight, selection, and scrollbar marking
	if (!justUpdateScrollbar && !theSelection.selectionIsTooBig) 
		{
		storeSelection();
		// Get current text to highlight, or set theSelection.selectionTooBig = true.
		// Also set current text to "" if it's fewer than three characters, meaning remove
		// all markers and don't mark anything new or change the selection (this is a way to
		// clear markers).
		currentTextForHighlighting = getCurrentTextForMarkup();
		
		hideSelectionRow(); // Don't mark up row where text is selected
		
		markerInstance.unmark(unmarkOptions);
		}
	else if (justUpdateScrollbar)
		{
		removeAllScrollbarHighlights(scrollMarkerClass);
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
		}

	// EXPERIMENT, try showing hint for Go to definition.
	if (!theSelection.selectionIsTooBig)
		{
		let text = window.getSelection().toString();
		showDefinitionHint(text, evt);
		}

	theSelection.doingDoubleClick = false;
	justUpdateScrollbar = false;
}

//See intramine_viewer.pl#InitialHighlightItems().
function highlightInitialItems() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.mark(highlightItems[i], markerOptionsInitialHits);
			}
		initialSearchHitsAreShowing = true;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Hide Initial Hits";
			}
		}
}

function removeInitialHighlights() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.unmark(unmarkOptionsInitialHits);
			}
		initialSearchHitsAreShowing = false;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Show Initial Hits";
			}
		}
}

function toggleInitialSearchHits() {
	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		}
	else
		{
		highlightInitialItems();
		}
}

function noteWasDoubleClick(evt) {
	//let nons = '';
	theSelection.isDoubleClick = true;
}

function updateScrollbarMarkers() {
	justUpdateScrollbar = true;
	updateMarkers(null);
}

// This is called by mark.js after an unmark, see unmarkOptions above.
function markCurrentSelection() {

	if (currentTextForHighlighting !== "")
		{
		markerInstance.mark(currentTextForHighlighting, markerOptions);
		}
	
	showSelectionRow(); // Restore visibiliy of element containing current user selecton.
	
	showStoredSelections();

	theSelection.userDragged = false;
}

function getCurrentTextForMarkup() {
	let result = getSelectionText();

	return (result);
}

// Get text for marking, unless it's too big to be worth marking. This is a bit of a gamble,
// but a "too big" selection usually means the user is just intending to copy some text,
// not see other instances of it in the same file.
function getSelectionText() {
	let text = "";
	
	theSelection.userDragged = false;
	
	if (window.getSelection && !theSelection.doingDoubleClick)
		{
		let currSelection = window.getSelection();
		if (!theSelection.selectionTooBig)
			{
			text = currSelection.toString();
			if (text !== '')
				{
				theSelection.userDragged = true;
				}
			}
		else
			{
			theSelection.userDragged = true;
			}
		}

	
	if (!theSelection.selectionTooBig && !theSelection.userDragged)
		{
		// Empty selection: expand to nearest word.
		if (text === '')
			{
			//text = expandSelectionToWordIfPossible();
			let wordObj = expandSelectionToWordIfPossible();
			text = wordObj.theWord;
			if (typeof text === 'undefined')
				{
				text = '';
				}
			if (text !== '')
				{
				let beginOffset = wordObj.theBegin;
				let endOffset = wordObj.theEnd;
				// Re-capture the selection for later restoration.
				if (typeof theSelection.ltRange !== 'undefined')
					{
					try  {
						let startContainer = theSelection.ltRange.startContainer;
						theSelection.ltRange.setStart(startContainer, beginOffset);
						theSelection.ltRange.setEnd(startContainer, endOffset);
						}
					catch(e) {
						; // not much we can do.
						}
					}
				}
			}
		}

	// Avoid highlighting just one or two characters. Or a common English word (top 100);
	if (text.length <= 2 || (text.length > 2 && isCommonEnglishWord(text)))
		{
		text = "";
		}

	return text;
}


// "Too big" means selected text spreads across two or more lines.
// Or we're in a CODE block and more than a word is selected.
function selectionIsTooBig() {
	let selectionTooBig = false;
	let withinPRE = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			if (tdElem.nodeName === "PRE")
				{
				withinPRE = true;
				}
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		else
			{
			if (withinPRE)
				{
				let text = window.getSelection().toString();
				if (containsMoreThanOneWord(text))
					{
					selectionTooBig = true;
					}
				}
			}
		}

	return (selectionTooBig);
}

function containsMoreThanOneWord(text) {
	let result = false;
	let nonWordHitPosition = text.search(/\W/);
	if (nonWordHitPosition >= 0) // more than just a word is there
		{
		result = true;
		}

	return(result);
}

function currentSelectionTouchesLink() {
	let result = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let nodes = getNodesInRange(currRange);
		for (let i = 0; i < nodes.length; ++i)
			{
			if (nodes[i].nodeName === "A")
				{
				result = true;
				break;
				}
			}
		}
	
	return(result);
}

function getNextNode(node) {
    if (node.firstChild)
        return node.firstChild;
    while (node)
    {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
}

function getNodesInRange(range) {
    var start = range.startContainer;
    var end = range.endContainer;
    var commonAncestor = range.commonAncestorContainer;
    var nodes = [];
    var node;

    // Walk parent nodes from start to common ancestor.
    for (node = start.parentNode; node; node = node.parentNode)
    {
        nodes.push(node);
        if (node == commonAncestor)
            break;
    }
    nodes.reverse();

    // Walk children and siblings from start until end is found.
    for (node = start; node; node = getNextNode(node))
    {
        nodes.push(node);
        if (node == end)
            break;
    }

    return nodes;
}

function expandSelectionToWordIfPossible() {
	return (getFullWord(mouseEvt)); // see wordAtInsertionPt.js

}

// Add handlers for marker updating etc.
if (markerMainElement !== null)
	{
	markerMainElement.addEventListener("click", delayedUpdateMarkersAndTOC);
	markerMainElement.addEventListener("dblclick", noteWasDoubleClick);
	window.addEventListener("resize", updateScrollbarMarkers);

	markerMainElement.addEventListener("mouseup", resetTopNavPosition);
	if (tocMainElement !== null)
		{
		tocMainElement.addEventListener("mouseup", resetTopNavPosition);
		}
	}

// Show/hide highlight markers on scroll bar.

function removeAllScrollbarHighlights(mClass) {
	removeElementsByClass(mClass);
}

function removeElementsByClass(className) {
	let elements = document.getElementsByClassName(className);
	while (elements.length > 0)
		{
		elements[0].parentNode.removeChild(elements[0]);
		}
}

// Put little rectangles in the scrollbar region, placed vertically in proportion to
// where the selected text occurrences happen in the document.
function markHitsInScrollbar(textClassName, scrollHitClassName) {	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	// Fine-tuning: gray area of scrollbar is shortened by the up and down arrows, and starts
	// after the top arrow. There are no arrows on an iPad.
	let mainScrollY = markerMainElement.scrollTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	// let usableTextHeight = textViewableHeight - 2*arrowHeight;

	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowHeight = 18;
	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				//arrowHeight = Math.round(widthDifference) + 1;
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}
	
	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	let elements = document.getElementsByClassName(textClassName);
	for (let i = 0; i < elements.length; ++i)
		{
		let hitElement = elements[i];
		let elementBoundRect = hitElement.getBoundingClientRect();
		let textHitY = elementBoundRect.top;
		let positionInDoc = mainScrollY + textHitY - yTop;
		let positionRatio = positionInDoc / mainScrolllHeight;
		let relativeMarkerPos = positionRatio * usableTextHeight;
		let absMarkerPos = relativeMarkerPos + yTop + arrowHeight;

		let mk = document.createElement("mark");
		mk.setAttribute("class", scrollHitClassName);
		mk.style.top = absMarkerPos + "px";
		markerMainElement.appendChild(mk);
		}
}

function evtIsInScrollbar(evt) {
	let result = false;
	if (evt !== null)
		{
		if (evt.offsetX >= markerMainElement.clientWidth
				|| evt.offsetY >= markerMainElement.clientHeight)
			{
			// Mouse down over scroll element
			result = true;
			}
		}
	return (result);
}

// Remember the element that starts the selection.
function storeSelection() {
	theSelection.ltRange = lightrange.saveSelection();
}

// Look at siblings of startElement, advance until element does not contain a <mark> subelement.
function showStoredSelections() {
	lightrange.restoreSelection(theSelection.ltRange);
}

function saveSelection() {
	if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.getRangeAt && sel.rangeCount) {
	        return sel.getRangeAt(0);
	    }
	} else if (document.selection && document.selection.createRange) {
	    return document.selection.createRange();
	}
return null;
}

// Set theSelection.currentSelectionElem to TD holding selection, 
// and clone and remove the TD - only if not "too big".
function hideSelectionRow() {
	theSelection.currentSelectionElem = null;
	theSelection.currentSelPreviousSibling = null;
	if (theSelection.selectionIsTooBig)
		{
		return;
		}

	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		else
			{
			theSelection.currentSelectionElem = tdElem;
			theSelection.currentSelPreviousSibling = theSelection.currentSelectionElem.previousSibling;
			}
		}

	if (theSelection.currentSelectionElem !== null)
		{
		let currSelTD = theSelection.currentSelectionElem;
		let i = 0;
		theSelection.selChildren = [];
		
		findRangeTopContainers();
		
		let tdChildNodes = currSelTD.childNodes;
		for  (let j = 0; j < tdChildNodes.length; ++j)
			{
			
			if (tdChildNodes[j] === theSelection.topStartNode)
				{
				recordStartSelIndexes(j, tdChildNodes[j]);
				}

			if (tdChildNodes[j] === theSelection.topEndNode)
				{
				recordEndSelIndexes(j, tdChildNodes[j]);
				}
			}
		
		
		while (theSelection.currentSelectionElem.firstChild)
			{
			theSelection.selChildren[i++] = theSelection.currentSelectionElem.firstChild.cloneNode(true);
			theSelection.currentSelectionElem.removeChild(theSelection.currentSelectionElem.firstChild);
			}
		}
	}

function findRangeTopContainers() {
	let topStartNode = theSelection.ltRange.startContainer;
	while (topStartNode !== null && topStartNode.parentNode !== null && topStartNode.parentNode.nodeName !== "TD")
		{
		topStartNode = topStartNode.parentNode;
		}
	
	let topEndNode = theSelection.ltRange.endContainer;
	while (topEndNode !== null && topEndNode.parentNode !== null && topEndNode.parentNode.nodeName !== "TD")
		{
		topEndNode = topEndNode.parentNode;
		}
	
	theSelection.topStartNode = topStartNode;
	theSelection.topEndNode = topEndNode;
}

function recordStartSelIndexes(topIdx, topNode) {
	theSelection.startNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.startNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.startNodeIndexes.unshift(topIdx);
	theSelection.startNodeOffset = theSelection.ltRange.startOffset;
}

function recordEndSelIndexes(topIdx, topNode) {
	theSelection.endNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.endNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.endNodeIndexes.unshift(topIdx);
	theSelection.endNodeOffset = theSelection.ltRange.endOffset;
}

// Restore display of any TD element holding the current selection.
function showSelectionRow() {
	if (theSelection.currentSelectionElem !== null && theSelection.selChildren.length)
		{
		for (let i = 0; i < theSelection.selChildren.length; ++i)
			{
			theSelection.currentSelectionElem.appendChild(theSelection.selChildren[i]);
			
			
			if (i === theSelection.startNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setStart(node, theSelection.startNodeOffset);
				}
			if (i === theSelection.endNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setEnd(node, theSelection.endNodeOffset);
				}
			}
		
		restoreRangeStartsAndEnds();
		}
}

function restoreRangeStartsAndEnds() {
	let topNode = theSelection.currentSelectionElem;
	
	let drillDownNode = topNode;

	if (typeof drillDownNode === 'undefined')
		{
		return;
		}

	for (let i = 0; i < theSelection.startNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.startNodeIndexes[i]];
		}
	theSelection.ltRange.setStart(drillDownNode, theSelection.startNodeOffset);
	
	drillDownNode = topNode;
	for (let i = 0; i < theSelection.endNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.endNodeIndexes[i]];
		}
	theSelection.ltRange.setEnd(drillDownNode, theSelection.endNodeOffset);
}

// Skip along through childNodes until we hit a MARK and accumulated offset is
// >= targetOffset.
// Returns MARK node or null in [0], accumulated textLength in [1].
function markToSelect(node, textLength, targetOffset, markerNode) {
	if (markerNode !== null)
		{
		return ([ markerNode, textLength ]);
		}
	let lengthSoFar = textLength;
	let tagName = node.nodeName;
	if (tagName === "MARK")
		{
		let markLength = node.textContent.length;
		if (lengthSoFar + markLength >= targetOffset)
			{
			return ([ node, lengthSoFar + markLength ]);
			}
		}

	// Still here, go deeper.
	let numChildren = node.childNodes.length;
	if (numChildren == 0)
		{
		lengthSoFar += node.textContent.length;
		}
	else
		{
		for (let i = 0; i < node.childNodes.length; ++i)
			{
			let markNodeToSelectArray =
					markToSelect(node.childNodes[i], lengthSoFar, targetOffset, markerNode);
			lengthSoFar = markNodeToSelectArray[1];
			if (markNodeToSelectArray[0] !== null)
				{
				markerNode = markNodeToSelectArray[0];
				break;
				}
			}
		}

	return ([ markerNode, lengthSoFar ]);
}

// Link clicked means don't update markers for user's text selection.
function notelinkClicked(evt) {
	if (hintboxClicked)
		{
		hintboxClicked = false;
		return;
		}
	linkClicked = false;

	let target = evt.target || null;
	// Click might be on an "edit" pencil (edit1.png), move up to parent.
	if (target !== null && target.nodeName === "IMG")
		{
		target = target.parentNode;
		}
	if (target !== null && target.nodeName === "A")
		{
		linkClicked = true;
		}
	else
		{
		if (typeof target.id !== 'undefined')
			{
			if (target.id === "hintbox")
				{
				linkClicked = true;
				}
			}
		}
}

// The "hint" box shows a possibly reduced view of an image in text views. On an iPad,
// it's clickable. If clicked, we treat it as a click on a link and don't change the
// marked text.
function noteHintboxClicked() {
	hintboxClicked = true;
	linkClicked = true;
}

// Match braces, for Perl only.
const braceElements = [];
const braceSearchLinesMax = 1000;

function matchBraces() {
	removeBraceHighlights();

	let dir = 0;
	let withinPRE = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount === 1)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
			
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			if (tdElem.nodeName === "PRE")
				{
				withinPRE = true;
				// PRE is not currently handled.
				return;
				}
			tdElem = tdElem.parentNode;
			}
		
		if (tdElem !== null)
			{
			let tdChildren = tdElem.children;
			for (let i = 0; i < tdChildren.length; ++i)
				{
				if (tdChildren[i].nodeName === "SPAN")
					{
					let classes = tdChildren[i].className;
					if (classes.indexOf('Symbol') >= 0 && classes.indexOf('b-') >= 0)
						{
						// Contains curly brace { or }
						let brace = tdChildren[i].textContent; // or innerHTML?
						if (brace === '{')
							{
							dir = 1;
							}
						else if (brace === '}')
							{
							dir = 2;
							}
						// else serious error somewhere
						// Remember and highlight the span.
						addClass(tdChildren[i], 'brace-highlight');
						// Put color on the TD for line number.
						addClass(tdElem.previousSibling, 'brace-line-highlight');
						braceElements.push(tdElem);

						// Now find, remember, and highlight the other end.
						let braceClassMatches = classes.match(/(b-\d+)/i);
						if (braceClassMatches !== null)
							{
							let braceClass = braceClassMatches[1];
							// TEST ONLY
							//console.log("Brace class: " + braceClass);
							doOtherBrace(tdElem, dir, braceClass);
							}
						break;
						}
					}
				}
			}
		}
	
		if (dir > 0)
			{
			;//console.log("braceSeen: " + braceSeen);
			}
		
		return(dir);
	}

function removeBraceHighlights() {
	while (braceElements.length > 0)
		{
		let tdElem = braceElements.pop();
		removeClass(tdElem.previousSibling, 'brace-line-highlight');
		let tdChildren = tdElem.children;
		for (let i = 0; i < tdChildren.length; ++i)
			{
			removeClass(tdChildren[i], 'brace-highlight');
			}
		}
}

// dir: 1 == down/forward, 2 == back/upwards
function doOtherBrace(firstTD, dir, braceClass) {
	let parent = firstTD.parentElement;
	if (parent === null)
		{
		return;
		}

	let prevTR = parent;
	let foundIt = false;
	let counter = 0;
	while (prevTR !== null && !foundIt)
		{
		if (prevTR.firstChild !== null)
			{
			let tdElem = prevTR.firstChild.nextSibling;
			if (tdElem !== null)
				{
				let tdChildren = tdElem.children;
				for (let i = 0; i < tdChildren.length; ++i)
					{
					if (tdChildren[i].nodeName === "SPAN")
						{
						let classes = tdChildren[i].className;
						if (classes.indexOf('Symbol') >= 0 && classes.indexOf(braceClass) >= 0)
							{
							if (counter > 0 || classes.indexOf('brace-highlight') < 0)
								{
								addClass(tdChildren[i], 'brace-highlight');
								// Put color on the TD for line number.
								addClass(tdElem.previousSibling, 'brace-line-highlight');
								braceElements.push(tdElem);
								foundIt = true;
								break;
								}
							}
						}
					}
				// No good, with too many line numbers colored, removal is glitchy.
				//addClass(tdElem.previousSibling, 'brace-line-highlight');
				braceElements.push(tdElem);
				}
			else
				{
				break;
				}
			if (++counter >= braceSearchLinesMax)
				{
				removeBraceHighlights();
				break;
				}

			}
		prevTR = (dir === 1) ? prevTR.nextSibling : prevTR.previousSibling;
		}
}

let addHintTimer; // onMobile, to keep trying addHintboxListener() until it succeeds.

function addHintboxListener() {
	let tooltipElement = document.getElementById("hintbox");
	if (tooltipElement !== null)
		{
		tooltipElement.addEventListener("touchstart", noteHintboxClicked);
		clearInterval(addHintTimer);
		}
}

if (onMobile)
	{
	addHintTimer = setInterval(addHintboxListener, 200);
	}

document.addEventListener("mousedown", notelinkClicked);

if (thePath.match(/\.(pl|pm|cgi|t)$/i))
	{
	document.addEventListener("mouseup", matchBraces);
	}

ready(finishStartup);

</script>
<script type="text/javascript">
/**
 * indicator.js: Mainly a scroll indicator for PCs and iPads in non-codemirror views (text, perl etc).
 */

// 'indicator is for mobile', 'indicatorPC' is for a regular Windows box.
let indicatorElem = onMobile ? document.getElementById('indicator') : document.getElementById('indicatorPC');
let otherIndicatorElem = onMobile ? document.getElementById('indicatorPC') : document.getElementById('indicator');
//let indicatorElem = document.getElementById('indicator');
let indicatorM = 0; // for mobile and non-mobile
let lazySetUpMobileIndicator = JD.debounce(setUpMobileIndicator, 100);
let lazyMobileScroll = JD.debounce(scrollMobileIndicator, 500);
let lazyResetTopNavPosition = JD.debounce(resetTopNavPosition, 400);

let lazySetUpIndicator = JD.debounce(setUpIndicator, 100);
let lazyScroll = JD.debounce(scrollIndicator, 500);
let arrowHeight = 18; // Needed for PC only.

otherIndicatorElem.style.display = 'none';


if (onMobile) // iPad only supported for now....
	{
	//console.log("WE ARE MOBILE.");
	window.addEventListener("load", lazySetUpMobileIndicator);
	window.addEventListener("resize", lazySetUpMobileIndicator);
	markerMainElement.addEventListener("scroll", scrollMobileIndicator);
	markerMainElement.addEventListener("touchend", lazyResetTopNavPosition);

	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement !== null)
		{
		tocElement.addEventListener("touchend", lazyMobileScroll);
		tocElement.addEventListener("touchend", lazyResetTopNavPosition);
		}
	}
else
	{
	window.addEventListener("load", lazySetUpIndicator);
	window.addEventListener("resize", lazySetUpIndicator);
	
	markerMainElement.addEventListener("scroll", scrollIndicator);
	window.addEventListener("load", addHideIndicatorScrollListener);
	
	hideIt("search-button");
	hideIt("small-tip");
	hideIt("undo-button");
	hideIt("redo-button");
	}

// Mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;

	if (mainScrolllHeight > textViewableHeight)
		{
		let indicatorHeight = (textViewableHeight / mainScrolllHeight) * textViewableHeight;
		indicatorM =
				(textViewableHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);

		if (indicatorHeight < 2.0)
			{
			indicatorHeight = 2.0;
			}
		indicatorElem.style.height = indicatorHeight + "px";
		}

	lazyMobileScroll();
}

// Non-mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpIndicator() {
	if (onMobile)
		{
		return;
		}
	
	recalculateIndicatorM();

	lazyScroll();
	
	setTimeout(function() {
				hideIndicator();
			}, 1000);
}

function recalculateIndicatorM() {
	if (onMobile)
		{
		return;
		}
	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	
	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}

	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	if (mainScrolllHeight > usableTextHeight)
		{
		let indicatorHeight = usableTextHeight * (textViewableHeight/(mainScrolllHeight));
		
		// Show the indicator only if thumb is too small to reflect actual page size.
		if (indicatorHeight <= 20)
			{
			indicatorM =
					(usableTextHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);
	
			if (indicatorHeight < 2.0)
				{
				indicatorHeight = 2.0;
				}
			indicatorElem.style.height = indicatorHeight + "px";
			}
		else
			{
			indicatorM = 0;
			}
		}
	else
		{
		indicatorM = 0;
		}
}

// Mobile, set indicatorElem.top
function scrollMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop;
		indicatorElem.style.top = newThumbTop + "px";
		}
}

// Non-mobile, set indicatorElem.top
function scrollIndicator() {
	if (onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		indicatorElem.style.display = 'block';
		
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop + arrowHeight;
		indicatorElem.style.top = newThumbTop + "px";
		}

	// Sometimes the lines change, reset indicatorM.
	recalculateIndicatorM();
}

// Add a scroll listener that hides the 'indicatorPC' box after a few seconds.
let isScrollingIndicator = null;
function addHideIndicatorScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrollingIndicator );
	
			// Set a timeout to run after scrolling ends
			isScrollingIndicator = setTimeout(function() {
				// Run the callback
				hideIndicator();
			}, 3000);
			});
		}
}

function hideIndicator() {
	if (indicatorElem !== null)
		{
		indicatorElem.style.display = 'none';
		}
}

</script>
<script type="text/javascript">
// toggle.js: toggle between two positions in a document.
// This is for non-CodeMirror file views, as presented by IntraMine's Viewer service.
// Track "proximal" (current) and "distal" (previous) positions
// in response to all changes in scrolled position.
// If it's a small move, update the proximal position.
// If it's a big move, call the new position proximal, and the old
// proximal becomes distal.
// Toggle: scroll distal into view, and switch proximal with distal.

let proximalLineNumber = 1;	// "here"
let distalLineNumber = 1;	// "there"
let bigMoveLineLimit = 100; // Big move vs small move

function toggle() {
	//console.log("Toggle click");
	//console.log("Toggle, before: here " + proximalLineNumber + ", there " + distalLineNumber);
	let tempNum = proximalLineNumber;
	proximalLineNumber = distalLineNumber;
	distalLineNumber = tempNum;
	let el = document.getElementById(cmTextHolderName);
	//console.log("Toggle, AFTER: here " + proximalLineNumber + ", there " + distalLineNumber);
	restoreTopPositionNonCM(el, proximalLineNumber);
}

function updateTogglePositions() {
	let el = document.getElementById(cmTextHolderName);
	let myStartLine = firstVisibleLineNumber(el);
	//console.log("update myStartLine " + myStartLine);
	if (myStartLine < 1)
		{
		myStartLine = 1;
		}
	//console.log("update here " + proximalLineNumber);
	let linesScrolled = proximalLineNumber - myStartLine;
	//console.log("update lines scrolled: " + linesScrolled);
	if (linesScrolled < 0)
		{
		linesScrolled = -linesScrolled;
		}
	if (linesScrolled <= bigMoveLineLimit)
		{
		//console.log("small move, here " + proximalLineNumber + ", there " + distalLineNumber + " before update");
		proximalLineNumber = myStartLine;
		//console.log(" here is " + proximalLineNumber + " after update.)");
		}
	else
		{
		//console.log("Big move! here " + proximalLineNumber + ", there " + distalLineNumber + " before update")
		distalLineNumber = proximalLineNumber;
		proximalLineNumber = myStartLine;
		//console.log("AFTER BIG MOVE: here "+ proximalLineNumber + ", there " + distalLineNumber);
		}
	//console.log("Toggle position update top line " + myStartLine);
}

// Borrowed from
//https://gomakethings.com/detecting-when-a-visitor-has-stopped-scrolling-with-vanilla-javascript/
let isScrolling = null;
function addToggleScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrolling );
	
			// Set a timeout to run after scrolling ends
			isScrolling = setTimeout(function() {
				// Run the callback
				updateTogglePositions();
			}, 66);
			});
		}
}

// Set the number of lines that counts as a "big move"
// (meaning a real change of position, not just an adjustment
// of current position).
// Called by viewerStart.js#doResize() and on load by
// viewerStart.js#reJumpAndHighlight().
function updateToggleBigMoveLimit() {
	let el = document.getElementById(cmTextHolderName);
	let firstVisibleLineNum = firstVisibleLineNumber(el);
	let lastVisibleLineNum = lastVisibleLineNumber(el);
	
	// Problem, sometimes lastVisibleLineNumber() can return 0.
	if (lastVisibleLineNum === 0)
		{
		lastVisibleLineNum = lastVisibleLineNumber(el);
		if (lastVisibleLineNum === 0)
			{
			//console.log("EARLY EXIT in updateToggleBigMoveLimit!");
			return;
			}
		}
	
	let numVisibleLines = lastVisibleLineNum - firstVisibleLineNum;
	if (numVisibleLines <= 10)
		{
		bigMoveLineLimit = 20;
		//console.log("TINY WINDOW!");
		}
	else
		{
		bigMoveLineLimit = numVisibleLines + 10;
		}
	
	//console.log("First vis: " + firstVisibleLineNum);
	//console.log("LAST vis: " + lastVisibleLineNum);
	//console.log("Big move limit: " + bigMoveLineLimit);
}

window.addEventListener("load", addToggleScrollListener);


</script>
<script type="text/javascript">
/**
 * scrollTOC.js: when a heading is clicked in text, scroll corresponding Table of Contents
 * entry into view. Non-CodeMirror files only. See cmScrollTOC.js for CodeMirror handling.
 */

// Scroll the Table of Contents:
// if click was in text content, to heading at or just before line clicked.
// if scrolling, to heading at or just after first visible line.
function scrollTocEntryIntoView(evt, weAreScrolling) {
	let tocElem = null;

	if (!weAreScrolling)
		{
		let lineNum = lineNumberforAnchor();
		if (lineNum >= 0)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}
		else
			{
			// Treat as for scrolling.
			weAreScrolling = true;
			}
		}
	
	if (weAreScrolling)
		{
		let el = document.getElementById(cmTextHolderName);
		let limitLineNum = lastVisibleLineNumber(el) + 1;
		let lineNum = firstVisibleLineNumber(el);
		tocElem = getTocElemAfterLineNumber(lineNum, limitLineNum);
		if (tocElem === null)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}

		// For restoring scrolled position after a reload.
		location.hash = lineNum.toString();
		}
		
	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}

// This is called only for Markdown files, see addTocScrollListener() below.
function scrollMarkdownTocEntryIntoView(evt) {
	let tocDiv = document.getElementById('scrollContentsList');
	if (tocDiv === null)
		{
		return;
		}
	
	const idRegExp = /mdJump\(\'([^\']+)/;
	let tocElemIdentifier = markdownCurrentHeaderID();
	let tocElem = null;
	if (tocElemIdentifier !== '')
		{
		// Find corresponding entry in the TOC, scroll it into view and highlight.
		// The tocDiv contains a <ul> which contains <li>'s which each contain an <a>.
		let ulElement = tocDiv.firstElementChild;
		if (ulElement !== null)
			{
			let listElements = ulElement.children;			
			for (let i = 0; i < listElements.length; i++)
				{
				let anchorElement = listElements[i].firstElementChild;
				if (anchorElement !== null)
					{
					// Get the <li> element's contents, eg
					// <a onclick="mdJump('intraminesservices');">IntraMine's services</a>
					let listItemContents = listElements[i].innerHTML;

					let idMatchArr = listItemContents.match(idRegExp);
					if (idMatchArr !== null)
						{
						let potentialID = idMatchArr[1];
						if (potentialID === tocElemIdentifier)
							{
							tocElem = listElements[i];
							break;
							}
						}
					}
				}
			}
		}

	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}

// Restore scrolled position of Table of Contents.
// Called by  viewerStart.js#reJumpToLineNumber().
function restoreTocSelection(lineNum) {
	let tocElem = null;

	let el = document.getElementById(cmTextHolderName);
	let limitLineNum = lastVisibleLineNumber(el) + 1;
	tocElem = getTocElemAfterLineNumber(lineNum, limitLineNum);
	if (tocElem === null)
		{
		tocElem = getTocElemForLineNumber(lineNum);
		}
	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}

// Get text line number for current selection anchor, or -1.
function lineNumberforAnchor() {
	let currSelection = window.getSelection();
	if (currSelection === null)
		{
		return(-1);
		}
	
	let lineNum = -1;
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.startContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem !== null)
			{
			let previousElem = tdElem.previousElementSibling;
			if (previousElem !== null)
				{
				let tdLineNum = previousElem.getAttribute("n");
				if (tdLineNum !== null)
					{
					lineNum = tdLineNum;
					}
				}
			}
		}
	
	return (lineNum);
}

// Return TOC element that is at or closest above the text line number.
// Called for mouse/touch in actual text content.
// Typical non-CodeMirror TOC entry:
// <li class="h2" im-text-ln="123">
function getTocElemForLineNumber(lineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let previousTocElem = null;
	let previousTocElemLineNum = 0;
	let lowestNumberedElem = null;
	let lowestNumberedElemNumber = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum <= lineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (previousTocElemLineNum <  tocLineNum)
				{
				previousTocElemLineNum = tocLineNum;
				previousTocElem = tocEntries[i];
				}
			
			if (lowestNumberedElemNumber == 0 || lowestNumberedElemNumber > tocLineNum)
				{
				lowestNumberedElemNumber = tocLineNum;
				lowestNumberedElem = tocEntries[i];
				}
			}
		}
	
	if (tocElem === null && previousTocElem !== null)
		{
		tocElem = previousTocElem;
		}
	else if (tocElem === null && lowestNumberedElem !== null)
		{
		tocElem = lowestNumberedElem;
		}
	
	return(tocElem);
}

// Return TOC element that is at or closest *below* the text line number.
// Called after a scroll. Element must be before the visible bottom of the page,
// otherwise we should be looking upwards from the top of page for the heading
// that applies to the current position.
function getTocElemAfterLineNumber(lineNum, limitLineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let nextTocElem = null;
	let nextTocElemLineNum = 999999;
	let lastTocElem = null;
	let lastTocElemLineNum = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum >= lineNum && tocLineNum <= limitLineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (nextTocElemLineNum >  tocLineNum)
				{
				nextTocElemLineNum = tocLineNum;
				nextTocElem = tocEntries[i];
				}
			
			if (lastTocElemLineNum < tocLineNum)
				{
				lastTocElemLineNum = tocLineNum;
				lastTocElem = tocEntries[i];
				}
			}
		}

	
	if (tocElem === null && nextTocElem !== null)
		{
		tocElem = nextTocElem;
		}
	else if (tocElem === null && lastTocElem !== null)
		{
		tocElem = lastTocElem;
		}
	
	return(tocElem);
}

let scrollingForToc = null;
let isMarkdownFile = pathIsForMarkdown(thePath);
function addTocScrollListener(evt) {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function(evt) {
			// Clear our timeout throughout the scroll
			window.clearTimeout( scrollingForToc );
	
			// Set a timeout to run after scrolling ends
			scrollingForToc = setTimeout(function() {
				// Run the callback.
				if (isMarkdownFile)
					{
					scrollMarkdownTocEntryIntoView(evt);
					}
				else
					{
					scrollTocEntryIntoView(evt, true);
					}
				// Trying to stabilize nav bar, sometimes it randomly
				// jumps off the top of the window.
				resetTopNavPosition();
			}, 66);
			});
		}
}

function pathIsForMarkdown(path)
	{
	const markdownRegex = new RegExp("\.(md|mkd|markdown)$");
	let result = markdownRegex.test(path);
	return(result);
	}

function updateTocHighlight(elem) {
	if (elem === null)
		{
		return;
		}
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		if (hasClass(tocEntries[i], selectedTocId))
			{
			removeClass(tocEntries[i], selectedTocId);
			}
		}
	
	addClass(elem, selectedTocId);
}

window.addEventListener("load", addTocScrollListener);

</script>
<script type="text/javascript">
// dragTOC.js: drag pane-separator to vary width of Table of Contents.
// localStorage is used to remember and restore the TOC width.
// See also dragTOC.css.
// Used by intramine_viewer.pl.

let leftPane = document.getElementById('scrollContentsList'); // 'left-pane'
let rightPane = document.getElementById('scrollTextRightOfContents'); // 'right-pane'
let panesContainer = document.getElementById('scrollAdjustedHeight'); // 'panes-container'
let paneSep; // 'panes-separator', eventually (see below)
let topLineNumber; // for restoring scrolled position when the separator is dragged.

// This is done in viewerStart.js#reJumpAndHighlight(). Doing it earlier there
// results in a stable first line number for the text. And it's now done
// early in the Editor, see editor.js#loadFileIntoCodeMirror().
/////window.addEventListener("load", addDragger);

function addDragger() {
    if (leftPane === null || rightPane === null || panesContainer === null)
        {
        return;
        }
    

    let paneSepElement = document.getElementById('panes-separator');
    if (paneSepElement === null)
        {
        let paneSepString = "<div class='panes-separator' id='panes-separator'></div>";
        let paneSeparator = createElementFromHTML(paneSepString);
        panesContainer.insertBefore(paneSeparator, rightPane);
        }

    paneSep = document.getElementById('panes-separator');
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);
    let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
    let paneSepWidth = parseFloat(paneSepWidthStr);
    let separatorPercent = paneSepWidth / widthPanesContainer * 100;
    // Retrieve left pane width from localStorage if possible, else leave width alone.
    let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
    let leftPaneWidthStr;
    let widthLeftPane;
    let cur;
    if (!localStorage.getItem(leftPaneWidthKey))
        {
        cur = 23; // toc width default is 23%
        widthLeftPane = cur * widthPanesContainer / 100;
        localStorage.setItem(leftPaneWidthKey, widthLeftPane);
        leftPane.style.width = cur + '%';
        }
    else
        {
        leftPaneWidthStr = localStorage.getItem(leftPaneWidthKey);
        widthLeftPane = parseFloat(leftPaneWidthStr);
        cur = widthLeftPane / widthPanesContainer * 100;
        if (cur < 5)
            {
            cur = 23; // toc width default is 23%
            widthLeftPane = cur * widthPanesContainer / 100;
            localStorage.setItem(leftPaneWidthKey, widthLeftPane);
            leftPane.style.width = cur + '%';
            }
        else
            {
            leftPane.style.width = cur + '%';
            }
        }
    
    let right = (100-cur-separatorPercent);
    rightPane.style.width = right + '%';

    paneSep.addEventListener('mousedown', startDraggingSeparator);

    //TEST ONLY
    // console.log("leftPaneWidthKey: " + leftPaneWidthKey);
	// console.log("widthLeftPane: " + widthLeftPane);
    // console.log("leftPaneWidthStr: " + leftPaneWidthStr);
	// console.log("panesContainerWidthStr: " + panesContainerWidthStr);
	// console.log("paneSepWidthStr: " + paneSepWidthStr);
	// console.log("paneSepWidth: " + paneSepWidth);
	// console.log("separatorPercent: " + separatorPercent);
	// //console.log("leftPanePC: " + leftPanePC);
	// console.log("right: " + right);

}

function separatorMouseUp() {
    window.removeEventListener('mousemove', moveSeparator);
    window.removeEventListener('selectstart', disableSelect);
    document.body.style.cursor = '';

    if (usingCM)
        {
        let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
        let startPos  = myCodeMirror.lineAtHeight(rect.top, "window");
        scrollTocEntryIntoView(startPos, false, true);

        if (typeof topLineNumber !== 'undefined')
            {
            location.hash = topLineNumber;
            }
        cmQuickRejumpToLine(); // Restores first text line in contents
        }

    // Remember left pane (TOC) width.
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);
    let leftPaneStr = leftPane.style.width;
    let leftPanePC = parseFloat(leftPaneStr);
    let leftPanePixels = leftPanePC * widthPanesContainer / 100;
    let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
    localStorage.setItem(leftPaneWidthKey, leftPanePixels);
    
    // Remove this function from mouseup, otherwise it's called for any mouseup.
    window.removeEventListener('mouseup', separatorMouseUp);
}

// Poke top line number of text into topLineNumber, for restoring scrolled position.
function rememberLocation() {
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
		let lineNumber = parseInt(myStartLine.toString(), 10);
		if (lineNumber > 0)
			{
			lineNumber += 2;
			}
		else
			{
			lineNumber = 1;
			}
        topLineNumber = lineNumber.toString();
		}
	else // text mainly
		{
		let el = document.getElementById(cmTextHolderName);
        if (el === null)
            {
            console.log("dragTOC.js#rememberLocation cmTextHolderName is missing!");
            return;
            }
		let lineNumber = firstVisibleLineNumber(el);
        topLineNumber = lineNumber.toString();
		}
	}

function getFirstVisibleLineNumber() {
    let firstLineNumber = -1;
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
		let lineNumber = parseInt(myStartLine.toString(), 10);
		if (lineNumber > 0)
			{
			lineNumber += 2;
			}
		else
			{
			lineNumber = 1;
			}
        firstLineNumber = lineNumber;
 		}
	else // text mainly
		{
		let el = document.getElementById(cmTextHolderName);
        if (el === null)
            {
            console.log("dragTOC.js#getFirstVisibleLineNumber cmTextHolderName is missing!");
            return(0);
            }
		firstLineNumber = firstVisibleLineNumber(el);
 		}

    return(firstLineNumber);
}

function startDraggingSeparator(e) {
    rememberLocation();
    document.body.style.cursor = 'col-resize';
    window.addEventListener('mousemove', moveSeparator);
    window.addEventListener('selectstart', disableSelect);
    window.addEventListener('mouseup', separatorMouseUp);
}

function moveSeparator(e) {
    let sepLeft = e.clientX - 20;
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);

    let leftPanePC = sepLeft / widthPanesContainer * 100;
    if (leftPanePC < 5)
        {
        leftPanePC = 5;
        }
    else if (leftPanePC > 90)
        {
        leftPanePC = 90;
        }
    leftPane.style.width = leftPanePC + '%';
    let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
    let paneSepWidth = parseFloat(paneSepWidthStr);
    let separatorPercent = paneSepWidth / widthPanesContainer * 100;
    let right = (100-leftPanePC-separatorPercent);
    rightPane.style.width = right + '%';

    if (initialSearchHitsAreShowing)
        {
        removeInitialHighlights();
        highlightInitialItems();
        }

    // Also redo scroll bar markers for selection hits in the scroll bar.
    if (!usingCM)
        {
        removeAllScrollbarHighlights(scrollMarkerClass);
        markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
        location.hash = topLineNumber;
        reJump();
        }
    else
        {
        //let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
        //let startPos  = myCodeMirror.lineAtHeight(rect.top, "window") + 2;
        location.hash = topLineNumber;
        myCodeMirror.refresh();
        reJump();
        }
}

function disableSelect(event) {
    event.preventDefault();
}
</script>
<script type="text/javascript">
/*! lolight v1.4.0 - https://larsjung.de/lolight/ modified to add 'my' and 'sub' keywords. -KLB */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.lolight=t()}(this,function(){function t(e){if("string"!=typeof e)throw new Error("tok: no string");for(var t=[],n=u.length,o=!1;e;)for(var r=0;r<n;r+=1){var i=u[r][1].exec(e);if(i&&0===i.index){var a=u[r][0];if("rex"!==a||!o){var l=i[0];a===s&&c.test(l)&&(a="key"),"spc"===a?0<=l.indexOf("\n")&&(o=!1):o=a===f||a===s,e=e.slice(l.length),t.push([a,l]);break}}}return t}function e(e,t){if("undefined"!=typeof document)t(document);else if(e)throw new Error("no doc")}function n(o){e(!0,function(n){var e=t(o.textContent);o.innerHTML="",e.forEach(function(e){var t=n.createElement("span");t.className="ll-"+e[0],t.textContent=e[1],o.appendChild(t)})})}function o(t){e(!0,function(e){[].forEach.call(e.querySelectorAll(t||".lolight"),function(e){n(e)})})}var r="_nam#2196f3}_num#ec407a}_str#43a047}_rex#ef6c00}_pct#666}_key#555;font-weight:bold}_com#aaa;font-style:italic}".replace(/_/g,".ll-").replace(/#/g,"{color:#"),c=/^(a(bstract|lias|nd|rguments|rray|s(m|sert)?|uto|sync)|b(ase|egin|ool(ean)?|reak|yte)|c(ase|atch|har|hecked|lass|lone|ompl|onst|ontinue)|de(bugger|cimal|clare|f(ault|er)?|init|l(egate|ete)?)|do|double|e(cho|ls?if|lse(if)?|nd|nsure|num|vent|x(cept|ec|p(licit|ort)|te(nds|nsion|rn)))|f(allthrough|alse|inal(ly)?|ixed|loat|or(each)?|riend|rom|unc(tion)?)|global|goto|guard|i(f|mp(lements|licit|ort)|n(it|clude(_once)?|line|out|stanceof|t(erface|ernal)?)?|s)|l(ambda|et|ock|ong)|m(odule|utable|y)|NaN|n(amespace|ative|ext|ew|il|ot|ull)|o(bject|perator|r|ut|verride)|p(ackage|arams|rivate|rotected|rotocol|ublic)|r(aise|e(adonly|do|f|gister|peat|quire(_once)?|scue|strict|try|turn))|s(byte|ealed|elf|hort|igned|izeof|tatic|tring|truct|ubscript|uper|ynchronized|witch|ub)|t(emplate|hen|his|hrows?|ransient|rue|ry|ype(alias|def|id|name|of))|u(n(checked|def(ined)?|ion|less|signed|til)|se|sing)|v(ar|irtual|oid|olatile)|w(char_t|hen|here|hile|ith)|xor|yield)$/,i="com",s="nam",f="num",u=[[f,/#([0-9a-f]{6}|[0-9a-f]{3})\b/],[i,/(\/\/|#).*?(?=\n|$)/],[i,/\/\*[\s\S]*?\*\//],[i,/<!--[\s\S]*?-->/],["rex",/\/(\\\/|[^\n])*?\//],["str",/(['"`])(\\\1|[\s\S])*?\1/],[f,/[+-]?([0-9]*\.?[0-9]+|[0-9]+\.?[0-9]*)([eE][+-]?[0-9]+)?/],["pct",/[\\.,:;+\-*\/=<>()[\]{}|?!&@~]/],["spc",/\s+/],[s,/[\w$]+/],["unk",/./]];return e(!1,function(e){var t=e.querySelector("head"),n=e.createElement("style");n.textContent=r,t.insertBefore(n,t.firstChild),/^(i|c|loade)/.test(e.readyState)?o():e.addEventListener("DOMContentLoaded",function(){o()})}),o.tok=t,o.el=n,o});
</script>
<script type="text/javascript">
// viewer_hover_inline_images.js: toggle between showing images
// as hover tooltips or inline.
// Only for .txt files. When the #inlineImages button is clicked, we do a reload().
// The state is remembered in localStorage.

// Hover / Inline Button clicked, set localStorage for
// 'inlineImages' and reload.
function toggleImagesButton() {
	let buttonElem = document.getElementById("inlineImages");
	if (buttonElem === null)
		{
		return;
		}
	let shouldInline = shouldInlineImages();
	shouldInline = !shouldInline;
	let imageKey = thePath + '?' + 'inlineImages';
	localStorage.setItem(imageKey, shouldInline);
	
	window.location.reload();
}

// Button hover / inline state is kept in localStorage.
function shouldInlineImages() {
	let imageKey = thePath + '?' + 'inlineImages';
	let shouldInline = localStorage.getItem(imageKey);
	if (shouldInline === 'true' || shouldInline === true)
		{
		shouldInline = true;
		}
	else
		{
		shouldInline = false;
		}

	return(shouldInline);
	}

// Call during load, or when the Hover / Inline button is clicked.
function setImagesButtonText() {
	let buttonElem = document.getElementById("inlineImages");
	if (buttonElem === null)
		{
		return;
		}
	let imageKey = thePath + '?' + 'inlineImages';
	let shouldInline = shouldInlineImages();
	let buttonText = (shouldInline) ? 'Hover Images' : 'Inline Images';
	buttonElem.value = buttonText;
}

</script>
<script type="text/javascript">
// popup_image_cache.js: retrieve bin64 images from a Map.
// The Map is created in gloss.pm when loading images for
// glossary popups. The goal is to have just
// one stored instance of each image that's use in a popup
// definition. Images are loaded into the popup definition
// when the popup is shown.

// Given popup hint text containing image placeholders such as '__img__cache__00007',
// replace with bin64 image from imageCache.
function loadCachedImages(text) {

	// If we get here too early before imageCache is defined, just leave.
	if (typeof imageCache === 'undefined')
		{
		return;
		}

	let keyLength = 19; // Length of __img__cache__ plus 5 for the digits
	const imagePositions = [];
	let cacheKeyRegExp = new RegExp('__img__cache__[0-9][0-9][0-9][0-9][0-9]', 'g');
	let match = {};
	while ((match = cacheKeyRegExp.exec(text)) !== null)
		{
		let currentMatchPos = match.index;
		imagePositions.push(currentMatchPos);
		}
		
	// Loop through array in reverse, putting in images.
	for (let i = imagePositions.length - 1; i >= 0; --i)
		{
		let imageKey = text.substr(imagePositions[i], keyLength);
		if (imageCache.has(imageKey))
			{
			let bin64Image = imageCache.get(imageKey);
			text = text.substr(0, imagePositions[i]) + bin64Image + text.substr(imagePositions[i] + keyLength);
			}
		}
		
	return(text);
}

</script>

<script>const imageCache = new Map();

</script>
</body></html>
