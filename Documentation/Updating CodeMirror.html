<!doctype html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-touch-fullscreen" content="yes" />
<meta name="google" content="notranslate">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>Updating CodeMirror</title>
<style>
/* main.css: the place where failure to plan goes to die. */

h1 {
	font-size: 1.5em;
}

.shimclear {
	height: 6px;
	float: none;
}

/*#help {display:none;}*/

/* ipadfix out overflow: hidden; in width: 100%*/
html, body {
    overflow: hidden;
	height: 100%;
   /* width: 100%*/
}

body {
	background: #fafafa;
	font: normal .8em/1.5em Arial, Helvetica, sans-serif;
	min-width: 800px;
	margin-left: 1%;
	margin-right: 0.5%;
	margin-top: 0;
	margin-bottom: 0;
	/* Experimental, trying to get word breaks on iPad Pro */
	/* Doesn't help: overflow-wrap: break-word; */
	/* Works, but breaks on everything: word-break: break-all; */
}

/* ipadfix adding a wrapper around entire body */
#bodywrapper {
	position: fixed; height:100%; width:100%; top:0; left:0;
}

#pageContent {
	height: 100%;
}

a {
text-decoration: none;
}

a:link {
color: Black;
border-bottom: 1px solid #AAA;
}

a:visited {
color: #333;
border-bottom: 1px solid #AAA;
}

a:hover {
color: #333;
border-bottom: 1px solid #333;
}

#scrollContentsList a:link {
	border-bottom: 0;
}

/* File tree displays, suppress underlines on links. */
UL.jqueryFileTree A {
	border-bottom: none;
}

/* ipadfix adding wrapper around fixed top part */
#fixed_header {
	position: absolute; top:0; left:0; width:100%; height: 200px; z-index:10;
	}

#nav {
	position: relative;
	display: block;
	margin: 0;
	margin-top: 8px;
	padding: 7px 6px 0;
	line-height: 100%;
	border-radius: .4em;

	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);

	/*background: -webkit-gradient(linear, left top, left bottom, from(#a9a9a9), to(#7a7a7a));*/
	background: -webkit-gradient(linear, left top, left bottom, from(#999999), to(#333333));

	border: solid 1px #6d6d6d;
	min-width:770px;
}
#nav li {
	margin: 0 5px;
	padding: 0 0 8px;
	float: left;
	position: relative;
	list-style: none;
}
/* main level link */
#nav a {
	font-weight: bold;
	color: #e7e5e5;
	text-decoration: none;
	border-bottom: none;
	display: block;
	padding:  8px 15px;
	margin: 0;
	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .3);
}
/* main level link hover */
#nav .current a, #nav li:hover > a {
	background: -webkit-gradient(linear, left top, left bottom, from(#ebebeb), to(#a1a1a1)); /* for webkit browsers */
	border-top: solid 1px #f8f8f8;
	-webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	-moz-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	text-shadow: 0 1px 0 rgba(255, 255, 255, .8);
}

#nav li:hover > a {
	color: #444;
}

#nav .current a, #nav .current:hover > a {
	color: #008000; /*#31540c*/
}

/* sub levels link hover */
#nav ul li:hover a, #nav li:hover li a {
	background: none;
	border: none;
	color: #666;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
}
#nav ul a:hover {
	background: -webkit-gradient(linear, left top, left bottom, from(#04acec), to(#0186ba)) !important; /* for webkit browsers */

	color: #fff !important;
	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .1);
}
/* level 2 list */
#nav ul {
	background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#cfcfcf)); /* for webkit browsers */

	display: none;
	margin: 0;
	padding: 0;
	width: 185px;
	position: absolute;
	top: 35px;
	left: 0;
	border: solid 1px #b4b4b4;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
}
/* dropdown */
#nav li:hover > ul {
	display: block;
}
#nav ul li {
	float: none;
	margin: 0;
	padding: 0;
}
#nav ul a {
	font-weight: normal;
	text-shadow: 0 1px 1px rgba(255, 255, 255, .9);
}
/* level 3+ list */
#nav ul ul {
	left: 181px;
	top: -3px;
}
/* rounded corners for first and last child */
#nav ul li:first-child > a {
	-webkit-border-top-left-radius: 9px;
	-moz-border-radius-topleft: 9px;
	-webkit-border-top-right-radius: 9px;
	-moz-border-radius-topright: 9px;
}
#nav ul li:last-child > a {
	-webkit-border-bottom-left-radius: 9px;
	-moz-border-radius-bottomleft: 9px;
	-webkit-border-bottom-right-radius: 9px;
	-moz-border-radius-bottomright: 9px;
}
/* clearfix */
#nav:after {
	content: ".";
	display: block;
	clear: both;
	visibility: hidden;
	line-height: 0;
	height: 0;
}
#nav {
	display: inline-block;
}
html[xmlns] #nav {
	display: block;
}

* html #nav {
	height: 1%;
}

/* For changing "ToDo" in the Nav bar. See todoFlash.js. */
#nav li > a.flashOn {
	background-color: black;
    color: lightgreen;
}

#spinnerParent {
	position: relative;
	display: inline-block;
	width: 43.4px;
	height: 36px;
	margin: 0;
	padding: 0;
}
#spinner {
	position: absolute;
	display: inline-block;
	margin: 0;
	padding: 0;
	top: 0;
	left: 0;
	top: -4px;
	cursor: pointer;
}

#details tr {
	margin: 0;
	padding: 0;
}
#details td {
	margin: 0;
	font-size: 1.0em;
	padding: 0;
}

#details caption {
	font-size: 1.2em;
	font-weight: bold;
}
.yebal, .openingbal {
	font-weight: bold;
	background-color: #CCCCCC;
}
.yebalneg {
	font-weight: bold;
	background-color: #FFCCCC;
}
.monthlybal {
	background-color: #EEEEEE;
}
.monthlybalneg {
	/*font-weight: bold;*/
	background-color: #FFAAAA;
}

.unsupported {
	color: #aaaaaa;
}

/* Scroll support */

/* Transition to new names for scroll support NOTE some classes are now ids */
#headingAboveContents { /* Replaces #searchWhat */
	margin-top: 10px;
	font-size: 1.2em;
}

#scrollAdjustedHeight, #scrollAdjustedHeightDirPicker {
	display: flex;
	width: 100%;
	height: 60%;
	overflow: hidden;
}

#scrollContentsList {
	width: 22.5%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	font-family: helvetica, arial, sans-serif;
	font-size: 1.2em;
	line-height: 1.3em;
	margin-top: 20px;
}

#scrollContentsList a {
	text-decoration: none;
}

#scrollContentsList li, #scrollContentsList ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

#scrollContentsList li {
	margin-bottom: 6px;
}

#scrollContentsList a:hover {
	color: blue;
	cursor: pointer;
}

#scrollTextRightOfContents {
	flex: auto;
	padding-left: 0; /* was 1em */
	overflow: auto;
	-moz-tab-size: 4;
	tab-size: 4;
}

#scrollText {
	float: left;
	width: 100%;
	-moz-tab-size: 4;
	tab-size: 4;
}

#scrollTextRightOfContents h1, #scrollTextRightOfContents h2, #scrollTextRightOfContents h3, #scrollTextRightOfContents h4 {
	display: inline;
}

#scrollContentsList .h1 {
	font-size: 1.3em;
}

#scrollContentsList .h2 {
	font-size: 1.1em;
}

#scrollContentsList .h3 {
	font-size: 1.0em;
	font-style: italic;
	font-variant: normal;
}


#scrollContentsList .h4 {
	font-size: .9em;
}

#scrollContentsList .h2Disabled {
	font-size: 1.1em;
	color: #889988;
}

#scrollContentsList .h2 a:before {
	font-size: 0.6em;
	content: "\00a0";
	padding-left: 0;
}

#scrollContentsList .h3 a:before {
	font-size: 0.6em;
	content: "\00a0\00a0";
	padding-left: 8px;
}

#scrollContentsList .h4 a:before {
	font-size: 0.4em;
	content: "\00a0\00a0\00a0";
	padding-left: 24px;
}


/* section marker */
/*
#scrollContentsList .h2 a:before {
	font-size: 0.6em;
	content: "\25B0  ";
	padding-left: 0;
	color: #667766;
}


#scrollContentsList .h3 a:before {
	font-size: 0.6em;
	content: "\25B0  ";
	padding-left: 8px;
	color: #889988;
}

#scrollContentsList .h4 a:before {
	font-size: 0.4em;
	content: "\25B0  ";
	padding-left: 24px;
	color: #889988;
}
*/

#details {
	height: 100%;
}

/* Circled letters, for table of contents display by intramine_viewer.pl. */
.circle_red {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #FAA;
	border: 1px solid #FAA;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}
  .circle_green {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #7E7;
	border: 1px solid #7E7;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}
  .circle_blue {
	display: inline-block;
	vertical-align: text-top;
	border-radius: 50%;
	width: 10px;
	height: 10px;
	margin: 0 4px 0 0;
	padding: 1px 1px 1px 1px;
	background: #CCF;
	border: 1px solid #CCF;
	color: #000;
	text-align: center;
	font: 9px Arial, sans-serif;
	/*font-size: 10px;*/
}


/* A bit of formatting for text. */
.Comment_Normal {color: #004221;}
.Comment_POD {color: #004221;}
.Directive {color: #000000;}
.Label {color: #000000;}
.Quote {color: #8A0808;}
.String {color: #8A0808;}
.Subroutine {color: #000000;}
.Variable_Scalar {color: #0101DF;}
.Variable_Array {color: #0101DF;}
.Variable_Hash {color: #0101DF;}
.Variable_Typeglob {color: #0101DF;}
/*.Whitespace {color: #000000;}*/
.Character {color: #000000;}
.Keyword {color: #A020F0;}
.Builtin_Function {color: #000000;}
.Builtin_Operator {color: #000000;}
.Operator {color: #000000;}
.Bareword {color: #000000;}
.Package {color: #000000;}
.Number {color: #000000;}
.Symbol {color: #000000;}
.CodeTerm {color: #000000;  font-weight: bold;}
.DATA {color: #000000;}

/* OLDER SCROLL SUPPORT, still valid but not for use with ace editor displays */
#searchresults, #cmdresults {
	height: 60%;
}
#jumpsandtext {
	height: 85%;
	font-family: monospace;
	font-size: 1.2em;
}

.jumplist {
	float: left;
	width: 23%;
	overflow: auto;
	height: 100%;
	padding: 4px;
}

.jumplist a {
	text-decoration: none;
	font-size: 1.1em;
	line-height: 1.2em;
}

.jumplist li, .jumplist ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

.jumplist li {
	margin-bottom: 6px;
}

.jumplist .h2 a:before {
	font-size: 1.2em;
	content: "\25B0";
}

.jumplist .h3 a:before {
	font-size: 1.2em;
	content: "\25B0\25B0";
}

.jumplist a:hover {
	color: blue;
}

.theTextWithJumpList {
	float: left;
	width: 75%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	padding-right: 0;
}

#theTextWithoutJumpList {
	float: left;
	width: 98%;
	overflow: auto;
	height: 100%;
	padding: 4px;
}

.theText {
	font-family: Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	font-size: 9pt;
	line-height: 12pt;
	float: none;
	width: 100%;
}

#searchWhat {
	margin-top: 10px;
	font-size: 1.2em;
}

.line_number {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em;
	display: inline-block;
}
a.embedded_image {
	text-decoration: none;
}

.notabene {
	color: Crimson;
	font-size: 0.9em;
}

.textSymbol {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.1em;
}

.textSymbolSmall {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.0em;
}

/* A "line break" for long URLs */
.noshow {
	display: inline-block;
	width: 0px;
}

/* Up down left right triangles for navigation. */
.arrow-left {
	display: inline-block;
	width: 0; 
	height: 0;
	margin-left: 16px;
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent; 
	border-right:16px solid #6aa436;
	position: relative;
	top: 10px;
}

.arrow-up {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
 	border-bottom: 16px solid #6aa436;
	position: relative;
	top: -14px;
	left: 8px;
}

.arrow-down {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
	border-top: 16px solid #6aa436;
	position: relative;
	top: 18px;
	left: -24px;
}

.arrow-right {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent;
	border-left: 16px solid #6aa436;
	position: relative;
	top: 10px;
	left: -16px;
}

.img-arrow-left {
	display: inline;
	margin-left: 16px;
	position: relative;
	top: 10px;
}

.img-arrow-up {
	display: inline;
	position: relative;
	top: -24px;
	left: 0;
}

.img-arrow-down {
	display: inline;
	position: relative;
	top: 40px;
	left: -68px;
}

.img-arrow-right {
	display: inline;
	position: relative;
	top: 10px;
	left: -64px;
}

#title-block {
	display: inline-block;
	max-height: 60px;
	overflow: hidden;
	text-align: right;
}


#viewEditTitle {
	margin-right: 12px;
	display: inline-block;
	font-size: 1.4em;
	font-weight: bold;
}

#viewEditDateSize {
	margin-right: 12px;
}

#title-blockTR {
	max-height: 60px;
	overflow: hidden;
}

#title-blockTD {
	max-height: 60px;
	overflow: hidden;
}

#button-block {
	display: inline-block;
	vertical-align: top;
	/*margin-top: 20px;*/
}

/* For the Status page main status tables. */
#tablePageServerStatus th {
	cursor: pointer;
}

#tableBackgroundServerStatus th {
	cursor: pointer;
}

.divAlignCenter {
	display: inline-block;
	vertical-align: middle;
}

#editor_error {
	display: inline-block;
	font-size: 0.8em;
}

/* For the "edit" pencil image, a bit of space on the left. */
.edit_img {
	display: inline-block;
	margin-left: 6px;
}

/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
#theTextWithoutJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.theTextWithJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.jumplist {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollText {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollTextRightOfContents {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollContentsList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
}
</style>
<style>
/* non_cm_test.css: formatting for non-CodeMirror displays presented by the Viewer service. */

#scrollTextRightOfContents {
	padding-right: 0;
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	top: 0; right: 0; bottom: 0;

	/* https://css-tricks.com/snippets/css/prevent-long-urls-from-breaking-out-of-container/*/
	
	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollText { /* Replaces #theTextWithoutJumpList */
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;

	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollTextRightOfContents img, #scrollText img{
	max-width: 100%;
}

/* TOC shrink/expand element */
#tocShrinkExpand {
	position: absolute;
	display: inline-block;
	cursor: pointer;
	margin-right: 5px;
	margin-bottom: 5px;
}

.marker-highlight {
	background-color: lightgreen
}

.scroll-hilite {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: green;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

.initial-hits-highlight {
	background-color: #ffcccc;
}

.initial-scroll-hl {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: #990000;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

div#indicator {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.75%;
    opacity: .5;
    width: 2px;
    height: 20px;
    background-color: #888;
    border: none;
    margin: 0;
    padding: 0;
	pointer-events: none;
}

div#indicatorPC {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.74%;
    /*opacity: .5;*/
    width: 9px;
    height: 20px;
    background-color: #ffdb58; /* #ffe958 or mustard, #ffdb58 */
    border: 1px solid gray; /*none;*/
    margin: 0;
    padding: 0;
	pointer-events: none;
}

/* Some special treatment for index.html files that hold a table of contents.
See intramine_fileviewer_cm.pl#GetPrettyText(). */
#specialScrollTextRightOfContents {
	padding-right: 0;
	position: absolute;
	top: 0; left: 2%; right: 0; bottom: 0;
	overflow: auto;
	/*background-image: url("Coffee-Paper-Texture4.jpg");*/
	-webkit-background-size: cover;
	-moz-background-size: cover;
	-o-background-size: cover;
}

#toc-line {
	font: normal 28px "Baskerville BT", serif;
}

#special-index-wrapper {
	padding-top: 20px;
	height: 100%;
	font: normal 24px "Baskerville BT", serif;
	/*background-color: #E8E3C5;*/
}

#special-index-wrapper th {
	text-align: center;
}

#special-index-wrapper td:not(:first-child) {
	padding-left: 80px;
}

#special-index-wrapper td:nth-child(1) {
	/*background-color: #E8E3C5;*/
	background: transparent;
}

#special-index-wrapper a {
	text-decoration: none;
}

#special-index-wrapper a:link {
	color: Black;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:visited {
	color: #333;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:hover {
	color: #333;
	border-bottom: 1px solid #333;
	background-color: #ECF6CE;
}

/* Glossary links, for glossary popups shown in standalone Gloss HTML files. */
.glossary:link {
	border-bottom: 1px dotted #666;
}

.glossary:link:hover {
	border-bottom: 1px dotted #666;
}

.glossary:link:visited {
	border-bottom: 1px dotted #666;
}

/* Second and subsequent glossary tooltips in Gloss HTML standalone files, suppress underline. */
.term-seen:link {
	border-bottom: 1px dotted #CCC;
}

.term-seen:hover {
	border-bottom: 1px dotted #666;
}

.term-seen:visited {
	border-bottom: 1px dotted #CCC;
}

/* Table of Contents highlight for current item. */
.tocitup {
	background-color: lightgreen;
}

/* Gloss standalone HTML, alignment for "inlined" images. */
.valigntop {
	vertical-align: top;
}
and the entry name in a span with
.inlinespan {
	display:inline-block;
}

#bottomShim {
	margin: 0;
	height: 3px;
	}

/* For Gloss display of *!* wrapped code bits. */
code {
	background-color:#ECF6CE;
}

/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
	#scrollTextRightOfContents {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
	#scrollText {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
}

</style>
<style>
/* non_cm_tables.css: for non-CodeMirror table display by the Viewer service. */

table {
	tab-size: 4;
	white-space: pre-wrap;
}

table, tr, td {
	margin: 0;
	border: none;
	border-spacing: 0;
	padding: 0;
}

td {
	vertical-align: top;
	padding-left: 4px;
	/*overflow-wrap: break-word;*/
}

thead {
	overflow-wrap: break-word;
	word-wrap: normal;
	-ms-word-break: normal;
	word-break: normal;
}

/* vertical align middle */
td.vam {
	vertical-align: middle;
}

td:nth-child(1) {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em; /* enough for 99999 one hopes */
}

th {
	text-align: left;
}

/* Avoid copy of line numbers in the first column.
<td n='$lineNum'></td>
*/
td:first-child:after, th:first-child:after {
    content: attr(n);
}


h1, h2, h3, h4 {
	font-family: helvetica, arial, sans-serif;
	text-shadow: #9C9C9C 1px 1px 1px;
	color: #002000;
}

h1 {
	color: #305030;
	font-size: 2em;
	line-height: 2em;
	margin: 0;
	padding: 2px;
}

h3 {
	font-style: italic;
}

/* Unordered list items. */
.outdent-unordered {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.outdent-unordered-sub {
	margin: 0;
	padding: 0;
	text-indent: -1.3em;
	padding-left: 2.9em;
	}

.outdent-unordered-continued {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.outdent-unordered-sub-continued {
	margin: 0;
	padding: 0;
	padding-left: 2.9em;
	}

/* Ordered lists, with one or two digits in the main item or sub item, and their
continuation paragraphs. There are twelve possibilities.
Naming: "ol-1-2-c" = ordered list - one digit top level - two digits second - continuation
paragraph (ie not the first paragraph in the item).
"ol-2" = ordered list - two digits top level, no second level, first paragraph.
*/
.ol-1 {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.ol-1-c {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.ol-1-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 4.2em;
	}

.ol-1-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.2em;
	}

.ol-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 2.3em;
	}

.ol-2-c {
	margin: 0;
	padding: 0;
	padding-left: 2.3em;
	}

.ol-1-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.7em;
	padding-left: 4.6em;
	}

.ol-1-2-c {
	margin: 0;
	padding: 0;
	padding-left: 4.6em;
	}

.ol-2-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.6em;
	padding-left: 4.9em;
}

.ol-2-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.9em;
	}

.ol-2-2 {
	margin: 0;
	padding: 0;
	text-indent: -3.2em;
	padding-left: 5.6em;
}

.ol-2-2-c {
	margin: 0;
	padding: 0;
	padding-left: 5.6em;
	}


/* Data tables in text */
.bordered {
    border: solid #ccc 1px;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 1px 1px #ccc; 
    -moz-box-shadow: 0 1px 1px #ccc; 
    box-shadow: 0 1px 1px #ccc;
    margin-bottom: 4px;    
}

.bordered tr:hover {
    background: #fbf8e9;
    -o-transition: all 0.1s ease-in-out;
    -webkit-transition: all 0.1s ease-in-out;
    -moz-transition: all 0.1s ease-in-out;
    -ms-transition: all 0.1s ease-in-out;
    transition: all 0.1s ease-in-out;     
}    
    
.bordered td, .bordered th {
    border-left: 1px solid #ccc;
    border-top: 1px solid #ccc;
    padding-top: 2px;
    padding-bottom: 2px;
    text-align: left;    
}

.bordered th {
    background-color: #dce9f9;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#ebf3fc), to(#dce9f9));
    background-image: -webkit-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:    -moz-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:     -ms-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:      -o-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:         linear-gradient(top, #ebf3fc, #dce9f9);
    -webkit-box-shadow: 0 1px 0 rgba(255,255,255,.8) inset; 
    -moz-box-shadow:0 1px 0 rgba(255,255,255,.8) inset;  
    box-shadow: 0 1px 0 rgba(255,255,255,.8) inset;        
    border-top: none;
    text-shadow: 0 1px 0 rgba(255,255,255,.5); 
}

.bordered td:first-child, .bordered th:first-child {
    border-left: none;
    border-top: none;
    background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 4em;
}

.bordered th:first-child {
    -moz-border-radius: 6px 0 0 0;
    -webkit-border-radius: 6px 0 0 0;
    border-radius: 6px 0 0 0;
}

.bordered th:last-child {
    -moz-border-radius: 0 6px 0 0;
    -webkit-border-radius: 0 6px 0 0;
    border-radius: 0 6px 0 0;
}

.bordered th:only-child{
    -moz-border-radius: 6px 6px 0 0;
    -webkit-border-radius: 6px 6px 0 0;
    border-radius: 6px 6px 0 0;
}

.bordered tr:last-child td:first-child {
    -moz-border-radius: 0 0 0 6px;
    -webkit-border-radius: 0 0 0 6px;
    border-radius: 0 0 0 6px;
}

.bordered tr:last-child td:last-child {
    -moz-border-radius: 0 0 6px 0;
    -webkit-border-radius: 0 0 6px 0;
    border-radius: 0 0 6px 0;
}

.bordered td:not(:first-child), .bordered th:not(:first-child) {
	padding-left: 4px;
	padding-right: 4px;
}

.bordered td.centered_cell, .bordered th.centered_cell {
	text-align: center;
}

.bordered td.left_cell, .bordered th.left_cell {
	text-align: left;
}

.bordered td.right_cell, .bordered th.right_cell {
	text-align: right;
}

.shrunkrow {
	height: 3pt;
	}
	
.reallyshrunkrow {
	background: #888;
}

.reallyshrunkrow td {
	height: 1px;
	border: none;
	padding: 0;
	}

</style>
<style>
/* tooltip.css: for popup hints and images, see also tooltip.js. */

#hintbox{ /*CSS for pop up hint box */
position:absolute;
top: 0;
background-color: lightyellow;
width: 150px; /*Default width of hint.*/ 
padding: 3px;
border:1px solid black;
font:normal 11px Verdana;
line-height:18px;
z-index:100;
border-right: 3px solid black;
border-bottom: 3px solid black;
visibility: hidden;
}

.hintanchor{ /*CSS for link that shows hint onmouseover (no longer used)*/
font-weight: bold;
color: navy;
margin: 3px 8px;
}
.plainhintanchor { /* looks like ordinary text */
	text-decoration: none;
	font-family: arial, helvetica, sans-serif; font-size:100%;
	color: black;
}
.hintanchor:hover {
    border-top-style: hidden;
}
.plainhintanchor:hover {
    border-top-style: hidden;
}
.invisiblehintanchor:hover {
	border-top-style: hidden;
}
</style>
<style>
/* dragTOC.css: CSS for the panes-separator in the Viewer, allowing width of
Table of Contents to be changed by dragging. */

.panes-separator {
    width: 3px;
    background: #aaaaaa;
    cursor: col-resize;
    }

.dragCursor {
    cursor: col-resize;
    }

</style>
<style>
/* Custom CSS for lolight syntax highlighting of code blocks.
Used in IntraMine by gloss2html.pl to style CODE/ENDCODE blocks.
Some attempt has been made to coordinate the colors with
highlightjs default.min.css.
*/

pre {
    overflow: visible;
    word-wrap: anywhere;
    white-space: pre-wrap;
    padding-left: 0.5em;
	margin: 0;
	background: #f3f3f3;
  }

.ll-nam { /* words */
    color: black;
}
.ll-num { /* numbers */
    color: #800;
}
.ll-str { /* strings */
    color: #800;
}
.ll-rex { /* regular expressions */
    color: #ab5656;
}
.ll-pct { /* operators, punctation */
    color: #ab5656;
}
.ll-key { /* keywords */
    color: #444;
    font-weight: bold;
}
span.ll-com { /* comments */
    color: #050;
    font-style: normal;
}

</style>
</head>
<body>
<!-- added for touch scrolling, an indicator -->
<div id="indicator"></div>
<hr id="rule_above_editor" />
<div id='scrollAdjustedHeight'>
<div id='scrollContentsList'><li class='h2' im-text-ln='1'><a href='#top-of-document'>TOP</a></li>
<ul>
<li class='h1' im-text-ln='1'><a href='#Updating_CodeMirror'>Updating CodeMirror</a></li>
<li class='h2' im-text-ln='6'><a href='#A_small_iPad_problem'>A small iPad problem</a></li>
<li class='h2' im-text-ln='28'><a href='#How_to_update_IntraMines_copy_of_CodeMirror'>How to update IntraMine's copy of CodeMirror</a></li></ul></div><div id='scrollTextRightOfContents'><table><span id='top-of-document'></span><tr id='R1'><td n='1'></td><td><h1 id="Updating_CodeMirror">Updating CodeMirror</h1></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R3'><td n='3'></td><td></td></tr>
<tr id='R4'><td n='4'></td><td>IntraMine ships with a copy of CodeMirror (version 5.65.2), so it's not necessary to install it. The copy you have should be fine. However, if you want to update IntraMine's copy some day, read on. Otherwise, if you're installing stuff you can continue with <a href="./Installing universal ctags.html" target="_blank">"Installing universal ctags.txt"</a>.</td></tr>
<tr id='R5'><td n='5'></td><td></td></tr>
<tr id='R6'><td n='6'></td><td><h2 id="A_small_iPad_problem">A small iPad problem</h2></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R8'><td n='8'></td><td>[March 2022, alas the iPad is no longer supported at all. This is mainly because I can't find a free way to debug it.]</td></tr>
<tr id='R9'><td n='9'></td><td><span class='notabene'>NOTE</span> you will lose hit markers in the scroll area for source file views on an iPad if you update CodeMirror. If you don't use an iPad to get at IntraMine, then nothing should be lost.</td></tr>
<tr id='R10'><td n='10'></td><td></td></tr>
<tr id='R11'><td n='11'></td><td>If you do want to use an iPad, there is a hack that should get the scroll area markers back after updating CodeMirror. After following the install instructions below, look in Codemirror-master\addon\scroll\annotatescrollbar.js in your IntraMine folder, around line 93, for</td></tr>
<tr id='R12'><td n='12'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R13'><td n='13'></td><td>    var lastLine = cm.lastLine()</td></tr>
<tr id='R14'><td n='14'></td><td>    if (cm.display.barWidth) for (var i = 0, nextTop; i &#60; anns.length; i++) {</td></tr>
<tr id='R15'><td n='15'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R16'><td n='16'></td><td>If you spot that, then in between those two lines add five lines as shown below, ending up with:</td></tr>
<tr id='R17'><td n='17'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R18'><td n='18'></td><td>    var lastLine = cm.lastLine()</td></tr>
<tr id='R19'><td n='19'></td><td>	// HORRIBLE TEMPORARY HACK!</td></tr>
<tr id='R20'><td n='20'></td><td>	if (typeof window.ontouchstart !== 'undefined')</td></tr>
<tr id='R21'><td n='21'></td><td>		{</td></tr>
<tr id='R22'><td n='22'></td><td>		cm.display.barWidth = 17;</td></tr>
<tr id='R23'><td n='23'></td><td>		}</td></tr>
<tr id='R24'><td n='24'></td><td>    if (cm.display.barWidth) for (var i = 0, nextTop; i &#60; anns.length; i++) {</td></tr>
<tr id='R25'><td n='25'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R26'><td n='26'></td><td>I have enquired of the CodeMirror community for a better way of doing this, see <a href='https://discuss.codemirror.net/t/scrollbar-annotations-on-ipad/1963' target='_blank'>https://discuss.codemirror.net/t/scrollbar-annotations-on-ipad/1963</a>. But no one has posted a better way, alas.</td></tr>
<tr id='R27'><td n='27'></td><td></td></tr>
<tr id='R28'><td n='28'></td><td><h2 id="How_to_update_IntraMines_copy_of_CodeMirror">How to update IntraMine's copy of CodeMirror</h2></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R30'><td n='30'></td><td><p class="ol-1">1. Stop IntraMine if it's running.</p></td></tr>
<tr id='R31'><td n='31'></td><td><p class="ol-1">2. Head to <a href='https://github.com/codemirror/codemirror' target='_blank'>https://github.com/codemirror/codemirror</a> (or more simply download the latest zipped version using <a href='https://codemirror.net/codemirror.zip' target='_blank'>https://codemirror.net/codemirror.zip</a> and skip the next step).</p></td></tr>
<tr id='R32'><td n='32'></td><td><p class="ol-1">3. Under the white-on-green "Clone or download" dropdown, select "Download ZIP". (<span href='./C:/perlprogs/IntraMine/Documentation/images/2019-09-11 13_48_49-GitHub - codemirror_CodeMirror_ In-browser code editor.png' onmouseOver="showhint('<img src=&quot;data:image/png;base64,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&quot;  />', this, event, '500px', true);"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIHIwWU3GsAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI8SURBVDhPbZJrSNNhFMZ/q4lp5cwuSK6LZX5IbaWFKISSFtmFvoSXUSjS
tLKkSAoCgwqxLL+UUsYi+2CoqTmslqQtU4uUDCGFLLykGfMvpsuVmrjev040th8ceHk4z8M5hxeZ
7m+4tdZwaMNaVNOCndIsVB1lZFZlk7zOh0V22Tnj477HWoyKvtyTVG30xk9IClMJSvNL9J/eu9q+
NLtOVWZTYMxjvzGHyKILhN1OJ/haEgGJ0XhS0BC+9O9E2Md3VUi30hhI3kOjegWB9XkEWE1Yeiqx
DdZgq8imS7cX/VZfLm7fREaQL2ma9aSolxPExJ97Owet/v0Nj5HyMpBOHWQgJoS6Zj2GiXpscrUX
Y/VYwm4xoYuoBfNKIQpGhioSh0fXmOvLRchppMs6hjLjGf7+hMnZkKKrNIpW+V5zxvm0tN1N7+xa
2Wl8QN8NHf2pMfTnn8EyVjcTMPYG2yUtX2+mUN1QTIXF7JlzLl0dKKxzYSGaZaqoSHaEbiFms5rD
ft5om+7QMTvFh4dMno/lZ1YS0ov7DAyPqMxxCatShVWeygE5WdFaQvDv1/ySAwafMxmhoSk+AvOV
o0iGAqTezy59cbGLo+z9jth6UPQayJcDrK+YykykRcih0RoKxUrmZ3qk6qc0enniM+NwwtsifCy1
/Bg1MXX9BO3ubuwT8kJ3FN7iPxSW5tK9K5w0oSmnDc5oe8SRrjKsZ7XUKpVECGl+s5f/auQ1/vvV
Dhw/wDYPNxLEUx7X6eEcgX8MB93QHHZJTQAAAABJRU5ErkJggg==
" width='17' height='12'  />2019-09-11 13_48_49-GitHub - codemirror_CodeMirror_ In-browser code editor.png<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIIFtS/BIcAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI1SURBVDhPlZFfSFNhGMafbdSESmLIwkFNN7DozxEnDJYlLPojDgPLmUGI
JVpJRRlTYUGYLhixmgktukk2oX8Ysgt1E8Vm0MqLabKLZOC02qFzcNuFbcuGp2/HMzC0i37w8PE9
vO/zvS8f/kUFhdyh+2j+8hZmZwe2CTbPscPYFfLBEJiDlDcaKyCzNOLgk1sofdUG3cgD6IfsqPLa
8HIukLManNzK0V7YuAWISLlIo4LG0Qrf7Kg4nEgV1vAhSjlKilW4XFyAaxo1TCVq3LlxGk7PQ3xn
RsF9dYNbHkfMZUa+SoGyqwbMPm0FExgHk07rfe7pE/yU/AtE4nWSUmrUhQaQWJkEl9GIFc4qLaZv
VoN91g72gxtsNEmFV1IOLanfQDYw321DIBsSeoHfbUbEOpsQJZOwH4fBJhJFkXj0jZHvEhA5eovK
lhal9rE+DFouwmNpQDjlWwtJToDruoTYFQPonhZEPP34Nh9WhqZmHE1CP4+k8+6ebiYi/TH4GMy9
erAmI+IzLqSz0wxb4S+Q49wBJc7qKJw6fhKl+7SyXKGfR9R+e0f9YlBMv34E1nwebO0R0HoKU3Ev
VjMhyxNgvHYoMrWCNiLbif3vxxAc6AXbUQu6/BAcxNZZWxBMvQP3i6wWcsFEvM0DBKQXqtHdb8F8
TTl6yD2PSLI9B2fIjywkSdCSB5/9z/HXCpsh36uAnpzrC7dIJKjsasaniBs//X04Kvj/TebbC3fn
oeF6JdRrVgbgD8K63nrr6C+tAAAAAElFTkSuQmCC
" width='17' height='12'  /></span>) and your download will start.</p></td></tr>
<tr id='R33'><td n='33'></td><td><p class="ol-1">4. The resulting zip will be called "Codemirror...something.zip". Unzip it to a folder.</p></td></tr>
<tr id='R34'><td n='34'></td><td><p class="ol-1">5. Take a look inside. If you see directories named "addon", "bin", etc then you want the entire unzipped folder. If you just see a single folder, take a look inside that one and you should see "addon", "bin" etc - that single folder is the one you want.</p></td></tr>
<tr id='R35'><td n='35'></td><td><p class="ol-1-1">5.1 Rename your wanted folder to "CodeMirror-master".</p></td></tr>
<tr id='R36'><td n='36'></td><td><p class="ol-1">6. Look in your IntraMine folder at the top and you will find a same-named "CodeMirror-master" subfolder. Copy that somewhere outside of your IntraMine folder so you can revert if things don't go well. Then delete IntraMine's "CodeMirror-master" folder and copy your new "CodeMirror-master" subfolder into your IntraMine folder.</p></td></tr>
<tr id='R37'><td n='37'></td><td><p class="ol-1">7. To verify you have the right folder, look inside CodeMirror-master and you should see something very much like this: <span href='./C:/perlprogs/IntraMine/Documentation/images/2019-09-11 13_51_31-C__perlprogs_mine_CodeMirror-master.png' onmouseOver="showhint('<img src=&quot;data:image/png;base64,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&quot;  />', this, event, '500px', true);"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIHIwWU3GsAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI8SURBVDhPbZJrSNNhFMZ/q4lp5cwuSK6LZX5IbaWFKISSFtmFvoSXUSjS
tLKkSAoCgwqxLL+UUsYi+2CoqTmslqQtU4uUDCGFLLykGfMvpsuVmrjev040th8ceHk4z8M5hxeZ
7m+4tdZwaMNaVNOCndIsVB1lZFZlk7zOh0V22Tnj477HWoyKvtyTVG30xk9IClMJSvNL9J/eu9q+
NLtOVWZTYMxjvzGHyKILhN1OJ/haEgGJ0XhS0BC+9O9E2Md3VUi30hhI3kOjegWB9XkEWE1Yeiqx
DdZgq8imS7cX/VZfLm7fREaQL2ma9aSolxPExJ97Owet/v0Nj5HyMpBOHWQgJoS6Zj2GiXpscrUX
Y/VYwm4xoYuoBfNKIQpGhioSh0fXmOvLRchppMs6hjLjGf7+hMnZkKKrNIpW+V5zxvm0tN1N7+xa
2Wl8QN8NHf2pMfTnn8EyVjcTMPYG2yUtX2+mUN1QTIXF7JlzLl0dKKxzYSGaZaqoSHaEbiFms5rD
ft5om+7QMTvFh4dMno/lZ1YS0ov7DAyPqMxxCatShVWeygE5WdFaQvDv1/ySAwafMxmhoSk+AvOV
o0iGAqTezy59cbGLo+z9jth6UPQayJcDrK+YykykRcih0RoKxUrmZ3qk6qc0enniM+NwwtsifCy1
/Bg1MXX9BO3ubuwT8kJ3FN7iPxSW5tK9K5w0oSmnDc5oe8SRrjKsZ7XUKpVECGl+s5f/auQ1/vvV
Dhw/wDYPNxLEUx7X6eEcgX8MB93QHHZJTQAAAABJRU5ErkJggg==
" width='17' height='12'  />2019-09-11 13_51_31-C__perlprogs_mine_CodeMirror-master.png<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIIFtS/BIcAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI1SURBVDhPlZFfSFNhGMafbdSESmLIwkFNN7DozxEnDJYlLPojDgPLmUGI
JVpJRRlTYUGYLhixmgktukk2oX8Ysgt1E8Vm0MqLabKLZOC02qFzcNuFbcuGp2/HMzC0i37w8PE9
vO/zvS8f/kUFhdyh+2j+8hZmZwe2CTbPscPYFfLBEJiDlDcaKyCzNOLgk1sofdUG3cgD6IfsqPLa
8HIukLManNzK0V7YuAWISLlIo4LG0Qrf7Kg4nEgV1vAhSjlKilW4XFyAaxo1TCVq3LlxGk7PQ3xn
RsF9dYNbHkfMZUa+SoGyqwbMPm0FExgHk07rfe7pE/yU/AtE4nWSUmrUhQaQWJkEl9GIFc4qLaZv
VoN91g72gxtsNEmFV1IOLanfQDYw321DIBsSeoHfbUbEOpsQJZOwH4fBJhJFkXj0jZHvEhA5eovK
lhal9rE+DFouwmNpQDjlWwtJToDruoTYFQPonhZEPP34Nh9WhqZmHE1CP4+k8+6ebiYi/TH4GMy9
erAmI+IzLqSz0wxb4S+Q49wBJc7qKJw6fhKl+7SyXKGfR9R+e0f9YlBMv34E1nwebO0R0HoKU3Ev
VjMhyxNgvHYoMrWCNiLbif3vxxAc6AXbUQu6/BAcxNZZWxBMvQP3i6wWcsFEvM0DBKQXqtHdb8F8
TTl6yD2PSLI9B2fIjywkSdCSB5/9z/HXCpsh36uAnpzrC7dIJKjsasaniBs//X04Kvj/TebbC3fn
oeF6JdRrVgbgD8K63nrr6C+tAAAAAElFTkSuQmCC
" width='17' height='12'  /></span>.</p></td></tr>
<tr id='R38'><td n='38'></td><td><p class="ol-1">8. Restart IntraMine, and check out some views of files that use CodeMirror. IntraMine uses CodeMirror for most views, including go, C, C++, and JavaScript (but not .txt or Perl). To bring up a view, click on any source file link under IntraMine's Files tab, or in the file hits after doing a Search.</p></td></tr>
<tr id='R39'><td n='39'></td><td><p class="ol-1">9. If you don't like the results, you can of course revert to the previous version  using the copy you made just above.</p></td></tr>
<tr id='R40'><td n='40'></td><td></td></tr>
<tr id='R41'><td n='41'></td><td>Next: <a href="./Installing universal ctags.html" target="_blank">Installing universal ctags.txt</a></td></tr>
<tr id='R42'><td n='42'></td><td></td></tr>
<tr id='R43'><td n='43'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R44'><td n='44'></td><td><a href="./contents.html" target="_blank">contents.txt</a></td></tr>
<tr id='R45'><td n='45'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr></table><p id='bottomShim'></p></div></div>
<script>
let thePath = 'C:/perlprogs/IntraMine/Documentation/Updating CodeMirror.txt';
let theEncodedPath = 'C:/perlprogs/IntraMine/Documentation/Updating CodeMirror.txt';
let usingCM = false;
let cmTextHolderName = 'scrollTextRightOfContents';
let specialTextHolderName = 'specialScrollTextRightOfContents';
let theMainPort = '99999';
let mainIP = '99999';
let ourServerPort = '99999';
let peeraddress = '99999';	// ip address of client
let weAreRemote = false;
let errorID = "editor_error";
let highlightItems = [];
let b64ToggleImage = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAYCAYAAAC8/X7cAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFLMAABSzATFtOXUAAAQZSURBVFhH1ZZfTFtVHMd/91/L7VY6/hVG4xgymWUIY5ENkq0jy4wGN3EjMmpI9mCcb0s0PvnnzfiyZCb6YqI+mJCUoRkmc7onXeYSBcxWZkfDMjYR6Ua7Au0dXLn33Hs8pz3BdC1QQpvUT/+l39/J70/POb/+ONggTX1SrQkwBEg/FBgAhcmborEX7CBKvxgAJ4L9+n0mZwXPPrPC/bpwQLTDb3I5NJtWkJi8aagv6rOI+KYxmJwVWRfg9krdWyv4n1s9zU7BSjZuiRlyAfFFfbZ6mpw0Bo3FLOuSVQF7vNK7jh384BHPS/KBbT1MzT3tJb3Q4Tkq01g0JpPXZM0Cmk+DSBx9Xu6Wzr3Q3sXvsrWBai4wa+5ZMmJQbzsIR9uO8WXPiudobJoDM2dk1UvsPgnFgiwNulrkF9t2dUKJ6EroGlbh4vUvITZleEDgYglxsxjY4agRrnUffBMkrighRdE0DN+9AiG/eoU0jJ7VGkbGAnb3WZ6yivj7mlZHU7PrMMicg1kAdFLA9ftDoEYxU3KDXMbBodpuEDkrU8iOkN2+FboKU6PKrWXEHZvo16aZaYW0Ahp6xX0WO3eprq20uq5kH3FoYZYkmDz+MR+vfMslRbydJJSakm4uw+T8Dbg3PB/SFHx8fADdYKYEKasbeqTjshN8dfsrtlTZaomyoS6bNzCYMLs4CZOj0UU1DN7xQf0SM/1XAGldZ4td3PmalhLBLpUztbBQtAhM+RcMZQa/Pe7TP6Ma19EBQni7eL60XjhbWW8DiU9eokJFN1WYvaPC3ITxqfMheodr8IpDlXvFV+0uPu38FSr0Hioz5Fj50Xc8xjCmxck7fZKz9n940VxpzjR34VHAvErO/rS2CJ1bKnmBK/BNwCT/Wb+hK3+ZZ0hH+kSgYiRg3ty2kx9R58yurVW8lUuohYepA4RGkaJG4MTtAfQt1VJ+78ZT4l6xmLtcvV+oFuXC2gqkYgiNGCEUxy8HLiA/k9NvbaPXsoMvwpe3Py80Wh2FUcRyDMOD343Ass51PvlvnDHDei84LKJ0sapFOGJzpi9ZiuC8jBK2igyxwhge3jR+0pB+8o4P0mavVX/inafBYtOlryr2CH2OmtRl4T+MvAxzzudSL19sCkPkttG/JOlv/Pk1aExOYdUCGJz7lPhR6TPCe2W7yVjBVtMC4ve0svFvYC6pbI6G16C0+GlLdKUAsrnRCRPP3zU+Jp3mw6SSmfWGHRy8gN6fmzTOkNaFaAvLN6xNIhLzLZL8B1RKWjKT1bQW9KEv4jO4KzSMHtNWli8SbXIEKfEQfoXGZPKaZD1uBgf0H8jFPfz3r+iBoTIxhyDik/pWH+GOoE//kcnrsqF5mc7i+gLXvhjGY7wAOdsL6ot0mzHq+8l5f20A/gW9of8+fiHTAwAAAABJRU5ErkJggg==';
let selectedTocId = 'tocitup';
let doubleClickTime = 500;
let useLolight = true;
//let weAreStandalone = true;
</script>
<script type="text/javascript">
	// Call fn when ready.
	function ready(fn) {
	  if (document.readyState != 'loading'){
	    fn();
	  } else {
	    document.addEventListener('DOMContentLoaded', fn);
	  }
	}

	function getRandomInt(min, max) {
  		return Math.floor(Math.random() * (max - min + 1) + min);
		}
</script>
<script type="text/javascript">
/**
 * debounce.js: //debounce() is (ultimately) from http://underscorejs.org/#debounce.
 */

let JD = {};

JD.debounce = function(func, wait, immediate) {
	let timeout;
	return function() {
		let context = this, args = arguments;
		let later = function() {
			timeout = null;
			if (!immediate)
				{
				func.apply(context, args);
				}
		};
		let callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait || 200);
		if (callNow)
			{
			func.apply(context, args);
			}
	};
};

</script>
<script type="text/javascript">
// tooltip.js: show a "tooltip" with text or an image, the main call is showhint().
/**********************************************************************************************
 * Show Hint script- (c) Dynamic Drive (www.dynamicdrive.com) 
 * This notice MUST stay intact for legal use 
 * Visit http://www.dynamicdrive.com/ for this script and 100s more.
 **********************************************************************************************/
// (Significantly modified from the original 2018-19 and 2023 for use with IntraMine.)
// IntraMine use, see eg showhint() calls in
// intramine_linker.pl#GetImageFileRep(), intramine_boilerplate.pl#ThePage().

// Where to place the hint, relative to cursor position.
const DIRECTION_BELOW = 0;
const DIRECTION_ABOVE = 1;
const DIRECTION_RIGHT = 2;
const DIRECTION_LEFT = 3;

let anchorClassName = "showHintAnchorClass"; 	// applied while mouse over element
let hitAnchorClassName = "invisiblehintanchor"; // applied if not present in element, permanently
let overAnchorTimer = null;
let shMainPort = 0; // See setMainPort() just below.
let shOurServerPort = (typeof ourServerPort !== 'undefined') ? ourServerPort: 0;
let shOnMobile = (typeof window.ontouchstart !== 'undefined') ? true : false;
let hintElement = {}; // The HTML element holding the hint
let hintParams = {};  // hint HTML, position, width, whether it's an image


// Set the main IntraMine port, 81 by default.
function setMainPort() {
	shMainPort = (typeof theMainPort !== 'undefined') ? theMainPort: 0;
	}

window.addEventListener("load", setMainPort);


function hasClass(el, className) {
	if (el === null || el.nodeName === "#TEXT" || el.nodeName === "#text")
		{
		return false;
		}
	if (el.classList)
		return el.classList.contains(className);
	else
		return(typeof el.className !== 'undefined' && !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)')));
}

function addClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.add(className);
		else if (!hasClass(el, className))
			el.className += " " + className;
		}
}

function removeClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.remove(className);
		else if (hasClass(el, className))
			{
			let reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
			el.className = el.className.replace(reg, ' ');
			}
		}
}

function isDescendant(parent, child) {
	var node = child.parentNode;
	while (node != null) {
		if (node == parent) {
			return true;
		}
		node = node.parentNode;
	}
	return false;
}
// Helper function to get an element's exact position.
function getPosition(el) {
	"use strict";
	let rect = el.getBoundingClientRect();
	let yPos = rect.top;
	let xPos = rect.left;
	let xScrollTOTAL = 0;
	let yScrollTOTAL = 0;

	while (el)
		{
		if (el.tagName === "BODY")
			{
			// deal with browser quirks with body/window/document and page scroll
			let xScroll = el.scrollLeft || document.documentElement.scrollLeft;
			let yScroll = el.scrollTop || document.documentElement.scrollTop;
			xScrollTOTAL += xScroll;
			yScrollTOTAL += yScroll;
			}
		else
			{
			// for all other non-BODY elements
			xScrollTOTAL += el.scrollLeft;
			yScrollTOTAL += el.scrollTop;
			}

		el = el.offsetParent;
		}
	return {
		x : xPos,
		y : yPos,
		sx : xScrollTOTAL,
		sy : yScrollTOTAL
	};
}


function positionAndShowHint() {
	"use strict";
	let hintContents = hintParams.hintContents;
	let x = hintParams.x;
	let y = hintParams.y;
	let tipwidth = hintParams.tipwidth;
	let isAnImage = hintParams.isAnImage;
	let gap = 10; // gap between cursor and tip
	let windowHeight = window.innerHeight - gap;
	let windowWidth = window.innerWidth - gap;
	let hintWidth = 450;
	let hintHeight = hintElement.offsetHeight;
	if (isAnImage)
		{
		hintWidth = hintParams.theImage.width;
		hintHeight = hintParams.theImage.height;
		}
	else
		{
		if (tipwidth !== "")
			{
			hintWidth = parseInt(tipwidth, 10);
			}
		}

	// Calculate tip all four ways, pick the way that produces least shrinkage.
	// Preference order below, above, right, left.
	let ds = bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight);
	let bestDirection = ds.bestDirection;
	let scaleFactor = ds.scaleFactor;
	
	// For now, just scale images. Text tips are usually small enough.
	if (isAnImage)
		{
		if (scaleFactor < 1.0)
			{
			let finalScaleFactor = scaleFactor * 0.95; //temp[bestDirection] * 0.95;
			hintWidth = Math.floor(hintWidth * finalScaleFactor);
			hintHeight = Math.floor(hintHeight * finalScaleFactor);
			}
		}

	// Position tip (and scale if image).
	// Try to keep tip close to mouse x,y position.
	let tl = tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap);
	hintElement.style.top = tl.top;
	hintElement.style.left = tl.left;
	
	if (isAnImage)
		{
		hintContents =
			hintContents.slice(0, -1) + " width='" + hintWidth + "' height='" + hintHeight + "'>";
		}

	hintElement.innerHTML = hintContents;

	// Set width and height for an image. For text, set the desired width and let it flow.
	// hintElement.style.width = hintWidth + "px";
	if (isAnImage)
		{
		hintElement.style.height = hintHeight + "px";
		hintElement.style.width = hintWidth + "px";
		}
	else
		{
		hintElement.style.height = '';
		}

	hintElement.style.visibility = "visible";
}

// Calculate tip all four ways, pick the way that produces least shrinkage.
// Preference order: below, above, right, left.
function bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight) {
	// Below:
	let heightAvailable = windowHeight - y;
	let widthAvailable = windowWidth;
	let belowScaleFactor = heightAvailable / hintHeight;
	if (belowScaleFactor > widthAvailable / hintWidth)
		{
		belowScaleFactor = widthAvailable / hintWidth;
		}
	// Above:
	heightAvailable = y;
	let aboveScaleFactor = heightAvailable / hintHeight;
	if (aboveScaleFactor > widthAvailable / hintWidth)
		{
		aboveScaleFactor = widthAvailable / hintWidth;
		}
	// Right:
	heightAvailable = windowHeight;
	widthAvailable = windowWidth - x;
	let rightScaleFactor = heightAvailable / hintHeight;
	if (rightScaleFactor > widthAvailable / hintWidth)
		{
		rightScaleFactor = widthAvailable / hintWidth;
		}
	// Left:
	widthAvailable = x;
	let leftScaleFactor = heightAvailable / hintHeight;
	if (leftScaleFactor > widthAvailable / hintWidth)
		{
		leftScaleFactor = widthAvailable / hintWidth;
		}
	
	// Largest scaleFactor wins, preferring in order below, above, right, left where
	// there's a tie or values are above 1.0.
	let directionalScale = [];
	directionalScale[DIRECTION_BELOW] = (belowScaleFactor > 1.0) ? 1.0 : belowScaleFactor;
	directionalScale[DIRECTION_ABOVE] = (aboveScaleFactor > 1.0) ? 1.0 : aboveScaleFactor;
	directionalScale[DIRECTION_RIGHT] = (rightScaleFactor > 1.0) ? 1.0 : rightScaleFactor;
	directionalScale[DIRECTION_LEFT] = (leftScaleFactor > 1.0) ? 1.0 : leftScaleFactor;
	// bestDirection:
	// 0 == show hint below cursor x,y
	// 1 == show hint above
	// 2 == show hint to right of cursor
	// 3 == show hint to left of cursor
	let bestDirection = -1;
	let i = 0;
	for (i = directionalScale.length - 1; i >= 0; i -= 1)
		{
		if (directionalScale[i] >= 1.0)
			{
			bestDirection = i;
			}
		}
	
	if (bestDirection < 0) // all directionalScale[] are < 1.0
		{
		let curValue = directionalScale[0];
		bestDirection = 0;
		for (i = 1; i < directionalScale.length; i++)
			{
			if (directionalScale[i] > curValue)
				{
				curValue = directionalScale[i];
				bestDirection = i;
				}
			}
		}

	let ds = {};
	ds.bestDirection = bestDirection;
	ds.scaleFactor = directionalScale[bestDirection];
	return(ds);
}

// Position tip (and scale if image).
// Try to keep tip close to mouse x,y position.
function tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap) {
	let left = 0;
	let top = 0;
	
	if (bestDirection === DIRECTION_BELOW) // below
		{
		top = y + gap + "px";
		left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? "0" : left + "px";
		}
	else if (bestDirection === DIRECTION_ABOVE) // above
		{
		if (y - hintHeight - gap >= 0)
			{
			top = y - hintHeight - gap + "px";
			}
		else
			{
			top = "0";
			}
		let left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? "0" : left + "px";
		}
	else if (bestDirection === DIRECTION_RIGHT) // right
		{
		left = x + gap + "px";
		let top =
			(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight - gap;
		top = (top < 0) ? "0" : top + "px";
		}
	else
		// if (bestDirection === DIRECTION_LEFT) // left
		{
		if (x - hintWidth - gap >= 0)
			{
			left = x - hintWidth - gap + "px";
			}
		else
			{
			left = "0";
			}
		let top =
			(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight - gap;
		top = (top < 0) ? "0" : top + "px";
		}

	let topLeft = {};
	topLeft.top = top;
	topLeft.left = left;

	return(topLeft);
}

function showhint(hintContents, obj, e, tipwidth, isAnImage) {
	"use strict";
	
	setTimeout(function() {
	showWithFreshPort(hintContents, obj, e, tipwidth, isAnImage);
	}, 100);
}

// Special handling for some images: if hintContents looks like
//<img src="http://192.168.1.132:81/Viewer/imagefile.png">
// then we take what's in the "81" position as IntraMine's Main port, and what's in
// the "Viewer" spot as a Short name. Then call back to the Main port requesting a free
// port for the Short name, and replace the "81" in hintContents with the free port number.
// Also strip out the Short name, it was needed only to tell Main which server we wanted.
// For other img src values, just pass them along to showhinAfterDelay unchanged.
// (The fancy footwork with the port is an attempt to get the port number of a service that is
// running and not under maintenance. This allows showhint to show the image if there are two
// or more instances of a service running, even if one is doing maintenance.)
async function showWithFreshPort(hintContents, obj, e, tipwidth, isAnImage) {
	let hintShown = false;
	let image_url = "";

	if (isAnImage)
		{
		image_url = srcURL(hintContents);

		if (image_url !== "")
			{
			// Match eg http://192.168.1.132:81/Viewer/...
			let urlMatch = /^http\:\/\/([0-9\.]+)\:(\d+)\/([A-Za-z_]+)\/(.+?)$/.exec(image_url);
			if (urlMatch !== null)
				{
				let ip = urlMatch[1];
				let port = urlMatch[2];
				let shortName = urlMatch[3];
				let path = urlMatch[4];
				
				if (port === shMainPort) // Request good port number from shMainPort
					{
					hintShown = true; // Give up if we can't show it here.
					// However, if we're on an iPad (shOnMobile), try to use our current server's
					// port rather than asking Main to supply a fresh one - Apple really doesn't
					// like any hanky panky with the port number.
					if (shOnMobile && port === shMainPort && shOurServerPort !== 0)
						{
						let rePort = new RegExp(port);
						hintContents = hintContents.replace(rePort, shOurServerPort);
						let reName = new RegExp(shortName + "\/");
						hintContents = hintContents.replace(reName, "");
						showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
						}
					else
						{
						try {
							let theAction = 'http://' + ip + ':' + port + '/' +
							shortName + '/?req=portNumber';

							const response = await fetch(theAction);
							if (response.ok)
								{
								let resp = await response.text(); 

								if (!isNaN(resp))
									{
									// Replace port with resp in hintContents. And remove
									// server short name.
									let rePort = new RegExp(port);
									hintContents = hintContents.replace(rePort, resp);
									let reName = new RegExp(shortName + "\/");
									hintContents = hintContents.replace(reName, "");
									showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
									}
								}
							}
						catch(error) {
							console.log('Connection error in showWithFreshPort!');
							}
						}
					}
				}
			}
		}
	
	if (!hintShown)
		{
		showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage);
		}
	}

function showhintAfterDelay(hintContents, obj, e, tipwidth, isAnImage) {
	"use strict";
	
	if (overAnchorTimer !== null)
		{
		window.clearTimeout(overAnchorTimer);
		overAnchorTimer = null;
		}

	if (document.getElementById("hintbox") !== null)
		{
		hintElement = document.getElementById("hintbox");
		hintElement.innerHTML = hintContents;

		if (!hasClass(obj, hitAnchorClassName))
			{
			addClass(obj, hitAnchorClassName);
			}
		addClass(obj, anchorClassName);

		// Check if mouse is still over element (which must have
		// class hintanchor or plainhintanchor)
		let stillOver = mouseStillOverTipOwner(obj);

		if (!stillOver)
			{
			hintElement.style.visibility = "hidden";
			hintElement.style.left = "-500px";
			removeClass(obj, anchorClassName);
			return;
			}

		hintElement.style.left = "-500px";
		hintElement.style.top = "-500px";
		if (tipwidth === "")
			{
			tipwidth = "300px";
			}
		hintElement.widthobj = hintElement.style;
		if (hintElement.innerHTML.indexOf('<img') == 0)
			{
			hintElement.style.backgroundColor = 'lightyellow';
			hintElement.style.border = 'thin dotted black';
			}
		hintElement.style.width = tipwidth;
		if (!isAnImage)
			{
			// Reset height to 'auto'.
			hintElement.style.height = '';
			}

		hintParams.hintContents = hintContents;
		hintParams.x = e.clientX;
		hintParams.y = e.clientY;
		hintParams.tipwidth = tipwidth;
		hintParams.isAnImage = isAnImage;
		
		// Note we re-get the image_url since it might have changed.
		let image_url = srcURL(hintContents);
		if (image_url !== "")
			{
			let my_image = new Image();
			my_image.onload = function() {
				positionAndShowHint();
			};
			my_image.src = image_url;
			hintParams.theImage = my_image;
			}
		else
			{
			positionAndShowHint();
			}

		obj.onmouseout = hidetip;

		if (typeof window.ontouchstart === 'undefined')
			{
			overAnchorTimer = window.setTimeout(function() {
				hideTipIfMouseHasLeft(obj);
			}, 1000);
			}
		}
}

// If see src="something", return something, else "".
// The something should be in single or double quotes of some sort.
function srcURL(hintContents) {
	let image_url = "";
	let arrayMatch = null;

	if ((arrayMatch = /src='([^']+?)'/.exec(hintContents)) ||
		(arrayMatch = /src="([^"]+?)"/.exec(hintContents)) ||
		(arrayMatch = /src=\&quot\;(.+?)\&quot\;/.exec(hintContents)) ||
		(arrayMatch = /src=\&apos\;(.+?)\&apos\;/.exec(hintContents)) )
		{
		image_url = arrayMatch[1];
		}

	return(image_url);
}

function hideTipIfMouseHasLeft(obj) {
	if (mouseStillOverTipOwner(obj))
		{
		overAnchorTimer = window.setTimeout(function() {
			hideTipIfMouseHasLeft(obj);
		}, 1000);
		}
	else
		{
		hidetip();
		removeClass(obj, anchorClassName);
		}
}

function mouseStillOverTipOwner(obj) {
	let stillOver = false;

	let anks = document.getElementsByClassName(anchorClassName);
	if (anks.length > 0)
		{
		let el = anks[0];
		let c = window.getComputedStyle(el).getPropertyValue('border-top-style');
		stillOver = (c === 'hidden') ? true : false;
		}
	return (stillOver);
}

function hidetip(e) {
	hintElement.style.visibility = "hidden";
	hintElement.style.left = "-500px";
	let anks = document.getElementsByClassName(anchorClassName);
	if (anks.length > 0)
		{
		for (i = anks.length - 1; i >= 0; --i)
			{
			removeClass(anks[i], anchorClassName);
			}
		}
}

function touchhidetip(e) {
	hintElement.style.visibility = "hidden";
	hintElement.style.left = "-500px";
}

function createhintbox() {
	let divblock = document.createElement("div");
	divblock.setAttribute("id", "hintbox");
	document.body.appendChild(divblock);

	hintElement = document.getElementById("hintbox");
	hintElement.style.visibility = "hidden";
	hintElement.style.left = "-500px";
	
	if (shOnMobile)
		{
		hintElement.addEventListener("touchstart", function(e) {touchhidetip();});
		}
}

// For remote iPad "debugging" since remotedebug_ios_webkit_adapter has stopped working.
// For Viewer, errorID element is up near the top of the window.
// (iPad has been abandoned, too hard to debug.)
function writeMessageToWindow(str) {
	let errorElem = document.getElementById(errorID);
	if (errorElem !== null)
		{
		errorElem.innerHTML = "<p>" + str + "</p>";
		}
}

if (window.addEventListener)
	window.addEventListener("load", createhintbox, false);
else if (window.attachEvent)
	window.attachEvent("onload", createhintbox);
else if (document.getElementById)
	window.onload = createhintbox;

</script>
<script type="text/javascript">

// Whitespace (or punctuation) checker. Copied from somewhere, and it works.
function isW(s) {
	return /[ \t\uFFE5\^\+=`~<>{}\[\]|\u3000-\u303F!-#%-\x2A,-/:;\x3F@\x5B-\x5D\x7B}\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/.test(s);
	
	
// return /[ \f\n\r\t\v\u00A0\u2028\u2029]/.test(s);
}

</script>
<script type="text/javascript">
/*!***************************************************
* mark.js v9.0.0
* https://markjs.io/
* Copyright (c) 20142018, Julian Khnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Mark=t()}(this,function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var i=
/* */
function(){function e(n){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5e3;t(this,e),this.ctx=n,this.iframes=r,this.exclude=o,this.iframesTimeout=i}return r(e,[{key:"getContexts",value:function(){var e=[];return(void 0!==this.ctx&&this.ctx?NodeList.prototype.isPrototypeOf(this.ctx)?Array.prototype.slice.call(this.ctx):Array.isArray(this.ctx)?this.ctx:"string"==typeof this.ctx?Array.prototype.slice.call(document.querySelectorAll(this.ctx)):[this.ctx]:[]).forEach(function(t){var n=e.filter(function(e){return e.contains(t)}).length>0;-1!==e.indexOf(t)||n||e.push(t)}),e}},{key:"getIframeContents",value:function(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};try{var o=e.contentWindow;if(n=o.document,!o||!n)throw new Error("iframe inaccessible")}catch(e){r()}n&&t(n)}},{key:"isIframeBlank",value:function(e){var t="about:blank",n=e.getAttribute("src").trim();return e.contentWindow.location.href===t&&n!==t&&n}},{key:"observeIframeLoad",value:function(e,t,n){var r=this,o=!1,i=null,a=function a(){if(!o){o=!0,clearTimeout(i);try{r.isIframeBlank(e)||(e.removeEventListener("load",a),r.getIframeContents(e,t,n))}catch(e){n()}}};e.addEventListener("load",a),i=setTimeout(a,this.iframesTimeout)}},{key:"onIframeReady",value:function(e,t,n){try{"complete"===e.contentWindow.document.readyState?this.isIframeBlank(e)?this.observeIframeLoad(e,t,n):this.getIframeContents(e,t,n):this.observeIframeLoad(e,t,n)}catch(e){n()}}},{key:"waitForIframes",value:function(e,t){var n=this,r=0;this.forEachIframe(e,function(){return!0},function(e){r++,n.waitForIframes(e.querySelector("html"),function(){--r||t()})},function(e){e||t()})}},{key:"forEachIframe",value:function(t,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},a=t.querySelectorAll("iframe"),s=a.length,c=0;a=Array.prototype.slice.call(a);var u=function(){--s<=0&&i(c)};s||u(),a.forEach(function(t){e.matches(t,o.exclude)?u():o.onIframeReady(t,function(e){n(t)&&(c++,r(e)),u()},u)})}},{key:"createIterator",value:function(e,t,n){return document.createNodeIterator(e,t,n,!1)}},{key:"createInstanceOnIframe",value:function(t){return new e(t.querySelector("html"),this.iframes)}},{key:"compareNodeIframe",value:function(e,t,n){if(e.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_PRECEDING){if(null===t)return!0;if(t.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING)return!0}return!1}},{key:"getIteratorNode",value:function(e){var t=e.previousNode();return{prevNode:t,node:null===t?e.nextNode():e.nextNode()&&e.nextNode()}}},{key:"checkIframeFilter",value:function(e,t,n,r){var o=!1,i=!1;return r.forEach(function(e,t){e.val===n&&(o=t,i=e.handled)}),this.compareNodeIframe(e,t,n)?(!1!==o||i?!1===o||i||(r[o].handled=!0):r.push({val:n,handled:!0}),!0):(!1===o&&r.push({val:n,handled:!1}),!1)}},{key:"handleOpenIframes",value:function(e,t,n,r){var o=this;e.forEach(function(e){e.handled||o.getIframeContents(e.val,function(e){o.createInstanceOnIframe(e).forEachNode(t,n,r)})})}},{key:"iterateThroughNodes",value:function(e,t,n,r,o){for(var i,a,s,c=this,u=this.createIterator(t,e,r),l=[],h=[];s=void 0,s=c.getIteratorNode(u),a=s.prevNode,i=s.node;)this.iframes&&this.forEachIframe(t,function(e){return c.checkIframeFilter(i,a,e,l)},function(t){c.createInstanceOnIframe(t).forEachNode(e,function(e){return h.push(e)},r)}),h.push(i);h.forEach(function(e){n(e)}),this.iframes&&this.handleOpenIframes(l,e,n,r),o()}},{key:"forEachNode",value:function(e,t,n){var r=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},i=this.getContexts(),a=i.length;a||o(),i.forEach(function(i){var s=function(){r.iterateThroughNodes(e,i,t,n,function(){--a<=0&&o()})};r.iframes?r.waitForIframes(i,s):s()})}}],[{key:"matches",value:function(e,t){var n="string"==typeof t?[t]:t,r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.oMatchesSelector||e.webkitMatchesSelector;if(r){var o=!1;return n.every(function(t){return!r.call(e,t)||(o=!0,!1)}),o}return!1}}]),e}(),a=
/* */
function(){function e(n){t(this,e),this.opt=o({},{diacritics:!0,synonyms:{},accuracy:"partially",caseSensitive:!1,ignoreJoiners:!1,ignorePunctuation:[],wildcards:"disabled"},n)}return r(e,[{key:"create",value:function(e){return"disabled"!==this.opt.wildcards&&(e=this.setupWildcardsRegExp(e)),e=this.escapeStr(e),Object.keys(this.opt.synonyms).length&&(e=this.createSynonymsRegExp(e)),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),this.opt.diacritics&&(e=this.createDiacriticsRegExp(e)),e=this.createMergedBlanksRegExp(e),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.createJoinersRegExp(e)),"disabled"!==this.opt.wildcards&&(e=this.createWildcardsRegExp(e)),e=this.createAccuracyRegExp(e),new RegExp(e,"gm".concat(this.opt.caseSensitive?"":"i"))}},{key:"sortByLength",value:function(e){return e.sort(function(e,t){return e.length===t.length?e>t?1:-1:t.length-e.length})}},{key:"escapeStr",value:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}},{key:"createSynonymsRegExp",value:function(e){var t=this,n=this.opt.synonyms,r=this.opt.caseSensitive?"":"i",o=this.opt.ignoreJoiners||this.opt.ignorePunctuation.length?"\0":"";for(var i in n)if(n.hasOwnProperty(i)){var a=Array.isArray(n[i])?n[i]:[n[i]];a.unshift(i),(a=this.sortByLength(a).map(function(e){return"disabled"!==t.opt.wildcards&&(e=t.setupWildcardsRegExp(e)),e=t.escapeStr(e)}).filter(function(e){return""!==e})).length>1&&(e=e.replace(new RegExp("(".concat(a.map(function(e){return t.escapeStr(e)}).join("|"),")"),"gm".concat(r)),o+"(".concat(a.map(function(e){return t.processSynonyms(e)}).join("|"),")")+o))}return e}},{key:"processSynonyms",value:function(e){return(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),e}},{key:"setupWildcardsRegExp",value:function(e){return(e=e.replace(/(?:\\)*\?/g,function(e){return"\\"===e.charAt(0)?"?":""})).replace(/(?:\\)*\*/g,function(e){return"\\"===e.charAt(0)?"*":""})}},{key:"createWildcardsRegExp",value:function(e){var t="withSpaces"===this.opt.wildcards;return e.replace(/\u0001/g,t?"[\\S\\s]?":"\\S?").replace(/\u0002/g,t?"[\\S\\s]*?":"\\S*")}},{key:"setupIgnoreJoinersRegExp",value:function(e){return e.replace(/[^(|)\\]/g,function(e,t,n){var r=n.charAt(t+1);return/[(|)\\]/.test(r)||""===r?e:e+"\0"})}},{key:"createJoinersRegExp",value:function(e){var t=[],n=this.opt.ignorePunctuation;return Array.isArray(n)&&n.length&&t.push(this.escapeStr(n.join(""))),this.opt.ignoreJoiners&&t.push("\\u00ad\\u200b\\u200c\\u200d"),t.length?e.split(/\u0000+/).join("[".concat(t.join(""),"]*")):e}},{key:"createDiacriticsRegExp",value:function(e){var t=this.opt.caseSensitive?"":"i",n=this.opt.caseSensitive?["a","A","c","C","d","D","e","E","i","I","l","L","n","N","o","O","r","R","s","S","t","T","u","U","y","Y","z","Z"]:["aA","cC","dD","eE","iI","lL","nN","oO","rR","sS","tT","uU","yY","zZ"],r=[];return e.split("").forEach(function(o){n.every(function(n){if(-1!==n.indexOf(o)){if(r.indexOf(n)>-1)return!1;e=e.replace(new RegExp("[".concat(n,"]"),"gm".concat(t)),"[".concat(n,"]")),r.push(n)}return!0})}),e}},{key:"createMergedBlanksRegExp",value:function(e){return e.replace(/[\s]+/gim,"[\\s]+")}},{key:"createAccuracyRegExp",value:function(e){var t=this,n=this.opt.accuracy,r="string"==typeof n?n:n.value,o="string"==typeof n?[]:n.limiters,i="";switch(o.forEach(function(e){i+="|".concat(t.escapeStr(e))}),r){case"partially":default:return"()(".concat(e,")");case"complementary":return i="\\s"+(i||this.escapeStr("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")),"()([^".concat(i,"]*").concat(e,"[^").concat(i,"]*)");case"exactly":return"(^|\\s".concat(i,")(").concat(e,")(?=$|\\s").concat(i,")")}}}]),e}(),s=
/* */
function(){function n(e){t(this,n),this.ctx=e,this.ie=!1;var r=window.navigator.userAgent;(r.indexOf("MSIE")>-1||r.indexOf("Trident")>-1)&&(this.ie=!0)}return r(n,[{key:"log",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"debug",r=this.opt.log;this.opt.debug&&"object"===e(r)&&"function"==typeof r[n]&&r[n]("mark.js: ".concat(t))}},{key:"getSeparatedKeywords",value:function(e){var t=this,n=[];return e.forEach(function(e){t.opt.separateWordSearch?e.split(" ").forEach(function(e){e.trim()&&-1===n.indexOf(e)&&n.push(e)}):e.trim()&&-1===n.indexOf(e)&&n.push(e)}),{keywords:n.sort(function(e,t){return t.length-e.length}),length:n.length}}},{key:"isNumeric",value:function(e){return Number(parseFloat(e))==e}},{key:"checkRanges",value:function(e){var t=this;if(!Array.isArray(e)||"[object Object]"!==Object.prototype.toString.call(e[0]))return this.log("markRanges() will only accept an array of objects"),this.opt.noMatch(e),[];var n=[],r=0;return e.sort(function(e,t){return e.start-t.start}).forEach(function(e){var o=t.callNoMatchOnInvalidRanges(e,r),i=o.start,a=o.end;o.valid&&(e.start=i,e.length=a-i,n.push(e),r=a)}),n}},{key:"callNoMatchOnInvalidRanges",value:function(e,t){var n,r,o=!1;return e&&void 0!==e.start?(r=(n=parseInt(e.start,10))+parseInt(e.length,10),this.isNumeric(e.start)&&this.isNumeric(e.length)&&r-t>0&&r-n>0?o=!0:(this.log("Ignoring invalid or overlapping range: "+"".concat(JSON.stringify(e))),this.opt.noMatch(e))):(this.log("Ignoring invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)),{start:n,end:r,valid:o}}},{key:"checkWhitespaceRanges",value:function(e,t,n){var r,o=!0,i=n.length,a=t-i,s=parseInt(e.start,10)-a;return(r=(s=s>i?i:s)+parseInt(e.length,10))>i&&(r=i,this.log("End range automatically set to the max value of ".concat(i))),s<0||r-s<0||s>i||r>i?(o=!1,this.log("Invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)):""===n.substring(s,r).replace(/\s+/g,"")&&(o=!1,this.log("Skipping whitespace only range: "+JSON.stringify(e)),this.opt.noMatch(e)),{start:s,end:r,valid:o}}},{key:"getTextNodes",value:function(e){var t=this,n="",r=[];this.iterator.forEachNode(NodeFilter.SHOW_TEXT,function(e){r.push({start:n.length,end:(n+=e.textContent).length,node:e})},function(e){return t.matchesExclude(e.parentNode)?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},function(){e({value:n,nodes:r})})}},{key:"matchesExclude",value:function(e){return i.matches(e,this.opt.exclude.concat(["script","style","title","head","html"]))}},{key:"wrapRangeInTextNode",value:function(e,t,n){var r=this.opt.element?this.opt.element:"mark",o=e.splitText(t),i=o.splitText(n-t),a=document.createElement(r);return a.setAttribute("data-markjs","true"),this.opt.className&&a.setAttribute("class",this.opt.className),a.textContent=o.textContent,o.parentNode.replaceChild(a,o),i}},{key:"wrapRangeInMappedTextNode",value:function(e,t,n,r,o){var i=this;e.nodes.every(function(a,s){var c=e.nodes[s+1];if(void 0===c||c.start>t){if(!r(a.node))return!1;var u=t-a.start,l=(n>a.end?a.end:n)-a.start,h=e.value.substr(0,a.start),f=e.value.substr(l+a.start);if(a.node=i.wrapRangeInTextNode(a.node,u,l),e.value=h+f,e.nodes.forEach(function(t,n){n>=s&&(e.nodes[n].start>0&&n!==s&&(e.nodes[n].start-=l),e.nodes[n].end-=l)}),n-=l,o(a.node.previousSibling,a.start),!(n>a.end))return!1;t=a.end}return!0})}},{key:"wrapGroups",value:function(e,t,n,r){return r((e=this.wrapRangeInTextNode(e,t,t+n)).previousSibling),e}},{key:"separateGroups",value:function(e,t,n,r,o){for(var i=t.length,a=1;a<i;a++){var s=e.textContent.indexOf(t[a]);t[a]&&s>-1&&r(t[a],e)&&(e=this.wrapGroups(e,s,t[a].length,o))}return e}},{key:"wrapMatches",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){t.nodes.forEach(function(t){var o;for(t=t.node;null!==(o=e.exec(t.textContent))&&""!==o[a];){if(i.opt.separateGroups)t=i.separateGroups(t,o,a,n,r);else{if(!n(o[a],t))continue;var s=o.index;if(0!==a)for(var c=1;c<a;c++)s+=o[c].length;t=i.wrapGroups(t,s,o[a].length,r)}e.lastIndex=0}}),o()})}},{key:"wrapMatchesAcrossElements",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){for(var s;null!==(s=e.exec(t.value))&&""!==s[a];){var c=s.index;if(0!==a)for(var u=1;u<a;u++)c+=s[u].length;var l=c+s[a].length;i.wrapRangeInMappedTextNode(t,c,l,function(e){return n(s[a],e)},function(t,n){e.lastIndex=n,r(t)})}o()})}},{key:"wrapRangeFromIndex",value:function(e,t,n,r){var o=this;this.getTextNodes(function(i){var a=i.value.length;e.forEach(function(e,r){var s=o.checkWhitespaceRanges(e,a,i.value),c=s.start,u=s.end;s.valid&&o.wrapRangeInMappedTextNode(i,c,u,function(n){return t(n,e,i.value.substring(c,u),r)},function(t){n(t,e)})}),r()})}},{key:"unwrapMatches",value:function(e){for(var t=e.parentNode,n=document.createDocumentFragment();e.firstChild;)n.appendChild(e.removeChild(e.firstChild));t.replaceChild(n,e),this.ie?this.normalizeTextNode(t):t.normalize()}},{key:"normalizeTextNode",value:function(e){if(e){if(3===e.nodeType)for(;e.nextSibling&&3===e.nextSibling.nodeType;)e.nodeValue+=e.nextSibling.nodeValue,e.parentNode.removeChild(e.nextSibling);else this.normalizeTextNode(e.firstChild);this.normalizeTextNode(e.nextSibling)}}},{key:"markRegExp",value:function(e,t){var n=this;this.opt=t,this.log('Searching with expression "'.concat(e,'"'));var r=0,o="wrapMatches";this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),this[o](e,this.opt.ignoreGroups,function(e,t){return n.opt.filter(t,e,r)},function(e){r++,n.opt.each(e)},function(){0===r&&n.opt.noMatch(e),n.opt.done(r)})}},{key:"mark",value:function(e,t){var n=this;this.opt=t;var r=0,o="wrapMatches",i=this.getSeparatedKeywords("string"==typeof e?[e]:e),s=i.keywords,c=i.length;this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),0===c?this.opt.done(r):function e(t){var i=new a(n.opt).create(t),u=0;n.log('Searching with expression "'.concat(i,'"')),n[o](i,1,function(e,o){return n.opt.filter(o,t,r,u)},function(e){u++,r++,n.opt.each(e)},function(){0===u&&n.opt.noMatch(t),s[c-1]===t?n.opt.done(r):e(s[s.indexOf(t)+1])})}(s[0])}},{key:"markRanges",value:function(e,t){var n=this;this.opt=t;var r=0,o=this.checkRanges(e);o&&o.length?(this.log("Starting to mark with the following ranges: "+JSON.stringify(o)),this.wrapRangeFromIndex(o,function(e,t,r,o){return n.opt.filter(e,t,r,o)},function(e,t){r++,n.opt.each(e,t)},function(){n.opt.done(r)})):this.opt.done(r)}},{key:"unmark",value:function(e){var t=this;this.opt=e;var n=this.opt.element?this.opt.element:"*";n+="[data-markjs]",this.opt.className&&(n+=".".concat(this.opt.className)),this.log('Removal selector "'.concat(n,'"')),this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT,function(e){t.unwrapMatches(e)},function(e){var r=i.matches(e,n),o=t.matchesExclude(e);return!r||o?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},this.opt.done)}},{key:"opt",set:function(e){this._opt=o({},{element:"",className:"",exclude:[],iframes:!1,iframesTimeout:5e3,separateWordSearch:!0,acrossElements:!1,ignoreGroups:0,each:function(){},noMatch:function(){},filter:function(){return!0},done:function(){},debug:!1,log:window.console},e)},get:function(){return this._opt}},{key:"iterator",get:function(){return new i(this.ctx,this.opt.iframes,this.opt.exclude,this.opt.iframesTimeout)}}]),n}();return function(e){var t=this,n=new s(e);return this.mark=function(e,r){return n.mark(e,r),t},this.markRegExp=function(e,r){return n.markRegExp(e,r),t},this.markRanges=function(e,r){return n.markRanges(e,r),t},this.unmark=function(e){return n.unmark(e),t},this}});

</script>
<script type="text/javascript">
// wordAtInsertionPt.js
// See https://stackoverflow.com/questions/2444430/how-to-get-a-word-under-cursor-using-javascript 
// soln by Drakes https://stackoverflow.com/users/1938889/drakes
// (Modified from the original.)
// In IntraMine, getFullWord() is called by viewerStart.js#expandSelectionToWordIfPossible(),
// the goal being to select a whole word with one click when in a non-Editable view of a file.

// Get the full word the cursor is over regardless of span breaks
function getFullWord(event) {
let i, begin, end, range, textNode, offset;

// Internet Explorer
if (document.body.createTextRange) {
   try {
	 range = document.body.createTextRange();
	 range.moveToPoint(event.clientX, event.clientY);
	 range.select();
	 range = getTextRangeBoundaryPosition(range, true);
  
	 textNode = range.node;
	 offset = range.offset;
   } catch(e) {
   return(document.createRange()); // Sigh, IE
   }
}

// Firefox, Safari
// REF: https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint
else if (document.caretPositionFromPoint) {
  range = document.caretPositionFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.offsetNode;
	  offset = range.offset;
	  }
  else
	  {
	  return(document.createRange());
	  }

  // Chrome
  // REF: https://developer.mozilla.org/en-US/docs/Web/API/document/caretRangeFromPoint
} else if (document.caretRangeFromPoint) {
  range = document.caretRangeFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.startContainer;
	  offset = range.startOffset;
	  }
  else
	  {
	  return(document.createRange());
	  }
}

// Only act on text nodes
if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
	return(document.createRange());
}

let data = textNode.textContent;

// Sometimes the offset can be at the 'length' of the data.
// It might be a bug with this 'experimental' feature - 
// compensate for this below
if (offset >= data.length) {
  offset = data.length - 1;
}

// Scan behind the current character until whitespace or punct is found, or beginning
i = begin = end = offset;
// Don't scan behind if we're at the end of a line and last char is not a word char.
let blockedAtLineEnd = ( offset === data.length - 1 && isW(data[offset]) );
if (!blockedAtLineEnd)
	{
	while ( previousCharIsAWordChar(data, i - 1) ) {
	  //while (i > 0 && !isW(data[i - 1])) {
	  i--;
	  }
	}
begin = i;

// Scan ahead of the current character until whitespace or punct is found, or end
// unless char at offset is not a word char.
i = offset;
let offsetIsWordChar = nextCharIsAWordChar(data, offset);
if (nextCharIsAWordChar(data, i))
	{
	while ( nextCharIsAWordChar(data, i + 1) ) {
	//while (i < data.length - 1 && !isW(data[i + 1])) {
	  i++;
	}
	}
end = i;

// This is our temporary word
let word = data.substring(begin, end + 1);

// If at a node boundary, cross over and see what 
// the next word is and check if this should be added to our temp word
if (end === data.length - 1 || begin === 0) {

  let nextNode = getNextNode(textNode);
  let prevNode = getPrevNode(textNode);

  // Get the next node text
  if (end == data.length - 1 && nextNode) {
  let nextText = nextNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = 0;
	while ( nextCharIsAWordChar(nextText, i) ) {
	  word += nextText[i++];
	}

  } else if (begin === 0 && prevNode) {
	// Get the previous node text
  let prevText = prevNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = prevText.length - 1;
	while ( previousCharIsAWordChar(prevText, i) ) {
	  word = prevText[i--] + word;
	}
  }
}

// Sometimes a bad last char is tacked on?
if (word.length)
	{
	word = remove_linebreaks(word);
//	if (isW(word[ word.length - 1]))
//		{
//		word = word.substring(0, word.length - 1);
//		}
	}

// Return the word, and its start and end offsets. Kill selection of '.' or other non-word
// if click happened past end of line and the line ends in non-word char such as '.'.
if (blockedAtLineEnd)
	{
	word = '';
	begin = end;
	}
else
	{
	if (offsetIsWordChar)
		{
		++end;
		}
	}

let obj = {
		theWord: word,
		theBegin: begin,
		theEnd: end
		};

return(obj);

//return word;
} // getFullWord()


// Helper functions

function remove_linebreaks(str ) { 
return str.replace( /[\r\n]+/gm, "" ); 
} 

// Looking in the forward direction, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the following char is not white or punctuation.
function nextCharIsAWordChar(theText, i) {
	let result = ( i < theText.length 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && (i+1) < theText.length && !isW(theText[i+1])))
		  );
	return(result);
	}

// Looking in reverse, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the previous char is not white or punctuation.
function previousCharIsAWordChar(theText, i) {
	let result = ( i >= 0 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && i > 0 && !isW(theText[i-1])))
		  );
	return(result);
	}


// Barrier nodes are BR, DIV, P, PRE, TD, TR, ... 
function isBarrierNode(node) {
return node ? /^(BR|DIV|P|PRE|TD|TR|TABLE)$/i.test(node.nodeName) : true;
}

// Try to find the next adjacent node
function getNextNode(node) {
let n = null;
// Does this node have a sibling?
if (node.nextSibling) {
n = node.nextSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.nextSibling) {
n = node.parentNode.nextSibling;
}
return isBarrierNode(n) ? null : n;
}

// Try to find the prev adjacent node
function getPrevNode(node) {
var n = null;

// Does this node have a sibling?
if (node.previousSibling) {
n = node.previousSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.previousSibling) {
n = node.parentNode.previousSibling;
}
return isBarrierNode(n) ? null : n;
}

// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getChildIndex(node) {
var i = 0;
while( (node = node.previousSibling) ) {
i++;
}
return i;
}

// All this code just to make this work with IE, OTL
// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getTextRangeBoundaryPosition(textRange, isStart) {
var workingRange = textRange.duplicate();
workingRange.collapse(isStart);
var containerElement = workingRange.parentElement();
var workingNode = document.createElement("span");
var comparison, workingComparisonType = isStart ?
"StartToStart" : "StartToEnd";

var boundaryPosition, boundaryNode;

// Move the working range through the container's children, starting at
// the end and working backwards, until the working range reaches or goes
// past the boundary we're interested in
do {
containerElement.insertBefore(workingNode, workingNode.previousSibling);
workingRange.moveToElementText(workingNode);
} while ( (comparison = workingRange.compareEndPoints(
workingComparisonType, textRange)) > 0 && workingNode.previousSibling);

// We've now reached or gone past the boundary of the text range we're
// interested in so have identified the node we want
boundaryNode = workingNode.nextSibling;
if (comparison == -1 && boundaryNode) {
// This must be a data node (text, comment, cdata) since we've overshot.
// The working range is collapsed at the start of the node containing
// the text range's boundary, so we move the end of the working range
// to the boundary point and measure the length of its text to get
// the boundary's offset within the node
workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

boundaryPosition = {
  node: boundaryNode,
  offset: workingRange.text.length
};
} else {
// We've hit the boundary exactly, so this must be an element
boundaryPosition = {
  node: containerElement,
  offset: getChildIndex(workingNode)
};
}

// Clean up
workingNode.parentNode.removeChild(workingNode);

return boundaryPosition;
}

</script>
<script type="text/javascript">
// LightRange.js - A simple and lightweight selection, range and caret information library in native JavaScript, with an additional selection save & restore system. - https://github.com/n457/LightRange.js
// Version 2.2.0
// MIT License - Copyright (c) 2015 Bertrand Vignaud-Lerouge / n457 - https://github.com/n457
var LightRange=function(){};
LightRange.prototype.getSelectionInfo=function(){var a={};if(window.getSelection){var b=window.getSelection(),e=document.body.scrollTop,f=document.body.scrollLeft;if(0<b.rangeCount){var d=b.getRangeAt(0).cloneRange(),c=d.getBoundingClientRect();0===c.height&&(c=d.getClientRects()[0]);c&&(a.width=c.width,a.height=c.height,a.xStart=c.left+f,a.yStart=c.top+e);a.text=b.toString();a.charStart=d.startOffset;a.charEnd=d.endOffset;d.collapse(!1);if(c=d.getClientRects()[0])a.xEnd=c.left+f,a.yEnd=c.top+e}}else if(document.selection)b=
document.selection.createRange(),e=document.documentElement.scrollTop,f=document.documentElement.scrollLeft,a.width=b.boundingWidth,a.height=b.boundingHeight,a.xStart=b.boundingLeft+f,a.yStart=b.boundingTop+e,a.text=b.text,b.collapse(!1),a.xEnd=b.boundingLeft+f,a.yEnd=b.boundingTop+e;else return null;a.text?(a.characters=a.text.replace(/\s/g,"").length,a.charactersAll=a.text.replace(/[\n\r]/g,"").length):(a.characters=0,a.charactersAll=0);return a};
LightRange.prototype.saveSelection=function(){if(window.getSelection){var a=window.getSelection();if(a.getRangeAt&&a.rangeCount)return a.getRangeAt(0)}else return document.selection&&document.selection.createRange?document.selection.createRange():null};LightRange.prototype.restoreSelection=function(a){if(a){if(window.getSelection){var b=window.getSelection();b.removeAllRanges();b.addRange(a)}else if(document.selection&&a.select)a.select();else return null;return a}};var lightrange=new LightRange;

</script>
<script type="text/javascript">
// commonEnglishWords.js: top one hundred or so English words.
// Wanted when deciding what to highlight, common words can take too long in a large file.
// See viewerStart.js for use.

let commonEnglishWords = new Object();


function isCommonEnglishWord(wrd) {
	return(wrd.toLowerCase() in commonEnglishWords);
	}

// This started out as roughly the 200 commonest words, but many have been commented out
// because they're of some interest to developers.
function loadCommonestEnglishWords() {
	commonEnglishWords['I'] = 1;
	commonEnglishWords['a'] = 1;
	commonEnglishWords['about'] = 1;
	commonEnglishWords['after'] = 1;
	commonEnglishWords['again'] = 1;
	commonEnglishWords['against'] = 1;
	commonEnglishWords['all'] = 1;
	commonEnglishWords['also'] = 1;
	commonEnglishWords['an'] = 1;
	commonEnglishWords['and'] = 1;
	commonEnglishWords['another'] = 1;
	commonEnglishWords['any'] = 1;
	commonEnglishWords['around'] = 1;
	commonEnglishWords['as'] = 1;
	commonEnglishWords['ask'] = 1;
	commonEnglishWords['at'] = 1;
	commonEnglishWords['back'] = 1;
	commonEnglishWords['be'] = 1;
	commonEnglishWords['because'] = 1;
	commonEnglishWords['become'] = 1;
	commonEnglishWords['before'] = 1;
	commonEnglishWords['begin'] = 1;
	commonEnglishWords['between'] = 1;
	commonEnglishWords['both'] = 1;
	commonEnglishWords['but'] = 1;
	commonEnglishWords['by'] = 1;
	commonEnglishWords['call'] = 1;
	commonEnglishWords['can'] = 1;
	commonEnglishWords['change'] = 1;
	commonEnglishWords['child'] = 1;
	commonEnglishWords['come'] = 1;
	commonEnglishWords['consider'] = 1;
	commonEnglishWords['could'] = 1;
	commonEnglishWords['course'] = 1;
	commonEnglishWords['day'] = 1;
	//commonEnglishWords['develop'] = 1;
	commonEnglishWords['do'] = 1;
	//commonEnglishWords['down'] = 1;
	commonEnglishWords['during'] = 1;
	commonEnglishWords['each'] = 1;
	commonEnglishWords['early'] = 1;
	commonEnglishWords['end'] = 1;
	commonEnglishWords['even'] = 1;
	commonEnglishWords['eye'] = 1;
	commonEnglishWords['face'] = 1;
	commonEnglishWords['fact'] = 1;
	commonEnglishWords['feel'] = 1;
	commonEnglishWords['few'] = 1;
	//commonEnglishWords['find'] = 1;
	//commonEnglishWords['first'] = 1;
	commonEnglishWords['follow'] = 1;
	commonEnglishWords['for'] = 1;
	//commonEnglishWords['form'] = 1;
	commonEnglishWords['from'] = 1;
	//commonEnglishWords['general'] = 1;
	commonEnglishWords['get'] = 1;
	commonEnglishWords['give'] = 1;
	commonEnglishWords['go'] = 1;
	commonEnglishWords['good'] = 1;
	commonEnglishWords['govern'] = 1;
	commonEnglishWords['great'] = 1;
	commonEnglishWords['group'] = 1;
	commonEnglishWords['hand'] = 1;
	commonEnglishWords['have'] = 1;
	commonEnglishWords['he'] = 1;
	//commonEnglishWords['head'] = 1;
	commonEnglishWords['help'] = 1;
	commonEnglishWords['her'] = 1;
	commonEnglishWords['here'] = 1;
	commonEnglishWords['high'] = 1;
	commonEnglishWords['him'] = 1;
	commonEnglishWords['his'] = 1;
	commonEnglishWords['hold'] = 1;
	commonEnglishWords['home'] = 1;
	commonEnglishWords['house'] = 1;
	commonEnglishWords['how'] = 1;
	commonEnglishWords['however'] = 1;
	commonEnglishWords['if'] = 1;
	commonEnglishWords['in'] = 1;
	//commonEnglishWords['increase'] = 1;
	//commonEnglishWords['interest'] = 1;
	//commonEnglishWords['into'] = 1;
	commonEnglishWords['it'] = 1;
	commonEnglishWords['its'] = 1;
	commonEnglishWords['just'] = 1;
	//commonEnglishWords['keep'] = 1;
	commonEnglishWords['know'] = 1;
	//commonEnglishWords['large'] = 1;
	//commonEnglishWords['last'] = 1;
	commonEnglishWords['late'] = 1;
	//commonEnglishWords['lead'] = 1;
	commonEnglishWords['leave'] = 1;
	commonEnglishWords['let'] = 1;
	commonEnglishWords['lets'] = 1;
	commonEnglishWords['life'] = 1;
	//commonEnglishWords['like'] = 1;
	//commonEnglishWords['line'] = 1;
	commonEnglishWords['little'] = 1;
	//commonEnglishWords['long'] = 1;
	commonEnglishWords['look'] = 1;
	//commonEnglishWords['make'] = 1;
	commonEnglishWords['man'] = 1;
	//commonEnglishWords['many'] = 1;
	commonEnglishWords['may'] = 1;
	commonEnglishWords['me'] = 1;
	//commonEnglishWords['mean'] = 1;
	commonEnglishWords['might'] = 1;
	commonEnglishWords['more'] = 1;
	commonEnglishWords['most'] = 1;
	//commonEnglishWords['move'] = 1;
	commonEnglishWords['much'] = 1;
	commonEnglishWords['must'] = 1;
	commonEnglishWords['my'] = 1;
	commonEnglishWords['nation'] = 1;
	commonEnglishWords['need'] = 1;
	commonEnglishWords['never'] = 1;
	//commonEnglishWords['new'] = 1;
	commonEnglishWords['no'] = 1;
	commonEnglishWords['not'] = 1;
	//commonEnglishWords['now'] = 1;
	//commonEnglishWords['number'] = 1;
	commonEnglishWords['of'] = 1;
	//commonEnglishWords['off'] = 1;
	commonEnglishWords['old'] = 1;
	commonEnglishWords['on'] = 1;
	//commonEnglishWords['one'] = 1;
	commonEnglishWords['only'] = 1;
	//commonEnglishWords['open'] = 1;
	commonEnglishWords['or'] = 1;
	commonEnglishWords['order'] = 1;
	commonEnglishWords['other'] = 1;
	//commonEnglishWords['our'] = 1;
	//commonEnglishWords['out'] = 1;
	commonEnglishWords['over'] = 1;
	//commonEnglishWords['own'] = 1;
	commonEnglishWords['part'] = 1;
	commonEnglishWords['people'] = 1;
	commonEnglishWords['person'] = 1;
	commonEnglishWords['place'] = 1;
	commonEnglishWords['plan'] = 1;
	commonEnglishWords['play'] = 1;
	//commonEnglishWords['point'] = 1;
	//commonEnglishWords['possible'] = 1;
	commonEnglishWords['present'] = 1;
	//commonEnglishWords['problem'] = 1;
	//commonEnglishWords['program'] = 1;
	//commonEnglishWords['public'] = 1;
	//commonEnglishWords['real'] = 1;
	//commonEnglishWords['right'] = 1;
	//commonEnglishWords['run'] = 1;
	//commonEnglishWords['same'] = 1;
	//commonEnglishWords['say'] = 1;
	commonEnglishWords['school'] = 1;
	commonEnglishWords['see'] = 1;
	commonEnglishWords['seem'] = 1;
	//commonEnglishWords['set'] = 1;
	commonEnglishWords['she'] = 1;
	//commonEnglishWords['should'] = 1;
	commonEnglishWords['show'] = 1;
	commonEnglishWords['since'] = 1;
	//commonEnglishWords['small'] = 1;
	commonEnglishWords['so'] = 1;
	//commonEnglishWords['some'] = 1;
	commonEnglishWords['stand'] = 1;
	//commonEnglishWords['state'] = 1;
	commonEnglishWords['still'] = 1;
	commonEnglishWords['such'] = 1;
	//commonEnglishWords['system'] = 1;
	commonEnglishWords['take'] = 1;
	//commonEnglishWords['tell'] = 1;
	commonEnglishWords['than'] = 1;
	commonEnglishWords['that'] = 1;
	commonEnglishWords['the'] = 1;
	commonEnglishWords['their'] = 1;
	commonEnglishWords['them'] = 1;
	commonEnglishWords['then'] = 1;
	commonEnglishWords['there'] = 1;
	commonEnglishWords['these'] = 1;
	commonEnglishWords['they'] = 1;
	commonEnglishWords['thing'] = 1;
	commonEnglishWords['think'] = 1;
	//commonEnglishWords['this'] = 1;
	commonEnglishWords['those'] = 1;
	commonEnglishWords['through'] = 1;
	//commonEnglishWords['time'] = 1;
	commonEnglishWords['to'] = 1;
	commonEnglishWords['too'] = 1;
	commonEnglishWords['turn'] = 1;
	commonEnglishWords['two'] = 1;
	commonEnglishWords['under'] = 1;
	commonEnglishWords['up'] = 1;
	commonEnglishWords['us'] = 1;
	//commonEnglishWords['use'] = 1;
	commonEnglishWords['very'] = 1;
	commonEnglishWords['want'] = 1;
	commonEnglishWords['way'] = 1;
	commonEnglishWords['we'] = 1;
	commonEnglishWords['well'] = 1;
	commonEnglishWords['what'] = 1;
	commonEnglishWords['when'] = 1;
	commonEnglishWords['where'] = 1;
	commonEnglishWords['which'] = 1;
	//commonEnglishWords['while'] = 1;
	commonEnglishWords['who'] = 1;
	commonEnglishWords['why'] = 1;
	commonEnglishWords['will'] = 1;
	commonEnglishWords['with'] = 1;
	commonEnglishWords['without'] = 1;
	commonEnglishWords['word'] = 1;
	commonEnglishWords['work'] = 1;
	commonEnglishWords['world'] = 1;
	commonEnglishWords['would'] = 1;
	//commonEnglishWords['write'] = 1;
	//commonEnglishWords['year'] = 1;
	commonEnglishWords['you'] = 1;
	commonEnglishWords['your'] = 1;
	}


</script>
<script type="text/javascript">
/* glossstubs.js: stubs for functions that gloss2html.pl doesn't need.
*/

function addAutoLinks() {
}

</script>
<script type="text/javascript">
// viewerStart.js: used for non-CodeMirror views in intramine_viewer.pl.
// Manage layout changes on resize, jump to an anchor
// Put highlight hits in text and on scrollbar.
// Show/hide any initial search hits provided in highlightitems.
// Preserve user selection when marking, by remembering selection range, removing selected
// text before marking, then restoring text and selection range after marking (patent not pending).

let markerMainElement = document.getElementById(cmTextHolderName);
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById("scrollText");
	}
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById(specialTextHolderName);
	}

let tocMainElement = document.getElementById("scrollContentsList");

let onMobile = false; // Set below, true if we have touch events.
if (typeof window.ontouchstart !== 'undefined')
	{
	onMobile = true;
	}

window.addEventListener("load", reJumpAndHighlight);
window.addEventListener("resize", JD.debounce(doResize, 100));

// Adjust some element heights so scrolling works properly.
function doResize() {
	restoreColumnWidths();

	let rule = document.getElementById("rule_above_editor");
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;

	let windowHeight = window.innerHeight;
	let elHeight = windowHeight - pos.y - ruleHeight - 8;
	let newHeightPC = (elHeight / windowHeight) * 100;
	let el = document.getElementById("scrollAdjustedHeight");
	el.style.height = newHeightPC + "%";

	if (tocMainElement !== null)
		{
		let tocMarginTop =
				parseInt(window.getComputedStyle(tocMainElement).getPropertyValue('margin-top'));
		let tocHeight = elHeight - tocMarginTop;
		if (onMobile)
			{
			tocHeight -= 20;
			}
		else
			{
			tocHeight -= 16;
			}
		let newTocHeightPC = (tocHeight / elHeight) * 100;
		tocMainElement.style.height = newTocHeightPC + "%";
		}

	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		highlightInitialItems();
		}

	if (!onMobile)
		{
		scrollIndicator();
		}
	else
		{
		scrollMobileIndicator(); // if mobile
		}
	
	reJump();
	
	updateToggleBigMoveLimit();

	repositionTocToggle();
}

// On "load", scroll any location.hash position into view, and put highlights on any
// words that formed part of a search that produced this file as a hit.
// See intramine_viewer.pl#InitialHighlightItems().
function reJumpAndHighlight() {
	addDragger && addDragger(); // dragTOC.js#addDragger()
	
	reJump();
	updateToggleBigMoveLimit();
	updateTogglePositions();
	highlightInitialItems();
	addAutoLinks();
}

// Set top of nav to zero, fixes an iPad scroll problem where nav goes off the top.
function resetTopNavPosition() {
	let nav = document.getElementById("nav"); // nope nav.style.top = 0;
	if (nav !== null)
		{
		nav.parentNode.scrollTop = 0;
		}
}

// Scroll element into view, based on ID named in location.hash.
function reJump() {
	let h = location.hash;
	if (h.length > 1)
		{
		// strip leading '#'
		h = h.replace(/^#/, '');
		
		if (isNaN(h))
			{
			let el = getElementForHash(h);
			
			if (el !== null)
				{
				el.scrollIntoView();
				resetTopNavPosition();
				if (!onMobile)
					{
					scrollIndicator();
					}
				else
					{
					scrollMobileIndicator(); // if mobile
					}
				}
			}
		else
			{
			reJumpToLineNumber(h);
			}
		}
}

// Progressively shorten 'h' word by word as necessary until an anchor id is found. If the
// remaining part of 'h' is a number, though, jump to that line. If an anchor id is found,
// return the corresponding element in the html text.
//
// This "shortening" approach is needed because 'h' may be too long, if it was part of a link
// in a text file where the link was not quoted: when making the link, we didn't know where
// the hash stopped, and just grabbed a hundred or so characters after the '#'.
// [See intramine_file_viewer_cm.pl#RememberTextOrImageFileMention().]
function getElementForHash(h) {
	let hCopy = h;
	hCopy = hCopy.replace(/ /g, '_');
	hCopy = hCopy.replace(/\%20/g, '_');
	hCopy = hCopy.replace(/\(\)$/, '');
	let el = document.getElementById(hCopy);
	
	while(el === null && h.length > 0)
		{
		let lastIndexOfSpace = h.lastIndexOf(" ");
		let lastIndexOfPct = h.lastIndexOf("%");
		let trimIndex = (lastIndexOfSpace > lastIndexOfPct) ? lastIndexOfSpace: lastIndexOfPct;
		if (trimIndex > 0)
			{
			h = h.substring(0, trimIndex);
			let hCopy = h;
			hCopy = hCopy.replace(/ /g, '_');
			hCopy = hCopy.replace(/\%20/g, '_');
			el = document.getElementById(hCopy);
			if (el === null)
				{
				if (!isNaN(hCopy))
					{
					reJumpToLineNumber(hCopy);
					break;
					}
				}
			}
		else
			{
			break;
			}
		}
	
	return(el);
}

// Scroll a line into view, based on line number. Synch the TOC too.
function reJumpToLineNumber(h) {
	let lineNum = parseInt(h, 10) - 1;
	if (lineNum <= 0)
		{
		lineNum = 0;
		}
	// Look for row number lineNum.
	let rows = markerMainElement.getElementsByTagName('tr');
	if (lineNum < rows.length)
		{
		let el = rows[lineNum];
		if (el !== null)
			{
			el.scrollIntoView();
			resetTopNavPosition();
			if (!onMobile)
				{
				scrollIndicator();
				}
			else
				{
				scrollMobileIndicator(); // if mobile
				}
			}

		// Restore Table of Contents scrolled position and highlight.
		restoreTocSelection(lineNum);
		}
}

// Adust the top of "id" (the main text holder) so scrolling will work properly etc.
function setTextViewPosition(rule_id, id) {
	let el = document.getElementById(id);
	if (el === null)
		{
		return;
		}
	let rule = document.getElementById(rule_id);
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;
	let yPos = pos.y + ruleHeight + 8;
	el.style.top = yPos + "px";
}

// Position the main text-holding element.
function positionViewItems() {
	let viewElement = document.getElementById(cmTextHolderName);
	if (viewElement !== null)
		{
		setTextViewPosition("rule_above_editor", cmTextHolderName);
		}
	else
		{
		viewElement = document.getElementById(specialTextHolderName);
		if (viewElement !== null)
			{
			setTextViewPosition("rule_above_editor", specialTextHolderName);
			}
		}
	doResize();
}

function finishStartup() {
	if (thePath.match(/\.txt$/))
		{
		// use lolight highlighting
		putInLolightElements();
		}

	hideIt("search-button");
	hideIt("small-tip");
	positionViewItems();
	loadCommonestEnglishWords(); // See commonEnglishWords.js.
	reJump();
}

// Code block highlighting with lolight, used
// by intramine_viewer.pl and gloss2html.pl.
function putInLolightElements() {
	document.querySelectorAll('td').forEach((el) => {
		putInLolightPreAndClass(el);
	});
}

function putInLolightPreAndClass(el) {
	let text = el.innerHTML;
	let codeMarkerPosition = text.indexOf('_STARTCB_');
	if (codeMarkerPosition == 0)
		{
		// FL = First/Last line of a code block. These are
		// shrunk down, emptied out, and colored gray.
		// Other rows starting with 'STARTCB_' are given
		// a class of 'lolight', and lolight JS styles
		// them up when the document is ready.
		if (text.indexOf('_STARTCB_FL_') == 0)
			{
			el.innerHTML = '';
			el.parentNode.classList.add("reallyshrunkrow");
			el.parentNode.firstElementChild.removeAttribute("n");
			el.style.backgroundColor = "#d0d0d0";
			}
		else
			{
			text = text.substring(9);
			el.innerHTML = '<pre class="lolight">' + text + '</pre>';
			el.style.backgroundColor = "#f3f3f3";
			}
		}
}

function createElementFromHTML(htmlString) {
	let div = document.createElement('div');
	div.innerHTML = htmlString.trim();

	// Change this to div.childNodes to support multiple top-level nodes
	return div.firstChild; // or div.firstElementChild?
}

function hideIt(id) {
	let el = document.getElementById(id);
	if (el !== null)
		{
		el.style.display = 'none';
		}
}

// Set up for highlighting text, with marks in scrollbar, keeping user's selection
// or expanding it to a word. mark.js (mark.min.js) does the actual marking.
// Marks are used for both the initial highlight items and a user text selection.
let markerInstance = null;
let mouseEvt;

let textMarkerClass = "marker-highlight";
let scrollMarkerClass = "scroll-hilite";
let initialHitsTextMarkersClass = "initial-hits-highlight";
let initialHitsScrollMarkerClass = "initial-scroll-hl";
let toggleHitsButtonID = "sihits";
let initialSearchHitsAreShowing = false;
let currentTextForHighlighting = '';
let justUpdateScrollbar = false;


// Selection management: on a single click, expand to a word. If selection is on one row,
// the <td> holding it is removed before marking, and then restored, complete with selection.
// Done because marking the current selection will collapse it to an insertion point.
let theSelection = {};
theSelection.selectionIsTooBig = false;
theSelection.isDoubleClick = false;
theSelection.doingDoubleClick = false;
theSelection.userDragged = false;
//For LightRange.min.js range representing text selection.
theSelection.ltRange = null;
theSelection.currentSelectionElem = null; // Hide/show this element when marking
theSelection.currentSelPreviousSibling = null; // The target for re-insertion of currentSelectionElem
theSelection.selChildren = []; // Contents of TD containing current selection
theSelection.startNodeIndexes = [];
theSelection.startNodeOffset = 0;
theSelection.endNodeIndexes = [];
theSelection.endNodeOffset = 0;
theSelection.topStartNode = null;
theSelection.topEndNode = null;

let linkClicked = false;
let hintboxClicked = false;
let cmCursorPos = {
	line : -1,
	ch : -1
};

// mark.js mark/unmark options, "done" is fired at the end of the mark/unmark. Normally
// one calls unmark, with unmarkOptions "done" calling the mark function.
let markerOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
	}
};
let markerOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(initialHitsTextMarkersClass, initialHitsScrollMarkerClass);
	}
};

let unmarkOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"done" : function() {
		removeAllScrollbarHighlights(scrollMarkerClass);
		markCurrentSelection();
	}
};
let unmarkOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"done" : function() {
		removeAllScrollbarHighlights(initialHitsScrollMarkerClass);
	}
};

if (markerMainElement !== null)
	{
	markerInstance = new Mark(markerMainElement);
	}

// After a click, update markers in text and scroll corresponding TOC element into view.
function delayedUpdateMarkersAndTOC(evt) {
	let doubleClickDelay = doubleClickTime + 100; // milliseconds
	setTimeout(function() {
		updateMarkers(evt);
	}, doubleClickDelay);
	
	scrollTocEntryIntoView(evt, false);
}

// Highlight user's selection, unless it was a click on a link or in the scrollbar, or the
// first click in a double-click, or there's too much text selected to be worth higlighting.
function updateMarkers(evt) {
	if (linkClicked)
		{
		return;
		}
	if (theSelection.isDoubleClick)
		{
		theSelection.isDoubleClick = false;
		theSelection.doingDoubleClick = true;
		return;
		}
	if (markerMainElement === null || evtIsInScrollbar(evt))
		{
		return;
		}

	// No marking if selection is "too big" (spreads over more than on line).
	theSelection.selectionIsTooBig = selectionIsTooBig();
	
	if (!justUpdateScrollbar && currentSelectionTouchesLink())
		{
		theSelection.doingDoubleClick = false;
		return;
		}

	mouseEvt = evt;
	
	theSelection.userDragged = false;

	// full highlight, selection, and scrollbar marking
	if (!justUpdateScrollbar && !theSelection.selectionIsTooBig) 
		{
		storeSelection();
		// Get current text to highlight, or set theSelection.selectionTooBig = true.
		// Also set current text to "" if it's fewer than three characters, meaning remove
		// all markers and don't mark anything new or change the selection (this is a way to
		// clear markers).
		currentTextForHighlighting = getCurrentTextForMarkup();
		
		hideSelectionRow(); // Don't mark up row where text is selected
		
		markerInstance.unmark(unmarkOptions);
		}
	else if (justUpdateScrollbar)
		{
		removeAllScrollbarHighlights(scrollMarkerClass);
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
		}

	theSelection.doingDoubleClick = false;
	justUpdateScrollbar = false;
}

//See intramine_file_viewer_cm.pl#InitialHighlightItems().
function highlightInitialItems() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.mark(highlightItems[i], markerOptionsInitialHits);
			}
		initialSearchHitsAreShowing = true;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Hide Initial Hits";
			}
		}
}

//function decodeSpecialWordCharacters() {
//	if (markerMainElement !== null && highlightItems.length > 0)
//		{
//		for (let i = 0; i < highlightItems.length; ++i)
//			{
//			highlightItems[i] = highlightItems[i].replace(/ *__D_ */g, ".");
//			highlightItems[i] = highlightItems[i].replace(/__DS_([A-Za-z])/g, "\$$1");
//			highlightItems[i] = highlightItems[i].replace(/__PC_([A-Za-z])/g, "\%$1");
//			highlightItems[i] = highlightItems[i].replace(/__AT_([A-Za-z])/g, "\@$1");
//			}
//		}
//}

function removeInitialHighlights() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.unmark(unmarkOptionsInitialHits);
			}
		initialSearchHitsAreShowing = false;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Show Initial Hits";
			}
		}
}

function toggleInitialSearchHits() {
	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		}
	else
		{
		highlightInitialItems();
		}
}

function noteWasDoubleClick(evt) {
	//let nons = '';
	theSelection.isDoubleClick = true;
}

function updateScrollbarMarkers() {
	justUpdateScrollbar = true;
	updateMarkers(null);
}

// This is called by mark.js after an unmark, see unmarkOptions above.
function markCurrentSelection() {

	if (currentTextForHighlighting !== "")
		{
		markerInstance.mark(currentTextForHighlighting, markerOptions);
		}
	
	showSelectionRow(); // Restore visibiliy of element containing current user selecton.
	
	showStoredSelections();

	theSelection.userDragged = false;
}

function getCurrentTextForMarkup() {
	let result = getSelectionText();

	return (result);
}

// Get text for marking, unless it's too big to be worth marking. This is a bit of a gamble,
// but a "too big" selection usually means the user is just intending to copy some text,
// not see other instances of it in the same file.
function getSelectionText() {
	let text = "";
	
	theSelection.userDragged = false;
	
	if (window.getSelection && !theSelection.doingDoubleClick)
		{
		let currSelection = window.getSelection();
		if (!theSelection.selectionTooBig)
			{
			text = currSelection.toString();
			if (text !== '')
				{
				theSelection.userDragged = true;
				}
			}
		else
			{
			theSelection.userDragged = true;
			}
		}

	
	if (!theSelection.selectionTooBig && !theSelection.userDragged)
		{
		// Empty selection: expand to nearest word.
		if (text === '')
			{
			//text = expandSelectionToWordIfPossible();
			let wordObj = expandSelectionToWordIfPossible();
			text = wordObj.theWord;
			if (typeof text === 'undefined')
				{
				text = '';
				}
			if (text !== '')
				{
				let beginOffset = wordObj.theBegin;
				let endOffset = wordObj.theEnd;
				// Re-capture the selection for later restoration.
				if (typeof theSelection.ltRange !== 'undefined')
					{
					let startContainer = theSelection.ltRange.startContainer;
					theSelection.ltRange.setStart(startContainer, beginOffset);
					theSelection.ltRange.setEnd(startContainer, endOffset);
					}
				}
			}
		}

	// Avoid highlighting just one or two characters. Or a common English word (top 100);
	if (text.length <= 2 || (text.length > 2 && isCommonEnglishWord(text)))
		{
		text = "";
		}

	return text;
}


// "Too big" means selected text spreads across two or more lines.
// Or we're in a CODE block and more than a word is selected.
// Revision, this affects the actual current selection so stop doing it.
// I can't remember why I wrote the above line.
function selectionIsTooBig() {
	let selectionTooBig = false;
	let withinPRE = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			if (tdElem.nodeName === "PRE")
				{
				withinPRE = true;
				}
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		else
			{
			if (withinPRE)
				{
				let text = window.getSelection().toString();
				if (containsMoreThanOneWord(text))
					{
					selectionTooBig = true;
					}
				}
			}
		}

	return (selectionTooBig);
}

function containsMoreThanOneWord(text) {
	let result = false;
	let nonWordHitPosition = text.search(/\W/);
	if (nonWordHitPosition >= 0) // more than just a word is there
		{
		result = true;
		}

	return(result);
}

function currentSelectionTouchesLink() {
	let result = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let nodes = getNodesInRange(currRange);
		for (let i = 0; i < nodes.length; ++i)
			{
			if (nodes[i].nodeName === "A")
				{
				result = true;
				break;
				}
			}
		}
	
	return(result);
}

function getNextNode(node) {
    if (node.firstChild)
        return node.firstChild;
    while (node)
    {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
}

function getNodesInRange(range) {
    var start = range.startContainer;
    var end = range.endContainer;
    var commonAncestor = range.commonAncestorContainer;
    var nodes = [];
    var node;

    // walk parent nodes from start to common ancestor
    for (node = start.parentNode; node; node = node.parentNode)
    {
        nodes.push(node);
        if (node == commonAncestor)
            break;
    }
    nodes.reverse();

    // walk children and siblings from start until end is found
    for (node = start; node; node = getNextNode(node))
    {
        nodes.push(node);
        if (node == end)
            break;
    }

    return nodes;
}

function expandSelectionToWordIfPossible() {
	return (getFullWord(mouseEvt)); // see wordAtInsertionPt.js

}

// Add handlers for marker updating etc.
if (markerMainElement !== null)
	{
	markerMainElement.addEventListener("click", delayedUpdateMarkersAndTOC);
	markerMainElement.addEventListener("dblclick", noteWasDoubleClick);
	window.addEventListener("resize", updateScrollbarMarkers);

	markerMainElement.addEventListener("mouseup", resetTopNavPosition);
	if (tocMainElement !== null)
		{
		tocMainElement.addEventListener("mouseup", resetTopNavPosition);
		}
	}

// Show/hide highlight markers on scroll bar.

function removeAllScrollbarHighlights(mClass) {
	removeElementsByClass(mClass);
}

function removeElementsByClass(className) {
	let elements = document.getElementsByClassName(className);
	while (elements.length > 0)
		{
		elements[0].parentNode.removeChild(elements[0]);
		}
}

// Put little rectangles in the scrollbar region, placed vertically in proportion to
// where the selected text occurrences happen in the document.
function markHitsInScrollbar(textClassName, scrollHitClassName) {	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	// Fine-tuning: gray area of scrollbar is shortened by the up and down arrows, and starts
	// after the top arrow. There are no arrows on an iPad.
	let mainScrollY = markerMainElement.scrollTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	// let usableTextHeight = textViewableHeight - 2*arrowHeight;

	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowHeight = 18;
	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				//arrowHeight = Math.round(widthDifference) + 1;
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}
	
	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	// indicatorHeight: ideal height of the thumb. In practice the actual thumb height
	// needs to be a minimum of about 18 pixels.
	////let indicatorHeight = (textViewableHeight / mainScrolllHeight) * textViewableHeight;

	let elements = document.getElementsByClassName(textClassName);
	for (let i = 0; i < elements.length; ++i)
		{
		let hitElement = elements[i];
		let elementBoundRect = hitElement.getBoundingClientRect();
		let textHitY = elementBoundRect.top;
		let positionInDoc = mainScrollY + textHitY - yTop;
		let positionRatio = positionInDoc / mainScrolllHeight;
		let relativeMarkerPos = positionRatio * usableTextHeight;
		let absMarkerPos = relativeMarkerPos + yTop + arrowHeight;

		let mk = document.createElement("mark");
		mk.setAttribute("class", scrollHitClassName);
		mk.style.top = absMarkerPos + "px";
		markerMainElement.appendChild(mk);
		}
}

function evtIsInScrollbar(evt) {
	let result = false;
	if (evt !== null)
		{
		if (evt.offsetX >= markerMainElement.clientWidth
				|| evt.offsetY >= markerMainElement.clientHeight)
			{
			// Mouse down over scroll element
			result = true;
			}
		}
	return (result);
}

// Remember the element that starts the selection.
function storeSelection() {
	theSelection.ltRange = lightrange.saveSelection();
}

// Look at siblings of startElement, advance until element does not contain a <mark> subelement.
function showStoredSelections() {
	lightrange.restoreSelection(theSelection.ltRange);
}

function saveSelection() {
	if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.getRangeAt && sel.rangeCount) {
	        return sel.getRangeAt(0);
	    }
	} else if (document.selection && document.selection.createRange) {
	    return document.selection.createRange();
	}
return null;
}

// Set theSelection.currentSelectionElem to TD holding selection, 
// and clone and remove the TD - only if not "too big".
function hideSelectionRow() {
	theSelection.currentSelectionElem = null;
	theSelection.currentSelPreviousSibling = null;
	if (theSelection.selectionIsTooBig)
		{
		return;
		}

	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		else
			{
			theSelection.currentSelectionElem = tdElem;
			theSelection.currentSelPreviousSibling = theSelection.currentSelectionElem.previousSibling;
			}
		}

	if (theSelection.currentSelectionElem !== null)
		{
		let currSelTD = theSelection.currentSelectionElem;
		let i = 0;
		theSelection.selChildren = [];
		
		findRangeTopContainers();
		
		let tdChildNodes = currSelTD.childNodes;
		for  (let j = 0; j < tdChildNodes.length; ++j)
			{
			
			if (tdChildNodes[j] === theSelection.topStartNode)
				{
				recordStartSelIndexes(j, tdChildNodes[j]);
				}

			if (tdChildNodes[j] === theSelection.topEndNode)
				{
				recordEndSelIndexes(j, tdChildNodes[j]);
				}
			}
		
		
		while (theSelection.currentSelectionElem.firstChild)
			{
			theSelection.selChildren[i++] = theSelection.currentSelectionElem.firstChild.cloneNode(true);
			theSelection.currentSelectionElem.removeChild(theSelection.currentSelectionElem.firstChild);
			}
		}
	}

function findRangeTopContainers() {
	let topStartNode = theSelection.ltRange.startContainer;
	while (topStartNode !== null && topStartNode.parentNode !== null && topStartNode.parentNode.nodeName !== "TD")
		{
		topStartNode = topStartNode.parentNode;
		}
	
	let topEndNode = theSelection.ltRange.endContainer;
	while (topEndNode !== null && topEndNode.parentNode !== null && topEndNode.parentNode.nodeName !== "TD")
		{
		topEndNode = topEndNode.parentNode;
		}
	
	theSelection.topStartNode = topStartNode;
	theSelection.topEndNode = topEndNode;
}

function recordStartSelIndexes(topIdx, topNode) {
	theSelection.startNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.startNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.startNodeIndexes.unshift(topIdx);
	theSelection.startNodeOffset = theSelection.ltRange.startOffset;
}

function recordEndSelIndexes(topIdx, topNode) {
	theSelection.endNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.endNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.endNodeIndexes.unshift(topIdx);
	theSelection.endNodeOffset = theSelection.ltRange.endOffset;
}

// Restore display of any TD element holding the current selection.
function showSelectionRow() {
	if (theSelection.currentSelectionElem !== null && theSelection.selChildren.length)
		{
		for (let i = 0; i < theSelection.selChildren.length; ++i)
			{
			theSelection.currentSelectionElem.appendChild(theSelection.selChildren[i]);
			
			
			if (i === theSelection.startNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setStart(node, theSelection.startNodeOffset);
				}
			if (i === theSelection.endNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setEnd(node, theSelection.endNodeOffset);
				}
			}
		
		restoreRangeStartsAndEnds();
		}
}

function restoreRangeStartsAndEnds() {
	let topNode = theSelection.currentSelectionElem;
	
	let drillDownNode = topNode;

	if (typeof drillDownNode === 'undefined')
		{
		return;
		}

	for (let i = 0; i < theSelection.startNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.startNodeIndexes[i]];
		}
	theSelection.ltRange.setStart(drillDownNode, theSelection.startNodeOffset);
	
	drillDownNode = topNode;
	for (let i = 0; i < theSelection.endNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.endNodeIndexes[i]];
		}
	theSelection.ltRange.setEnd(drillDownNode, theSelection.endNodeOffset);
}

// Skip along through childNodes until we hit a MARK and accumulated offset is
// >= targetOffset.
// Returns MARK node or null in [0], accumulated textLength in [1].
function markToSelect(node, textLength, targetOffset, markerNode) {
	if (markerNode !== null)
		{
		return ([ markerNode, textLength ]);
		}
	let lengthSoFar = textLength;
	let tagName = node.nodeName;
	if (tagName === "MARK")
		{
		let markLength = node.textContent.length;
		if (lengthSoFar + markLength >= targetOffset)
			{
			return ([ node, lengthSoFar + markLength ]);
			}
		}

	// Still here, go deeper.
	let numChildren = node.childNodes.length;
	if (numChildren == 0)
		{
		lengthSoFar += node.textContent.length;
		}
	else
		{
		for (let i = 0; i < node.childNodes.length; ++i)
			{
			let markNodeToSelectArray =
					markToSelect(node.childNodes[i], lengthSoFar, targetOffset, markerNode);
			lengthSoFar = markNodeToSelectArray[1];
			if (markNodeToSelectArray[0] !== null)
				{
				markerNode = markNodeToSelectArray[0];
				break;
				}
			}
		}

	return ([ markerNode, lengthSoFar ]);
}

// Link clicked means don't update markers for user's text selection.
function notelinkClicked(evt) {
	if (hintboxClicked)
		{
		hintboxClicked = false;
		return;
		}
	linkClicked = false;

	let target = evt.target || null;
	// Click might be on an "edit" pencil (edit1.png), move up to parent.
	if (target !== null && target.nodeName === "IMG")
		{
		target = target.parentNode;
		}
	if (target !== null && target.nodeName === "A")
		{
		linkClicked = true;
		}
	else
		{
		if (typeof target.id !== 'undefined')
			{
			if (target.id === "hintbox")
				{
				linkClicked = true;
				}
			}
		}
}

// The "hint" box shows a possibly reduced view of an image in text views. On an iPad,
// it's clickable. If clicked, we treat it as a click on a link and don't change the
// marked text.
function noteHintboxClicked() {
	hintboxClicked = true;
	linkClicked = true;
}

let addHintTimer; // onMobile, to keep trying addHintboxListener() until it succeeds.

function addHintboxListener() {
	let tooltipElement = document.getElementById("hintbox");
	if (tooltipElement !== null)
		{
		tooltipElement.addEventListener("touchstart", noteHintboxClicked);
		clearInterval(addHintTimer);
		}
}

if (onMobile)
	{
	addHintTimer = setInterval(addHintboxListener, 200);
	}

document.addEventListener("mousedown", notelinkClicked);

ready(finishStartup);

</script>
<script type="text/javascript">
// showHideTOC.js: shrink/expand the Table Of Contents via a "#tocShrinkExpand" element
// at top of the Table Of Contents. The TOC isn't shrunk away to nothing, a bit is left
// visible (which reminds one that it's there, and makes the design easier:).
// TODO this is a bit fragile, scrollContentsList and scrollTextRightOfContents are hard-coded.
// However, any ambitious person who changes those has bought the rights to full maintenance.
// This is used in the Viewer (intramine_file_viewer_cm.pl) where a view has a table of contents,
// and in gloss2html.pl (which generates HTML from .txt, and there is always a table of contents).

// Shrink/expand the Table Of Contents when the "#tocShrinkExpand" element is clicked.
// If toggleElem is null then shrinkIt will be false and the TOC will expand. This is
// currently called with null by dragTOC.js#addDragger() since for some unknown reason the
// TOC pane is coming up too narrow.
function toggleTOC(toggleElem) {
	// Avoid spurious highlighting after TOC toggle causes redraw.
	if (document.activeElement !== null)
		{
		document.activeElement.blur();
		}

	rememberLocation();
	
	let elementToAdjust = document.getElementById('scrollContentsList');
	let textElement = document.getElementById('scrollTextRightOfContents');
	let divContainer = elementToAdjust.parentElement;
	if (elementToAdjust !== null && textElement !== null)
		{
		let widthStrTOC = window.getComputedStyle(elementToAdjust, null).getPropertyValue('width');
		let widthStrParent = window.getComputedStyle(divContainer, null).getPropertyValue('width');
		let widthTOC = parseFloat(widthStrTOC);
		let widthParent = parseFloat(widthStrParent);
		let oldTocWidthPC = 100 * widthTOC / widthParent;
		let paneSep = document.getElementById('panes-separator');;
		let widthPaneSep = 3; // pixels
		if (paneSep !== null)
			{
			let widthStrSep = window.getComputedStyle(paneSep, null).getPropertyValue('width');
			widthPaneSep = parseFloat(widthStrSep); // pixels
			}
		let newWidthPaneSep = widthPaneSep / widthParent * 100;
		
		let shrinkIt = (oldTocWidthPC < 10) ? false : true;
		if (toggleElem === null)
			{
			shrinkIt = false;
			}
		let newWidthTOCPC, newWidthTextPC;
		if (shrinkIt)
			{
			newWidthTOCPC = 5;
			}
		else
			{
			newWidthTOCPC = 23;
			}
		newWidthTextPC = 100 - newWidthPaneSep - newWidthTOCPC;

		elementToAdjust.style.width = newWidthTOCPC + "%";
		textElement.style.width = newWidthTextPC + "%";

		location.hash = topLineNumber;

		if (usingCM)
			{
			// Especially for CodeMirror, force a recalc.
			myCodeMirror.refresh();
			cmQuickRejumpToLine();
			}
		else
			{
			reJumpToLineNumber(topLineNumber);
			///// was restoreTopPosition(textElement, theTopPos);
			}

		// Redo initial scrollbar markers
		if (initialSearchHitsAreShowing)
			{
			removeInitialHighlights();
			highlightInitialItems();
			}

		// Also redo scroll bar markers for selection hits in the scroll bar.
		if (!usingCM)
			{
			removeAllScrollbarHighlights(scrollMarkerClass);
			markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
			}
		
		// Remember current TOC width in pixels.
		if (toggleElem !== null) // Not first call
			{
			let leftPaneStr = elementToAdjust.style.width;
			let leftPanePC = parseFloat(leftPaneStr);
			let leftPanePixels = leftPanePC * widthParent / 100;
			let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
			localStorage.setItem(leftPaneWidthKey, leftPanePixels);
			}
		}

	return (false);
}

function addTocToggle(idToggle) {
	let scrollContentsElement = document.getElementById('scrollContentsList');
	if (scrollContentsElement !== null)
		{
		// Add in the shrink/expand element at top of Table Of Contents.
		let toggleElem;
		if (b64ToggleImage !== '')
			{
			toggleElem = createElementFromHTML("<img src=\"data:image/png;base64,"
						+ b64ToggleImage + "\" id='" + idToggle + "'>");
			}
		else
			{
			toggleElem = createElementFromHTML("<img src='707788g4.png' id='" + idToggle + "'>");
			}
		
		document.body.insertBefore(toggleElem, document.body.firstChild);
		toggleElem.addEventListener('click', function() {
			toggleTOC(toggleElem);
		});

		// Default position is absolute relative to the page. We want to set the top so that it
		// nestles down in the Table of Contents at the top, where 20px of margin has been
		// left for it. Top should be just below the horizontal rule that divides upper part
		// of page from content proper.
		let rule = document.getElementById("rule_above_editor");
		let pos = getPosition(rule);
		let toggleTop = pos.y + 4;

		toggleElem.style.top = toggleTop + "px";
		}
}

// If the nav bar wraps and grows taller, or shrinks back down,
// it's nice to reposition the green double-headed arrow.
function repositionTocToggle() {
	let toggleElem = document.getElementById("tocShrinkExpand");
	let rule = document.getElementById("rule_above_editor");
	if (toggleElem === null || rule === null)
		{
		return;
		}
	let pos = getPosition(rule);
	let toggleTop = pos.y + 4;

	toggleElem.style.top = toggleTop + "px";
}

// Get line number of first visible line in text.
// For non-codemirror, look for table row with bounding rect top that is
// >= elem bounding rect top. On that row, <td n="(\d+)" gives the line number.
function firstVisibleLineNumber(elem) {
	let topPos = 0;
	//let undefCounter = 0;

	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let firstVisibleLineNum = myCodeMirror.lineAtHeight(rect.top, "window");
		topPos = firstVisibleLineNum;
		}
	else
		{
		topPos = quickGetPosition(elem, true);
		}

	return (topPos);
}

// For non-CodeMirror files, the text of the document is in one or more consecutive <table>s.
// - find first table whose top is too far, look at the one before that - or if top
// is dead on, use that one.
// - check every 100th or 10th entry for element that is too far or dead on
// - if checked 100, now check every 10th starting from the "100" row just found
// - step through from there to find the exact number, skipping shrunk rows that have no number.
// "elem" is the main text holder, having tables as direct children (at least one).
function quickGetPosition(elem, getTop) {
	if (elem === null)
		{
		return;
		}
	let topPos = 0;
	let undefCounter = 0;
	let enclosingRect = elem.getBoundingClientRect();
	let enclosingRectTopOrBot = (getTop) ? enclosingRect.top : enclosingRect.bottom;
	
	let kids = null;
	for (; undefCounter < 100; ++undefCounter)
		{
		if (typeof(elem.children) !== 'undefined')
			{
			kids = elem.children;
			break;
			}
		}
	
	if (typeof(elem.children) === 'undefined')
		{
		//console.log("ERROR could not get children!");
		return(0);
		}
	
	//let done = false;
	
	// If "kids" doesn't have a table, try going down one more level - this is needed
	// with "index.txt" for example, which has a "special-index-wrapper" holding its one table
	if (!elementHasTableAsChild(kids))
		{
		kids = elem.children[0].children;
		}
	
	// - find first table whose BOTTOM is past the top or bottom of the view.
	let table = wantedTableForPosition(kids, enclosingRectTopOrBot, getTop);
	
	if (table !== null)
		{
		let tableBody = getTableBody(table);
		
		if (tableBody !== null)
			{
			let rowNum = getRowCandidateAbovePosition(table, 100, 10, enclosingRectTopOrBot);
			topPos = rowTopPosition(table, rowNum, 10, enclosingRectTopOrBot);
			}
		}
	
	return (topPos);
}

function getTableBody(table) {
	let tableBody = null;
	
	if (table !== null)
		{
		let tableKids = table.children; // there should be only one TBODY
		for (let m = 0; m < tableKids.length; ++m)
			{
			if (tableKids[m].nodeName === "TBODY")
				{
				tableBody = tableKids[m];
				break;
				}
			}
		}
	
	return(tableBody);
}

//Look at last row bottom in each table body, return current table if its bottom is
// at or past enclosingRectTopOrBot.
// // Sometimes rounding errors get in the way, hence the "Math.ceil()"
function wantedTableForPosition(topChildren, enclosingRectTopOrBot, getTop) {
	let wantedTable = null;
	
	
	//enclosingRectTopOrBot -= 1;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		if (!getTop)
			{
			//console.log("Checking table " + i);
			}
		
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = getTableBody(topChildren[i]);
			
			if (tableBody !== null)
				{
				let rows = tableBody.children;
				if (rows.length > 0)
					{
					let rowToCheck = rows.length - 1;
					let bounding = rows[rowToCheck].getBoundingClientRect();
					let bottomCeiling = Math.ceil(bounding.bottom);
					
					if (!getTop)
						{
						//console.log("Checking table " + i + " row " + rowToCheck + " bottom " + bottomCeiling + " of " + rows.length + " against " + enclosingRectTopOrBot);
						}
					
					if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			} // if (tagName === "TABLE")
		}
		
	if (wantedTable === null)
		{
		if (!getTop)
			{
			//console.log("Did NOT find bottom!");
			}
		
		if (topChildren.length > 0)
			{
			if (getTop)
				{
				for (let i = 0; i < topChildren.length; ++i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			else // bottom
				{
				for (let i = topChildren.length - 1; i >= 0; --i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			}
		else
			{
			//console.log("ERROR no tables in document!");
			}
		}
	
	return(wantedTable);
}

function elementHasTableAsChild(topChildren) {
	let result = false;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			result = true;
			break;
			}
		}
	
	return(result);
}

// We are looking for a row with bottom above or at enclosingRectTopOrBot.
// 
// Starting at table bottom, look upwards rowInc at a time for the row bottom
// that is <= enclosingRectTopOrBot. If none found, the default 0 is returned.
// There are two passes, crude (100 row jumps) and fine (10 row jumps).
function getRowCandidateAbovePosition(table, majorInc, minorInc, enclosingRectTopOrBot) {
	let wantedRow = 0;
	//let lastRowCheckedInFirstPass = 0;
	let tableBody = getTableBody(table);
	
	if (tableBody !== null)
		{
		let rows = tableBody.children;
		let rowToCheck = rows.length - 1;
		
		// Look backwards in big jumps, from end of table.
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= majorInc;
				}
			}
		
		// Look backwards in small jumps, from wantedRow just found plus majorInc.
		rowToCheck = wantedRow + majorInc;
		if (rowToCheck > rows.length - 1)
			{
			rowToCheck = rows.length - 1;
			}
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= minorInc;
				}
			}
		}
	
	return(wantedRow);
}

// startRow should have a bottom that is <= enclosingRectTopOrBot, and not be too far
// above one that's >. Look down from startRow for a row with bottom >= enclosingRectTopOrBot.
// Try to adjust down slightly from that to a row with TOP >= enclosingRectTopOrBot.
// On a complete fail, which can happen when scrolling to bottom of document, take
// the last line number in the table. What can I say, it works.
function rowTopPosition(table, startRow, minorInc, enclosingRectTopOrBot) {
	let topPos = 0;
	let tableBody = getTableBody(table);
	
	enclosingRectTopOrBot = Math.ceil(enclosingRectTopOrBot);
	
	if (tableBody !== null)
		{
		let foundIt = false;
		let rows = tableBody.children;
		let lastToCheck = startRow + minorInc + 1;
		if (lastToCheck > rows.length)
			{
			lastToCheck = rows.length;
			}
		
		for (let j = startRow; j < lastToCheck; ++j)
			{
			let bounding = rows[j].getBoundingClientRect();
			let bottomCeiling = Math.ceil(bounding.bottom);
			if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
				{
				let lastToCheck_K =  j + 3;
				if (lastToCheck_K > rows.length)
					{
					lastToCheck_K = rows.length;
					}
				for (let k = j; k < lastToCheck_K; ++k)
					{
					let bounding_K = rows[k].getBoundingClientRect();
					let bottomCeiling_K = Math.ceil(bounding_K.bottom);
					if (bottomCeiling_K > enclosingRectTopOrBot)
						{
						let contents = rows[k].innerHTML;
						let lineNumMatch = /^<td n="(\d+)/.exec(contents);
						if (lineNumMatch !== null)
							{
							topPos = parseInt(lineNumMatch[1], 10);
							foundIt = true;
							break;
							}
						}
					}
				
				// For the very last line, it's possible that the bottom of the last row
				// won't be visible (perhaps by only a pixel or so) or that it's a shrunk
				// row with no line number. If so, look up starting at row j for a row
				// with visible top and a line number.
				if (!foundIt)
					{
					for (let k = j; k < lastToCheck_K; ++k)
						{
						let bounding_K = rows[k].getBoundingClientRect();
						if (bounding_K.top >= enclosingRectTopOrBot)
							{
							let contents = rows[k].innerHTML;
							let lineNumMatch = /^<td n="(\d+)/.exec(contents);
							if (lineNumMatch !== null)
								{
								topPos = parseInt(lineNumMatch[1], 10);
								foundIt = true;
								break;
								}
							}
						}
					}
				
				break;
				}
			}
		
		if (!foundIt)
			{
			// Find last row with a line number.
			let k = rows.length - 1;
			while (k >= 0)
				{
				let contents = rows[k].innerHTML;
				let lineNumMatch = /^<td n="(\d+)/.exec(contents);
				if (lineNumMatch !== null)
					{
					topPos = parseInt(lineNumMatch[1], 10);
					foundIt = true;
					break;
					}
				--k;
				}
			}
		} // if (tableBody !== null)
	
	return (topPos);
}

function lastVisibleLineNumber(elem) {
	let bottomPos = 0;
	//let undefCounter = 0;
	
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let lastVisibleLineNum = myCodeMirror.lineAtHeight(rect.bottom, "window");
		bottomPos = lastVisibleLineNum;
		}
	else
		{
		bottomPos = quickGetPosition(elem, false);
		}

	return (bottomPos);
}

// Not used.
// Mainly for Non-CodeMirror, calculate an average line height in pixels.
function getAverageLineHeight(elem) {
	let averageHeight = 14; // Use an arbitrary but not horrible default.
	if (usingCM)
		{
		averageHeight = myCodeMirror.defaultTextHeight();
		}
	else
		{
		let enclosingRect = elem.getBoundingClientRect();
		let visiblePixels = enclosingRect.bottom - enclosingRect.top;
		let firstVisibleLineNum = firstVisibleLineNum(elem);
		let lastVisibleLineNum = lastVisibleLineNumber(elem);
		let numVisibleLines = lastVisibleLineNum - firstVisibleLineNum;
		if (numVisibleLines > 0 && visiblePixels > 0)
			{
			averageHeight = visiblePixels / numVisibleLines;
			}
		}
	
	return(averageHeight);
}

// Unfinished, unused.
// Calc a rough value for nonCM, based on average line height in pixels.
function getNumVisibleLines(elem) {
	let numVisibleLines = 0;
	
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let firstVisibleLineNum = myCodeMirror.lineAtHeight(rect.top, "window");
		let lastVisibleLineNum = myCodeMirror.lineAtHeight(rect.bottom, "window");
		numVisibleLines = lastVisibleLineNum - firstVisibleLineNum + 1;
		}
	else
		{
		let enclosingRect = elem.getBoundingClientRect();
		let enclosingRectTop = enclosingRect.top;
		let enclosingRectBottom = enclosingRect.bottom;
		let numVisiblePixels = enclosingRectBottom - enclosingRectTop;
		
		}
	return(numVisibleLines);
}

function restoreTopPosition(elem, topPos) {
	if (usingCM)
		{
		jumpToLine(topPos + 2, false);
		}
	else
		{
		restoreTopPositionNonCM(elem, topPos);
		}
}

// Find <tr> in elem with <td n="topPos"..., scroll it into view.
function restoreTopPositionNonCM(elem, topPos) {
	let children = elem.children;
	let done = false;

	for (let i = 0; i < children.length; ++i)
		{
		let tagName = children[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = children[i].children;
			for (let k = 0; k < tableBody.length; ++k)
				{
				let tableChildren = tableBody[k].children;
				for (let j = 0; j < tableChildren.length; ++j)
					{
					let contents = tableChildren[j].innerHTML;
					let lineNumMatch = /^<td n="(\d+)/.exec(contents);
					if (lineNumMatch !== null)
						{
						let currentLine = lineNumMatch[1];
						if (currentLine == topPos)
							{
							tableChildren[j].scrollIntoView();
							// Set top of nav to zero, fixes an iPad scroll problem where nav
							// goes off the top.
							let nav = document.getElementById("nav"); // nope nav.style.top = 0;
							if (nav !== null)
								{
								nav.parentNode.scrollTop = 0;
								}
							done = true;
							break;
							}
						}
					}
				if (done)
					{
					break;
					}
				}
			}
		if (done)
			{
			break;
			}
		}
}

// Handle Table of Contents (TOC) width in views. The goal is to keep the
// same TOC width in pixels as much as possible.

function rememberTocWidthPixels() {
	let leftPane = document.getElementById('scrollContentsList'); // TOC column
	if (leftPane === null)
		{
		return;
		}
	let leftPaneWidthStr = window.getComputedStyle(leftPane, null).getPropertyValue('width');
	let widthLeftPane = parseFloat(leftPaneWidthStr);
	let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
	localStorage.setItem(leftPaneWidthKey, widthLeftPane);
}

// Return width in pixels of table of contents column from localStorage,
// also set localStorage value if that hasn't been done yet.
function getTocWidthPixels() {
	let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
	let widthLeftPane; // pixels
	if (!localStorage.getItem(leftPaneWidthKey))
		{
		rememberTocWidthPixels(); // sets leftPaneWidthKey in localStorage
		}
	
	let leftPaneWidthStr = localStorage.getItem(leftPaneWidthKey);
	widthLeftPane = parseFloat(leftPaneWidthStr);
	
	return(widthLeftPane);
}

// Use width in pixels of table of contents column as last save
// to set widths of table of contents and text in percentages.
function restoreColumnWidths() {
	let leftPane = document.getElementById('scrollContentsList'); // TOC column
	let panesContainer = document.getElementById('scrollAdjustedHeight');
	let paneSep = document.getElementById('panes-separator');
	if (leftPane === null || panesContainer === null || paneSep === null)
		{
		return;
		}

	let widthLeftPane = getTocWidthPixels();
	let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
	let widthPanesContainer = parseFloat(panesContainerWidthStr);
	let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
	let paneSepWidth = parseFloat(paneSepWidthStr);
	let separatorPercent = paneSepWidth / widthPanesContainer * 100;
	let leftPanePC = widthLeftPane / widthPanesContainer * 100;
	leftPane.style.width = leftPanePC + '%';
	let right = (100-leftPanePC-separatorPercent);
	rightPane.style.width = right + '%';
}

window.addEventListener("load", function() {
	addTocToggle('tocShrinkExpand');
});

</script>
<script type="text/javascript">
/**
 * indicator.js: Mainly a scroll indicator for PCs and iPads in non-codemirror views (text, perl etc).
 */

// 'indicator is for mobile', 'indicatorPC' is for a regular Windows box.
let indicatorElem = onMobile ? document.getElementById('indicator') : document.getElementById('indicatorPC');
let otherIndicatorElem = onMobile ? document.getElementById('indicatorPC') : document.getElementById('indicator');
//let indicatorElem = document.getElementById('indicator');
let indicatorM = 0; // for mobile and non-mobile
let lazySetUpMobileIndicator = JD.debounce(setUpMobileIndicator, 100);
let lazyMobileScroll = JD.debounce(scrollMobileIndicator, 500);
let lazyResetTopNavPosition = JD.debounce(resetTopNavPosition, 400);

let lazySetUpIndicator = JD.debounce(setUpIndicator, 100);
let lazyScroll = JD.debounce(scrollIndicator, 500);
let arrowHeight = 18; // Needed for PC only.

otherIndicatorElem.style.display = 'none';


if (onMobile) // iPad only supported for now....
	{
	//console.log("WE ARE MOBILE.");
	window.addEventListener("load", lazySetUpMobileIndicator);
	window.addEventListener("resize", lazySetUpMobileIndicator);
	markerMainElement.addEventListener("scroll", scrollMobileIndicator);
	markerMainElement.addEventListener("touchend", lazyResetTopNavPosition);

	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement !== null)
		{
		tocElement.addEventListener("touchend", lazyMobileScroll);
		tocElement.addEventListener("touchend", lazyResetTopNavPosition);
		}
	}
else
	{
	window.addEventListener("load", lazySetUpIndicator);
	window.addEventListener("resize", lazySetUpIndicator);
	
	markerMainElement.addEventListener("scroll", scrollIndicator);
	window.addEventListener("load", addHideIndicatorScrollListener);
	
	hideIt("search-button");
	hideIt("small-tip");
	hideIt("undo-button");
	hideIt("redo-button");
	}

// Mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;

	if (mainScrolllHeight > textViewableHeight)
		{
		let indicatorHeight = (textViewableHeight / mainScrolllHeight) * textViewableHeight;
		indicatorM =
				(textViewableHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);

		if (indicatorHeight < 2.0)
			{
			indicatorHeight = 2.0;
			}
		indicatorElem.style.height = indicatorHeight + "px";
		}

	lazyMobileScroll();
}

// Non-mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpIndicator() {
	if (onMobile)
		{
		return;
		}
	
	recalculateIndicatorM();
	// let rect = markerMainElement.getBoundingClientRect();
	// let yTop = rect.top;
	// let yBottom = rect.bottom;
	// let textViewableHeight = yBottom - yTop;
	// let mainScrolllHeight = markerMainElement.scrollHeight;
	
	// let viewWidth = rect.right - rect.left;
	// let widthDifference = viewWidth - markerMainElement.clientWidth;
	// let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	// let haveVerticalScroll = (widthDifference > 2) ? true : false;
	// let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	// let arrowMultiplier = 2;
	// if (typeof window.ontouchstart !== 'undefined')
	// 	{
	// 	arrowHeight = 2;
	// 	}
	// else
	// 	{
	// 	if (haveVerticalScroll)
	// 		{
	// 		if (widthDifference > 6.0 && widthDifference < 30.0)
	// 			{
	// 			arrowHeight = widthDifference;
	// 			}
	// 		if (haveHorizontalScroll)
	// 			{
	// 			arrowMultiplier = 3;
	// 			}
	// 		}
	// 	else
	// 		{
	// 		arrowHeight = 0;
	// 		}
	// 	}

	// let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	// if (mainScrolllHeight > usableTextHeight)
	// 	{
	// 	let indicatorHeight = usableTextHeight * (textViewableHeight/(mainScrolllHeight));
		
	// 	// Show the indicator only if thumb is too small to reflect actual page size.
	// 	if (indicatorHeight <= 20)
	// 		{
	// 		indicatorM =
	// 				(usableTextHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);
	
	// 		if (indicatorHeight < 2.0)
	// 			{
	// 			indicatorHeight = 2.0;
	// 			}
	// 		indicatorElem.style.height = indicatorHeight + "px";
	// 		}
	// 	else
	// 		{
	// 		indicatorM = 0;
	// 		}
	// 	}
	// else
	// 	{
	// 	indicatorM = 0;
	// 	}

	lazyScroll();
	
	setTimeout(function() {
				hideIndicator();
			}, 1000);
}

function recalculateIndicatorM() {
	if (onMobile)
		{
		return;
		}
	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	
	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}

	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	if (mainScrolllHeight > usableTextHeight)
		{
		let indicatorHeight = usableTextHeight * (textViewableHeight/(mainScrolllHeight));
		
		// Show the indicator only if thumb is too small to reflect actual page size.
		if (indicatorHeight <= 20)
			{
			indicatorM =
					(usableTextHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);
	
			if (indicatorHeight < 2.0)
				{
				indicatorHeight = 2.0;
				}
			indicatorElem.style.height = indicatorHeight + "px";
			}
		else
			{
			indicatorM = 0;
			}
		}
	else
		{
		indicatorM = 0;
		}
}

// Mobile, set indicatorElem.top
function scrollMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop;
		indicatorElem.style.top = newThumbTop + "px";
		}
}

// Non-mobile, set indicatorElem.top
function scrollIndicator() {
	if (onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		indicatorElem.style.display = 'block';
		
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop + arrowHeight;
		indicatorElem.style.top = newThumbTop + "px";
		}

	// Sometimes the lines change, reset indicatorM.
	recalculateIndicatorM();
}

// Add a scroll listener that hides the 'indicatorPC' box after a few seconds.
let isScrollingIndicator = null;
function addHideIndicatorScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrollingIndicator );
	
			// Set a timeout to run after scrolling ends
			isScrollingIndicator = setTimeout(function() {
				// Run the callback
				hideIndicator();
			}, 3000);
			});
		}
}

function hideIndicator() {
	if (indicatorElem !== null)
		{
		indicatorElem.style.display = 'none';
		}
}

</script>
<script type="text/javascript">
// toggle.js: toggle between two positions in a document.
// This is for non-CodeMirror file views, as presented by IntraMine's Viewer service.
// Track "proximal" (current) and "distal" (previous) positions
// in response to all changes in scrolled position.
// If it's a small move, update the proximal position.
// If it's a big move, call the new position proximal, and the old
// proximal becomes distal.
// Toggle: scroll distal into view, and switch proximal with distal.

let proximalLineNumber = 1;	// "here"
let distalLineNumber = 1;	// "there"
let bigMoveLineLimit = 100; // Big move vs small move

function toggle() {
	//console.log("Toggle click");
	//console.log("Toggle, before: here " + proximalLineNumber + ", there " + distalLineNumber);
	let tempNum = proximalLineNumber;
	proximalLineNumber = distalLineNumber;
	distalLineNumber = tempNum;
	let el = document.getElementById(cmTextHolderName);
	//console.log("Toggle, AFTER: here " + proximalLineNumber + ", there " + distalLineNumber);
	restoreTopPositionNonCM(el, proximalLineNumber);
}

function updateTogglePositions() {
	let el = document.getElementById(cmTextHolderName);
	let myStartLine = firstVisibleLineNumber(el);
	//console.log("update myStartLine " + myStartLine);
	if (myStartLine < 1)
		{
		myStartLine = 1;
		}
	//console.log("update here " + proximalLineNumber);
	let linesScrolled = proximalLineNumber - myStartLine;
	//console.log("update lines scrolled: " + linesScrolled);
	if (linesScrolled < 0)
		{
		linesScrolled = -linesScrolled;
		}
	if (linesScrolled <= bigMoveLineLimit)
		{
		//console.log("small move, here " + proximalLineNumber + ", there " + distalLineNumber + " before update");
		proximalLineNumber = myStartLine;
		//console.log(" here is " + proximalLineNumber + " after update.)");
		}
	else
		{
		//console.log("Big move! here " + proximalLineNumber + ", there " + distalLineNumber + " before update")
		distalLineNumber = proximalLineNumber;
		proximalLineNumber = myStartLine;
		//console.log("AFTER BIG MOVE: here "+ proximalLineNumber + ", there " + distalLineNumber);
		}
	//console.log("Toggle position update top line " + myStartLine);
}

// Borrowed from
//https://gomakethings.com/detecting-when-a-visitor-has-stopped-scrolling-with-vanilla-javascript/
let isScrolling = null;
function addToggleScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrolling );
	
			// Set a timeout to run after scrolling ends
			isScrolling = setTimeout(function() {
				// Run the callback
				updateTogglePositions();
			}, 66);
			});
		}
}

// Set the number of lines that counts as a "big move"
// (meaning a real change of position, not just an adjustment
// of current position).
// Called by viewerStart.js#doResize() and on load by
// viewerStart.js#reJumpAndHighlight().
function updateToggleBigMoveLimit() {
	let el = document.getElementById(cmTextHolderName);
	let firstVisibleLineNum = firstVisibleLineNumber(el);
	let lastVisibleLineNum = lastVisibleLineNumber(el);
	
	// Problem, sometimes lastVisibleLineNumber() can return 0.
	if (lastVisibleLineNum === 0)
		{
		lastVisibleLineNum = lastVisibleLineNumber(el);
		if (lastVisibleLineNum === 0)
			{
			//console.log("EARLY EXIT in updateToggleBigMoveLimit!");
			return;
			}
		}
	
	let numVisibleLines = lastVisibleLineNum - firstVisibleLineNum;
	if (numVisibleLines <= 10)
		{
		bigMoveLineLimit = 20;
		//console.log("TINY WINDOW!");
		}
	else
		{
		bigMoveLineLimit = numVisibleLines + 10;
		}
	
	//console.log("First vis: " + firstVisibleLineNum);
	//console.log("LAST vis: " + lastVisibleLineNum);
	//console.log("Big move limit: " + bigMoveLineLimit);
}

window.addEventListener("load", addToggleScrollListener);


</script>
<script type="text/javascript">
/**
 * scrollTOC.js: when a heading is clicked in text, scroll corresponding Table of Contents
 * entry into view. Non-CodeMirror files only. See cmScrollTOC.js for CodeMirror handling.
 */

// Scroll the Table of Contents:
// if click was in text content, to heading at or just before line clicked.
// if scrolling, to heading at or just after first visible line.
function scrollTocEntryIntoView(evt, weAreScrolling) {
	let tocElem = null;

	if (!weAreScrolling)
		{
		let lineNum = lineNumberforAnchor();
		if (lineNum >= 0)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}
		else
			{
			// Treat as for scrolling.
			weAreScrolling = true;
			}
		}
	
	if (weAreScrolling)
		{
		let el = document.getElementById(cmTextHolderName);
		let limitLineNum = lastVisibleLineNumber(el) + 1;
		let lineNum = firstVisibleLineNumber(el);
		tocElem = getTocElemAfterLineNumber(lineNum, limitLineNum);
		if (tocElem === null)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}

		// For restoring scrolled position after a reload.
		location.hash = lineNum.toString();
		}
		
	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}

// Restore scrolled position of Table of Contents.
// Called by  viewerStart.js#reJumpToLineNumber().
function restoreTocSelection(lineNum) {
	let tocElem = null;

	let el = document.getElementById(cmTextHolderName);
	let limitLineNum = lastVisibleLineNumber(el) + 1;
	tocElem = getTocElemAfterLineNumber(lineNum, limitLineNum);
	if (tocElem === null)
		{
		tocElem = getTocElemForLineNumber(lineNum);
		}
	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}

// Get text line number for current selection anchor, or -1.
function lineNumberforAnchor() {
	let currSelection = window.getSelection();
	if (currSelection === null)
		{
		return(-1);
		}
	
	let lineNum = -1;
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.startContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem !== null)
			{
			let previousElem = tdElem.previousSibling;
			if (previousElem !== null)
				{
				let tdLineNum = previousElem.getAttribute("n");
				if (tdLineNum !== null)
					{
					lineNum = tdLineNum;
					}
				}
			}
		}
	
	return (lineNum);
}

// Return TOC element that is at or closest above the text line number.
// Called for mouse/touch in actual text content.
// Typical non-CodeMirror TOC entry:
// <li class="h2" im-text-ln="123">
function getTocElemForLineNumber(lineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let previousTocElem = null;
	let previousTocElemLineNum = 0;
	let lowestNumberedElem = null;
	let lowestNumberedElemNumber = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum <= lineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (previousTocElemLineNum <  tocLineNum)
				{
				previousTocElemLineNum = tocLineNum;
				previousTocElem = tocEntries[i];
				}
			
			if (lowestNumberedElemNumber == 0 || lowestNumberedElemNumber > tocLineNum)
				{
				lowestNumberedElemNumber = tocLineNum;
				lowestNumberedElem = tocEntries[i];
				}
			}
		}
	
	if (tocElem === null && previousTocElem !== null)
		{
		tocElem = previousTocElem;
		}
	else if (tocElem === null && lowestNumberedElem !== null)
		{
		tocElem = lowestNumberedElem;
		}
	
	return(tocElem);
}

// Return TOC element that is at or closest *below* the text line number.
// Called after a scroll. Element must be before the visible bottom of the page,
// otherwise we should be looking upwards from the top of page for the heading
// that applies to the current position.
function getTocElemAfterLineNumber(lineNum, limitLineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let nextTocElem = null;
	let nextTocElemLineNum = 999999;
	let lastTocElem = null;
	let lastTocElemLineNum = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum >= lineNum && tocLineNum <= limitLineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (nextTocElemLineNum >  tocLineNum)
				{
				nextTocElemLineNum = tocLineNum;
				nextTocElem = tocEntries[i];
				}
			
			if (lastTocElemLineNum < tocLineNum)
				{
				lastTocElemLineNum = tocLineNum;
				lastTocElem = tocEntries[i];
				}
			}
		}

	
	if (tocElem === null && nextTocElem !== null)
		{
		tocElem = nextTocElem;
		}
	else if (tocElem === null && lastTocElem !== null)
		{
		tocElem = lastTocElem;
		}
	
	return(tocElem);
}

let scrollingForToc = null;
function addTocScrollListener(evt) {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function(evt) {
			// Clear our timeout throughout the scroll
			window.clearTimeout( scrollingForToc );
	
			// Set a timeout to run after scrolling ends
			scrollingForToc = setTimeout(function() {
				// Run the callback.
				scrollTocEntryIntoView(evt, true);
			}, 66);
			});
		}
}

// Not used.
function addTocAndToggleListeners(evt) {
	let el = document.getElementById(cmTextHolderName);
	el.addEventListener("scroll", function(evt) {
		// Clear our timeout throughout the scroll
		window.clearTimeout( scrollingForToc );
	
		// Set a timeout to run after scrolling ends
		scrollingForToc = setTimeout(function() {
			// Run the callbacks.
			scrollTocEntryIntoView(evt, true);
			updateTogglePositions();
		}, 66);
	});
}

function updateTocHighlight(elem) {
	if (elem === null)
		{
		return;
		}
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		if (hasClass(tocEntries[i], selectedTocId))
			{
			removeClass(tocEntries[i], selectedTocId);
			}
		}
	
	addClass(elem, selectedTocId);
}

window.addEventListener("load", addTocScrollListener);
//window.addEventListener("load", addTocAndToggleListeners);


</script>
<script type="text/javascript">
// dragTOC.js: drag pane-separator to vary width of Table of Contents.
// localStorage is used to remember and restore the TOC width.
// See also dragTOC.css.
// Used by intramine_viewer.pl.

let leftPane = document.getElementById('scrollContentsList'); // 'left-pane'
let rightPane = document.getElementById('scrollTextRightOfContents'); // 'right-pane'
let panesContainer = document.getElementById('scrollAdjustedHeight'); // 'panes-container'
let paneSep; // 'panes-separator', eventually (see below)
let topLineNumber; // for restoring scrolled position when the separator is dragged.

// This is done in viewerStart.js#reJumpAndHighlight(). Doing it earlier there
// results in a stable first line number for the text.
/////window.addEventListener("load", addDragger);

function addDragger() {
    if (leftPane === null || rightPane === null || panesContainer === null)
        {
        return;
        }
    
    let paneSepString = "<div class='panes-separator' id='panes-separator'></div>";
    let paneSeparator = createElementFromHTML(paneSepString);
    panesContainer.insertBefore(paneSeparator, rightPane);

    paneSep = document.getElementById('panes-separator');
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);
    let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
    let paneSepWidth = parseFloat(paneSepWidthStr);
    let separatorPercent = paneSepWidth / widthPanesContainer * 100;
    // Retrieve left pane width from localStorage if possible, else leave width alone.
    let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
    let leftPaneWidthStr;
    let widthLeftPane;
    let cur;
    if (!localStorage.getItem(leftPaneWidthKey))
        {
        cur = 23; // toc width default is 23%
        widthLeftPane = cur * widthPanesContainer / 100;
        localStorage.setItem(leftPaneWidthKey, widthLeftPane);
        leftPane.style.width = cur + '%';
        }
    else
        {
        leftPaneWidthStr = localStorage.getItem(leftPaneWidthKey);
        widthLeftPane = parseFloat(leftPaneWidthStr);
        cur = widthLeftPane / widthPanesContainer * 100;
        leftPane.style.width = cur + '%';
        }
    
    let right = (100-cur-separatorPercent);
    rightPane.style.width = right + '%';

    paneSep.addEventListener('mousedown', startDraggingSeparator);
}

function separatorMouseUp() {
    window.removeEventListener('mousemove', moveSeparator);
    window.removeEventListener('selectstart', disableSelect);
    document.body.style.cursor = '';

    if (usingCM)
        {
        let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
        let startPos  = myCodeMirror.lineAtHeight(rect.top, "window");
        scrollTocEntryIntoView(startPos, false, true);

        if (typeof topLineNumber !== 'undefined')
            {
            location.hash = topLineNumber;
            }
        cmQuickRejumpToLine(); // Restores first text line in contents
        }

    // Remember left pane (TOC) width.
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);
    let leftPaneStr = leftPane.style.width;
    let leftPanePC = parseFloat(leftPaneStr);
    let leftPanePixels = leftPanePC * widthPanesContainer / 100;
    let leftPaneWidthKey = thePath + '?' + "leftPaneWidth";
    localStorage.setItem(leftPaneWidthKey, leftPanePixels);
    
    // Remove this function from mouseup, otherwise it's called for any mouseup.
    window.removeEventListener('mouseup', separatorMouseUp);
}

// Poke top line number of text into topLineNumber, for restoring scrolled position.
function rememberLocation() {
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
		let lineNumber = parseInt(myStartLine.toString(), 10);
		if (lineNumber > 0)
			{
			lineNumber += 2;
			}
		else
			{
			lineNumber = 1;
			}
        topLineNumber = lineNumber.toString();
		}
	else // text mainly
		{
		let el = document.getElementById(cmTextHolderName);
		let lineNumber = firstVisibleLineNumber(el);
        topLineNumber = lineNumber.toString();
		}
	}

function getFirstVisibleLineNumber() {
    let firstLineNumber = -1;
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let myStartLine = myCodeMirror.lineAtHeight(rect.top, "window");
		let lineNumber = parseInt(myStartLine.toString(), 10);
		if (lineNumber > 0)
			{
			lineNumber += 2;
			}
		else
			{
			lineNumber = 1;
			}
        firstLineNumber = lineNumber;
 		}
	else // text mainly
		{
		let el = document.getElementById(cmTextHolderName);
		firstLineNumber = firstVisibleLineNumber(el);
 		}

    return(firstLineNumber);
}

function startDraggingSeparator(e) {
    rememberLocation();
    document.body.style.cursor = 'col-resize';
    window.addEventListener('mousemove', moveSeparator);
    window.addEventListener('selectstart', disableSelect);
    window.addEventListener('mouseup', separatorMouseUp);
}

function moveSeparator(e) {
    let sepLeft = e.clientX - 20;
    let panesContainerWidthStr = window.getComputedStyle(panesContainer, null).getPropertyValue('width');
    let widthPanesContainer = parseFloat(panesContainerWidthStr);

    let leftPanePC = sepLeft / widthPanesContainer * 100;
    if (leftPanePC < 5)
        {
        leftPanePC = 5;
        }
    else if (leftPanePC > 90)
        {
        leftPanePC = 90;
        }
    leftPane.style.width = leftPanePC + '%';
    let paneSepWidthStr = window.getComputedStyle(paneSep, null).getPropertyValue('width');
    let paneSepWidth = parseFloat(paneSepWidthStr);
    let separatorPercent = paneSepWidth / widthPanesContainer * 100;
    let right = (100-leftPanePC-separatorPercent);
    rightPane.style.width = right + '%';

    if (initialSearchHitsAreShowing)
        {
        removeInitialHighlights();
        highlightInitialItems();
        }

    // Also redo scroll bar markers for selection hits in the scroll bar.
    if (!usingCM)
        {
        removeAllScrollbarHighlights(scrollMarkerClass);
        markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
        location.hash = topLineNumber;
        reJump();
        }
    else
        {
        //let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
        //let startPos  = myCodeMirror.lineAtHeight(rect.top, "window") + 2;
        location.hash = topLineNumber;
        myCodeMirror.refresh();
        reJump();
        }
}

function disableSelect(event) {
    event.preventDefault();
}
</script>
<script type="text/javascript">
/*! lolight v1.4.0 - https://larsjung.de/lolight/ modified to add 'my' and 'sub' keywords. -KLB */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.lolight=t()}(this,function(){function t(e){if("string"!=typeof e)throw new Error("tok: no string");for(var t=[],n=u.length,o=!1;e;)for(var r=0;r<n;r+=1){var i=u[r][1].exec(e);if(i&&0===i.index){var a=u[r][0];if("rex"!==a||!o){var l=i[0];a===s&&c.test(l)&&(a="key"),"spc"===a?0<=l.indexOf("\n")&&(o=!1):o=a===f||a===s,e=e.slice(l.length),t.push([a,l]);break}}}return t}function e(e,t){if("undefined"!=typeof document)t(document);else if(e)throw new Error("no doc")}function n(o){e(!0,function(n){var e=t(o.textContent);o.innerHTML="",e.forEach(function(e){var t=n.createElement("span");t.className="ll-"+e[0],t.textContent=e[1],o.appendChild(t)})})}function o(t){e(!0,function(e){[].forEach.call(e.querySelectorAll(t||".lolight"),function(e){n(e)})})}var r="_nam#2196f3}_num#ec407a}_str#43a047}_rex#ef6c00}_pct#666}_key#555;font-weight:bold}_com#aaa;font-style:italic}".replace(/_/g,".ll-").replace(/#/g,"{color:#"),c=/^(a(bstract|lias|nd|rguments|rray|s(m|sert)?|uto|sync)|b(ase|egin|ool(ean)?|reak|yte)|c(ase|atch|har|hecked|lass|lone|ompl|onst|ontinue)|de(bugger|cimal|clare|f(ault|er)?|init|l(egate|ete)?)|do|double|e(cho|ls?if|lse(if)?|nd|nsure|num|vent|x(cept|ec|p(licit|ort)|te(nds|nsion|rn)))|f(allthrough|alse|inal(ly)?|ixed|loat|or(each)?|riend|rom|unc(tion)?)|global|goto|guard|i(f|mp(lements|licit|ort)|n(it|clude(_once)?|line|out|stanceof|t(erface|ernal)?)?|s)|l(ambda|et|ock|ong)|m(odule|utable|y)|NaN|n(amespace|ative|ext|ew|il|ot|ull)|o(bject|perator|r|ut|verride)|p(ackage|arams|rivate|rotected|rotocol|ublic)|r(aise|e(adonly|do|f|gister|peat|quire(_once)?|scue|strict|try|turn))|s(byte|ealed|elf|hort|igned|izeof|tatic|tring|truct|ubscript|uper|ynchronized|witch|ub)|t(emplate|hen|his|hrows?|ransient|rue|ry|ype(alias|def|id|name|of))|u(n(checked|def(ined)?|ion|less|signed|til)|se|sing)|v(ar|irtual|oid|olatile)|w(char_t|hen|here|hile|ith)|xor|yield)$/,i="com",s="nam",f="num",u=[[f,/#([0-9a-f]{6}|[0-9a-f]{3})\b/],[i,/(\/\/|#).*?(?=\n|$)/],[i,/\/\*[\s\S]*?\*\//],[i,/<!--[\s\S]*?-->/],["rex",/\/(\\\/|[^\n])*?\//],["str",/(['"`])(\\\1|[\s\S])*?\1/],[f,/[+-]?([0-9]*\.?[0-9]+|[0-9]+\.?[0-9]*)([eE][+-]?[0-9]+)?/],["pct",/[\\.,:;+\-*\/=<>()[\]{}|?!&@~]/],["spc",/\s+/],[s,/[\w$]+/],["unk",/./]];return e(!1,function(e){var t=e.querySelector("head"),n=e.createElement("style");n.textContent=r,t.insertBefore(n,t.firstChild),/^(i|c|loade)/.test(e.readyState)?o():e.addEventListener("DOMContentLoaded",function(){o()})}),o.tok=t,o.el=n,o});
</script>
</body></html>
