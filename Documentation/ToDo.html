<!doctype html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-touch-fullscreen" content="yes" />
<meta name="google" content="notranslate">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>ToDo</title>
<style>
/* main.css: the place where failure to plan goes to die. */

h1 {
	font-size: 1.5em;
}

.shimclear {
	height: 6px;
	float: none;
}

#help {display:none;}

/* ipadfix out overflow: hidden; in width: 100%*/
html, body {
    overflow: hidden;
	height: 100%;
   /* width: 100%*/
}

body {
	background: #fafafa;
	font: normal .8em/1.5em Arial, Helvetica, sans-serif;
	min-width: 800px;
	margin-left: 1%;
	margin-right: 0.5%;
	margin-top: 0;
	margin-bottom: 0;
	/* Experimental, trying to get word breaks on iPad Pro */
	/* Doesn't help: overflow-wrap: break-word; */
	/* Works, but breaks on everything: word-break: break-all; */
}

/* ipadfix adding a wrapper around entire body */
#bodywrapper {
	position: fixed; height:100%; width:100%; top:0; left:0;
}

#pageContent {
	height: 100%;
}

a {
text-decoration: none;
}

a:link {
color: Black;
border-bottom: 1px solid #AAA;
}

a:visited {
color: #333;
border-bottom: 1px solid #AAA;
}

a:hover {
color: #333;
border-bottom: 1px solid #333;
}

/* File tree displays, suppress underlines on links. */
UL.jqueryFileTree A {
	border-bottom: none;
}

/* ipadfix adding wrapper around fixed top part */
#fixed_header {
	position: absolute; top:0; left:0; width:100%; height: 200px; z-index:10;
	}

#nav {
	position: relative;
	display: block;
	margin: 0;
	margin-top: 8px;
	padding: 7px 6px 0;
	line-height: 100%;
	border-radius: .4em;

	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .4);

	/*background: -webkit-gradient(linear, left top, left bottom, from(#a9a9a9), to(#7a7a7a));*/
	background: -webkit-gradient(linear, left top, left bottom, from(#999999), to(#333333));

	border: solid 1px #6d6d6d;
	min-width:770px;
}
#nav li {
	margin: 0 5px;
	padding: 0 0 8px;
	float: left;
	position: relative;
	list-style: none;
}
/* main level link */
#nav a {
	font-weight: bold;
	color: #e7e5e5;
	text-decoration: none;
	border-bottom: none;
	display: block;
	padding:  8px 15px;
	margin: 0;
	-webkit-border-radius: .4em;
	-moz-border-radius: .4em;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .3);
}
/* main level link hover */
#nav .current a, #nav li:hover > a {
	background: -webkit-gradient(linear, left top, left bottom, from(#ebebeb), to(#a1a1a1)); /* for webkit browsers */
	border-top: solid 1px #f8f8f8;
	-webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	-moz-box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	box-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	text-shadow: 0 1px 0 rgba(255, 255, 255, .8);
}

#nav li:hover > a {
	color: #444;
}

#nav .current a, #nav .current:hover > a {
	color: #008000; /*#31540c*/
}

/* sub levels link hover */
#nav ul li:hover a, #nav li:hover li a {
	background: none;
	border: none;
	color: #666;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
}
#nav ul a:hover {
	background: -webkit-gradient(linear, left top, left bottom, from(#04acec), to(#0186ba)) !important; /* for webkit browsers */

	color: #fff !important;
	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	text-shadow: 0 1px 1px rgba(0, 0, 0, .1);
}
/* level 2 list */
#nav ul {
	background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#cfcfcf)); /* for webkit browsers */

	display: none;
	margin: 0;
	padding: 0;
	width: 185px;
	position: absolute;
	top: 35px;
	left: 0;
	border: solid 1px #b4b4b4;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;
	-webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	-moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
	box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
}
/* dropdown */
#nav li:hover > ul {
	display: block;
}
#nav ul li {
	float: none;
	margin: 0;
	padding: 0;
}
#nav ul a {
	font-weight: normal;
	text-shadow: 0 1px 1px rgba(255, 255, 255, .9);
}
/* level 3+ list */
#nav ul ul {
	left: 181px;
	top: -3px;
}
/* rounded corners for first and last child */
#nav ul li:first-child > a {
	-webkit-border-top-left-radius: 9px;
	-moz-border-radius-topleft: 9px;
	-webkit-border-top-right-radius: 9px;
	-moz-border-radius-topright: 9px;
}
#nav ul li:last-child > a {
	-webkit-border-bottom-left-radius: 9px;
	-moz-border-radius-bottomleft: 9px;
	-webkit-border-bottom-right-radius: 9px;
	-moz-border-radius-bottomright: 9px;
}
/* clearfix */
#nav:after {
	content: ".";
	display: block;
	clear: both;
	visibility: hidden;
	line-height: 0;
	height: 0;
}
#nav {
	display: inline-block;
}
html[xmlns] #nav {
	display: block;
}
* html #nav {
	height: 1%;
}
#spinnerParent {
	position: relative;
	display: inline-block;
	width: 43.4px;
	height: 36px;
	margin: 0;
	padding: 0;
}
#spinner {
	position: absolute;
	display: inline-block;
	margin: 0;
	padding: 0;
	top: 0;
	left: 0;
	top: -4px;
	cursor: pointer;
}

#details tr {
	margin: 0;
	padding: 0;
}
#details td {
	margin: 0;
	font-size: 1.0em;
	padding: 0;
}

#details caption {
	font-size: 1.2em;
	font-weight: bold;
}
.yebal, .openingbal {
	font-weight: bold;
	background-color: #CCCCCC;
}
.yebalneg {
	font-weight: bold;
	background-color: #FFCCCC;
}
.monthlybal {
	background-color: #EEEEEE;
}
.monthlybalneg {
	/*font-weight: bold;*/
	background-color: #FFAAAA;
}

.unsupported {
	color: #aaaaaa;
}

/* Scroll support */

/* Transition to new names for scroll support NOTE some classes are now ids */
#headingAboveContents { /* Replaces #searchWhat */
	margin-top: 10px;
	font-size: 1.2em;
}

/* ipadfix */
#scrollAdjustedHeight, #scrollAdjustedHeightDirPicker { /* Replaces #searchresults, #cmdresults, #jumpsandtext */
	/* ipadfix in */
	/*height:calc(100% - 1px); width:100%; margin-top: 200px; z-index: 1;*/
	/* ipadfix not appropriate: overflow-y: scroll; -webkit-overflow-scrolling: touch; */
	
	/* ipadfix out
	position: absolute;
	top: 200px;
	*/
	
	height: 60%;
}

#scrollContentsList { /* Replaces CLASS .jumplist */
	float: left;
	width: 23%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	font-family: helvetica, arial, sans-serif;
	font-size: 1.2em;
	line-height: 1.3em;
	margin-top: 20px;
}

#scrollContentsList a {
	text-decoration: none;
	/*font-size: 1.1em;*/
}

#scrollContentsList li, #scrollContentsList ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

#scrollContentsList li {
	margin-bottom: 6px;
}

#scrollContentsList a:hover {
	color: blue;
	cursor: pointer;
}

#scrollTextRightOfContents { /* Replaces CLASS .theTextWithJumpList */
	float: left;
	width: 75.5%;
	overflow: auto;
	-moz-tab-size: 4;
	tab-size: 4;
/*	height: 100%;
	padding: 4px;
	padding-right: 0;
	font: normal 9pt/12pt Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
*/
}

#scrollText {
	float: left;
	width: 100%;
	-moz-tab-size: 4;
	tab-size: 4;
	/*overflow: auto;*/
/* height 100% does not play well with ace editor.
	height: 100%;
	padding: 4px;
	font: normal 9pt/12pt Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
*/
}

#scrollTextRightOfContents h1, #scrollTextRightOfContents h2, #scrollTextRightOfContents h3, #scrollTextRightOfContents h4 {
	display: inline;
}

#scrollContentsList .h1 {
	font-size: 1.3em;
}

#scrollContentsList .h2 {
	font-size: 1.1em;
}

/* section marker */
#scrollContentsList .h2 a:before {
	font-size: 0.6em;
	content: "\25B0  "; /* "\00A7  " */
	padding-left: 0;
	color: #667766;
}


#scrollContentsList .h3 a:before {
	font-size: 0.6em;
	content: "\25B0  "; /* "\25B0  " */
	padding-left: 8px;
	color: #889988;
}

#scrollContentsList .h3 {
	font-size: 1.0em;
	font-style: italic;
	font-variant: normal;
}

#scrollContentsList .h4 a:before {
	font-size: 0.4em;
	content: "\25B0  "; /* "\25B0\25B0  " */
	padding-left: 24px;
	color: #889988;
}

#scrollContentsList .h4 {
	font-size: .9em;
}

#details {
	height: 100%;
}

/* A bit of formatting for text. */
.Comment_Normal {color: #004221;}
.Comment_POD {color: #004221;}
.Directive {color: #000000;}
.Label {color: #000000;}
.Quote {color: #8A0808;}
.String {color: #8A0808;}
.Subroutine {color: #000000;}
.Variable_Scalar {color: #0101DF;}
.Variable_Array {color: #0101DF;}
.Variable_Hash {color: #0101DF;}
.Variable_Typeglob {color: #0101DF;}
/*.Whitespace {color: #000000;}*/
.Character {color: #000000;}
.Keyword {color: #A020F0;}
.Builtin_Function {color: #000000;}
.Builtin_Operator {color: #000000;}
.Operator {color: #000000;}
.Bareword {color: #000000;}
.Package {color: #000000;}
.Number {color: #000000;}
.Symbol {color: #000000;}
.CodeTerm {color: #000000;  font-weight: bold;}
.DATA {color: #000000;}

/* OLDER SCROLL SUPPORT, still valid but not for use with ace editor displays */
#searchresults, #cmdresults {
	height: 60%;
}
#jumpsandtext {
	height: 85%;
	font-family: monospace;
	font-size: 1.2em;
}

.jumplist {
	float: left;
	width: 23%;
	overflow: auto;
	height: 100%;
	padding: 4px;
}

.jumplist a {
	text-decoration: none;
	font-size: 1.1em;
	line-height: 1.2em;
}

.jumplist li, .jumplist ul {
	list-style: none;
	margin: 0;
	padding: 0;
}

.jumplist li {
	margin-bottom: 6px;
}

.jumplist .h2 a:before {
	font-size: 1.2em;
	content: "\25B0";
}

.jumplist .h3 a:before {
	font-size: 1.2em;
	content: "\25B0\25B0";
}

.jumplist a:hover {
	color: blue;
}

.theTextWithJumpList {
	float: left;
	width: 75%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	padding-right: 0;
	/*font-family: Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	font-size: 9pt;
	line-height: 12pt;*/
}

#theTextWithoutJumpList {
	float: left;
	width: 98%;
	overflow: auto;
	height: 100%;
	padding: 4px;
	/*font-family: Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	font-size: 9pt;
	line-height: 12pt;*/
}

.theText {
	font-family: Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	font-size: 9pt;
	line-height: 12pt;
	
	float: none;
	width: 100%;
}

#searchWhat {
	margin-top: 10px;
	font-size: 1.2em;
}

.line_number {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em;
	display: inline-block;
}
a.embedded_image {
	text-decoration: none;
}

.notabene {
	color: Crimson;
	font-size: 0.9em;
}

.textSymbol {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.1em;
}

.textSymbolSmall {
	font-family: "Segoe UI Symbol", monospace;
	font-size: 1.0em;
}

/* A "line break" for long URLs */
.noshow {
	display: inline-block;
	width: 0px;
}

/* Up down left right triangles for navigation. */
.arrow-left {
	display: inline-block;
	width: 0; 
	height: 0;
	margin-left: 16px;
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent; 
	border-right:16px solid #6aa436;
	position: relative;
	top: 10px;
}

.arrow-up {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
 	border-bottom: 16px solid #6aa436;
	position: relative;
	top: -14px;
	left: 8px;
}

.arrow-down {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-left: 16px solid transparent;
	border-right: 16px solid transparent;
	border-top: 16px solid #6aa436;
	position: relative;
	top: 18px;
	left: -24px;
}

.arrow-right {
	display: inline-block;
	width: 0; 
	height: 0; 
	border-top: 16px solid transparent;
	border-bottom: 16px solid transparent;
	border-left: 16px solid #6aa436;
	position: relative;
	top: 10px;
	left: -16px;
}

.img-arrow-left {
	display: inline;
	margin-left: 16px;
	position: relative;
	top: 10px;
}

.img-arrow-up {
	display: inline;
	position: relative;
	top: -24px;
	left: 0;
}

.img-arrow-down {
	display: inline;
	position: relative;
	top: 40px;
	left: -68px;
}

.img-arrow-right {
	display: inline;
	position: relative;
	top: 10px;
	left: -64px;
}

#title-block {
	display: inline-block;
	max-height: 60px;
	overflow: hidden;
	text-align: right;
}


#viewEditTitle {
	margin-right: 12px;
	display: inline-block;
	font-size: 1.4em;
	font-weight: bold;
}

#viewEditDateSize {
	margin-right: 12px;
}

#title-blockTR {
	max-height: 60px;
	overflow: hidden;
}

#title-blockTD {
	max-height: 60px;
	overflow: hidden;
}

#button-block {
	display: inline-block;
	vertical-align: top;
	/*margin-top: 20px;*/
}

/* For the Status page main status tables. */
#tablePageServerStatus th {
	cursor: pointer;
}

#tableBackgroundServerStatus th {
	cursor: pointer;
}

.divAlignCenter {
	display: inline-block;
	vertical-align: middle;
}

#editor_error {
	display: inline-block;
	font-size: 0.5em;
}

/* For the "edit" pencil image, a bit of space on the left. */
.edit_img {
	display: inline-block;
	margin-left: 6px;
}

/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
#theTextWithoutJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.theTextWithJumpList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
.jumplist {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollText {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollTextRightOfContents {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
#scrollContentsList {overflow-y: scroll; -webkit-overflow-scrolling: touch;}
}
</style>
<style>
/* non_cm_test.css: formatting for non-CodeMirror displays presented by the Viewer service. */

#scrollTextRightOfContents {
	/*height: 100%;*/
	padding-right: 0;
	/*font: normal 9pt/12pt Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;*/
	/*font: normal 10pt/13pt Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;*/
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	/*font: normal 9pt/12pt Hack, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;*/
	position: absolute;
	top: 0; left: 24%; right: 0; bottom: 0;

	/* https://css-tricks.com/snippets/css/prevent-long-urls-from-breaking-out-of-container/*/
	
	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollText { /* Replaces #theTextWithoutJumpList */
	/*height: 100%;*/
	/*font: normal 9pt/12pt Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;*/
	font: normal 11pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;

	overflow-wrap: break-word;
	word-wrap: break-word;
	-ms-word-break: break-all;
	word-break: break-word;
}

#scrollTextRightOfContents img, #scrollText img{
	max-width: 100%;
}

/* TOC shrink/expand element */
#tocShrinkExpand {
	position: absolute;
	display: inline-block;
	cursor: pointer;
	margin-right: 5px;
	margin-bottom: 5px;
}

.marker-highlight {
	background-color: lightgreen
}

.scroll-hilite {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: green;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

.initial-hits-highlight {
	background-color: #ffcccc;
}

.initial-scroll-hl {
	display: block;
	position: fixed;
	width: 12px;
	height: 2px;
	/*right: 8px;*/
	right: 0.75%;
	opacity: .5;
	background-color: #990000;
	margin: 0;
	border: 0;
	padding: 0;
	z-index:1000;
	pointer-events: none;
}

div#indicator {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.75%;
    opacity: .5;
    width: 2px;
    height: 20px;
    background-color: #888;
    border: none;
    margin: 0;
    padding: 0;
	pointer-events: none;
}

div#indicatorPC {
    position: absolute;
    z-index: 99;
    top: 0px;
    /*left: 3px;*/
    right: 0.75%;
    /*opacity: .5;*/
    width: 9px;
    height: 20px;
    background-color: #ffdb58; /* #ffe958 or mustard, #ffdb58 */
    border: 1px solid gray; /*none;*/
    margin: 0;
    padding: 0;
	pointer-events: none;
}

/* Some special treatment for index.html files that hold a table of contents.
See intramine_fileviewer_cm.pl#GetPrettyText(). */
#specialScrollTextRightOfContents {
	padding-right: 0;
	position: absolute;
	top: 0; left: 2%; right: 0; bottom: 0;
	overflow: auto;
	/*background-image: url("Coffee-Paper-Texture4.jpg");*/
	-webkit-background-size: cover;
	-moz-background-size: cover;
	-o-background-size: cover;
}

#toc-line {
	font: normal 28px "Baskerville BT", serif;
}

#special-index-wrapper {
	padding-top: 20px;
	height: 100%;
	font: normal 24px "Baskerville BT", serif;
	/*background-color: #E8E3C5;*/
}

#special-index-wrapper th {
	text-align: center;
}

#special-index-wrapper td:not(:first-child) {
	padding-left: 80px;
}

#special-index-wrapper td:nth-child(1) {
	/*background-color: #E8E3C5;*/
	background: transparent;
}

#special-index-wrapper a {
	text-decoration: none;
}

#special-index-wrapper a:link {
	color: Black;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:visited {
	color: #333;
	border-bottom: 1px solid #CCC;
}

#special-index-wrapper a:hover {
	color: #333;
	border-bottom: 1px solid #333;
	background-color: #ECF6CE;
}

/* Glossary links, for glossary popups shown in standalone Gloss HTML files. */
.glossary:link {
	border-bottom: 1px dotted #666;
}

.glossary:link:hover {
	border-bottom: 1px dotted #666;
}

.glossary:link:visited {
	border-bottom: 1px dotted #666;
}

/* Second and subsequent glossary tooltips in Gloss HTML standalone files, suppress underline. */
.term-seen:link {
	border-bottom: 1px dotted #CCC;
}

.term-seen:hover {
	border-bottom: 1px dotted #666;
}

.term-seen:visited {
	border-bottom: 1px dotted #CCC;
}

/* Table of Contents highlight for current item. */
.tocitup {
	background-color: lightgreen;
}

/* Gloss standalone HTML, alignment for "inlined" images. */
.valigntop {
	vertical-align: top;
}
and the entry name in a span with
.inlinespan {
	display:inline-block;
}

#bottomShim {
	margin: 0;
	height: 3px;
	}


/* iPad */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
	#scrollTextRightOfContents {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
	#scrollText {font: normal 10pt Consolas, Lucida Console, Lucida Sans Unicode, Lucida Grande, monospace;}
}

</style>
<style>
/* non_cm_tables.css: for non-CodeMirror table display by the Viewer service. */

table {
	tab-size: 4;
	white-space: pre-wrap;
}

table, tr, td {
	margin: 0;
	border: none;
	border-spacing: 0;
	padding: 0;
}

td {
	vertical-align: top;
	padding-left: 4px;
	/*overflow-wrap: break-word;*/
}

thead {
	overflow-wrap: break-word;
	word-wrap: normal;
	-ms-word-break: normal;
	word-break: normal;
}

/* vertical align middle */
td.vam {
	vertical-align: middle;
}

td:nth-child(1) {
	background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 4em; /* enough for 99999 one hopes */
}

th {
	text-align: left;
}

/* Avoid copy of line numbers in the first column.
<td n='$lineNum'></td>
*/
td:first-child:after, th:first-child:after {
    content: attr(n);
}


h1, h2, h3, h4 {
	font-family: helvetica, arial, sans-serif;
	text-shadow: #9C9C9C 1px 1px 1px;
	color: #002000;
}

h1 {
	color: #305030;
	font-size: 2em;
	line-height: 2em;
	margin: 0;
	padding: 2px;
}

h3 {
	font-style: italic;
}

/* Unordered list items. */
.outdent-unordered {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.outdent-unordered-sub {
	margin: 0;
	padding: 0;
	text-indent: -1.3em;
	padding-left: 2.9em;
	}

.outdent-unordered-continued {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.outdent-unordered-sub-continued {
	margin: 0;
	padding: 0;
	padding-left: 2.9em;
	}

/* Ordered lists, with one or two digits in the main item or sub item, and their
continuation paragraphs. There are twelve possibilities.
Naming: "ol-1-2-c" = ordered list - one digit top level - two digits second - continuation
paragraph (ie not the first paragraph in the item).
"ol-2" = ordered list - two digits top level, no second level, first paragraph.
*/
.ol-1 {
	margin: 0;
	padding: 0;
	text-indent: -1.8em;
	padding-left: 1.8em;
	}

.ol-1-c {
	margin: 0;
	padding: 0;
	padding-left: 1.8em;
	}

.ol-1-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 4.2em;
	}

.ol-1-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.2em;
	}

.ol-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.3em;
	padding-left: 2.3em;
	}

.ol-2-c {
	margin: 0;
	padding: 0;
	padding-left: 2.3em;
	}

.ol-1-2 {
	margin: 0;
	padding: 0;
	text-indent: -2.7em;
	padding-left: 4.6em;
	}

.ol-1-2-c {
	margin: 0;
	padding: 0;
	padding-left: 4.6em;
	}

.ol-2-1 {
	margin: 0;
	padding: 0;
	text-indent: -2.6em;
	padding-left: 4.9em;
}

.ol-2-1-c {
	margin: 0;
	padding: 0;
	padding-left: 4.9em;
	}

.ol-2-2 {
	margin: 0;
	padding: 0;
	text-indent: -3.2em;
	padding-left: 5.6em;
}

.ol-2-2-c {
	margin: 0;
	padding: 0;
	padding-left: 5.6em;
	}


/* Data tables in text */
.bordered {
    border: solid #ccc 1px;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 1px 1px #ccc; 
    -moz-box-shadow: 0 1px 1px #ccc; 
    box-shadow: 0 1px 1px #ccc;
    margin-bottom: 4px;    
}

.bordered tr:hover {
    background: #fbf8e9;
    -o-transition: all 0.1s ease-in-out;
    -webkit-transition: all 0.1s ease-in-out;
    -moz-transition: all 0.1s ease-in-out;
    -ms-transition: all 0.1s ease-in-out;
    transition: all 0.1s ease-in-out;     
}    
    
.bordered td, .bordered th {
    border-left: 1px solid #ccc;
    border-top: 1px solid #ccc;
    padding-top: 2px;
    padding-bottom: 2px;
    text-align: left;    
}

.bordered th {
    background-color: #dce9f9;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#ebf3fc), to(#dce9f9));
    background-image: -webkit-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:    -moz-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:     -ms-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:      -o-linear-gradient(top, #ebf3fc, #dce9f9);
    background-image:         linear-gradient(top, #ebf3fc, #dce9f9);
    -webkit-box-shadow: 0 1px 0 rgba(255,255,255,.8) inset; 
    -moz-box-shadow:0 1px 0 rgba(255,255,255,.8) inset;  
    box-shadow: 0 1px 0 rgba(255,255,255,.8) inset;        
    border-top: none;
    text-shadow: 0 1px 0 rgba(255,255,255,.5); 
}

.bordered td:first-child, .bordered th:first-child {
    border-left: none;
    border-top: none;
    background-color: #F8F8F8;
	color: #808080;
	text-align: right;
	min-width: 3em;
}

.bordered th:first-child {
    -moz-border-radius: 6px 0 0 0;
    -webkit-border-radius: 6px 0 0 0;
    border-radius: 6px 0 0 0;
}

.bordered th:last-child {
    -moz-border-radius: 0 6px 0 0;
    -webkit-border-radius: 0 6px 0 0;
    border-radius: 0 6px 0 0;
}

.bordered th:only-child{
    -moz-border-radius: 6px 6px 0 0;
    -webkit-border-radius: 6px 6px 0 0;
    border-radius: 6px 6px 0 0;
}

.bordered tr:last-child td:first-child {
    -moz-border-radius: 0 0 0 6px;
    -webkit-border-radius: 0 0 0 6px;
    border-radius: 0 0 0 6px;
}

.bordered tr:last-child td:last-child {
    -moz-border-radius: 0 0 6px 0;
    -webkit-border-radius: 0 0 6px 0;
    border-radius: 0 0 6px 0;
}

.bordered td:not(:first-child), .bordered th:not(:first-child) {
	padding-left: 4px;
	padding-right: 4px;
}

.bordered td.centered_cell, .bordered th.centered_cell {
	text-align: center;
}

.bordered td.left_cell, .bordered th.left_cell {
	text-align: left;
}

.bordered td.right_cell, .bordered th.right_cell {
	text-align: right;
}

.shrunkrow {
	height: 3pt;
	}
	
.reallyshrunkrow {
	background: #888;
}

.reallyshrunkrow td {
	height: 1px;
	border: none;
	padding: 0;
	}

.codehere {
	background-color: #ECF6CE; /*#dce9f9 light blue,  #F7F8E0 light yellow, #E1F5A9 light green, #ECF6CE lighter green*/
}
</style>
<style>
/* tooltip.css: for popup hints and images, see also tooltip.js. */

#hintbox{ /*CSS for pop up hint box */
position:absolute;
top: 0;
background-color: lightyellow;
width: 150px; /*Default width of hint.*/ 
padding: 3px;
border:1px solid black;
font:normal 11px Verdana;
line-height:18px;
z-index:100;
border-right: 3px solid black;
border-bottom: 3px solid black;
visibility: hidden;
}

.hintanchor{ /*CSS for link that shows hint onmouseover (no longer used)*/
font-weight: bold;
color: navy;
margin: 3px 8px;
}
.plainhintanchor { /* looks like ordinary text */
	text-decoration: none;
	font-family: arial, helvetica, sans-serif; font-size:100%;
	color: black;
}
.hintanchor:hover {
    border-top-style: hidden;
}
.plainhintanchor:hover {
    border-top-style: hidden;
}
.invisiblehintanchor:hover {
	border-top-style: hidden;
}
</style>
</head>
<body>
<!-- added for touch scrolling, an indicator -->
<div id="indicator"></div>
<hr id="rule_above_editor" />
<div id='scrollAdjustedHeight'>
<div id='scrollContentsList'><li class='h2' im-text-ln='1'><a href='#top-of-document'>TOP</a></li>
<ul>
<li class='h1' im-text-ln='1'><a href='#ToDo'>ToDo</a></li>
<li class='h2' im-text-ln='16'><a href='#ToDo_features'>ToDo features</a></li>
<li class='h2' im-text-ln='28'><a href='#Server-Sent_Events_for_ToDo_changes'>Server-Sent Events for ToDo changes</a></li>
<li class='h2' im-text-ln='42'><a href='#API'>API</a></li>
<li class='h3' im-text-ln='46'><a href='#Get_ToDo_items'>Get ToDo items</a></li>
<li class='h3' im-text-ln='54'><a href='#Save_ToDo_items'>Save ToDo items</a></li>
<li class='h3' im-text-ln='64'><a href='#Broadcast_overdue_count'>Broadcast overdue count</a></li>
<li class='h3' im-text-ln='73'><a href='#Get_ToDo_timestamp'>Get ToDo timestamp</a></li></ul></div><div id='scrollTextRightOfContents'><table><span id='top-of-document'></span><tr id='R1'><td n='1'></td><td><h1 id="ToDo">ToDo</h1></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R3'><td n='3'></td><td><span href='./C:/perlprogs/IntraMine/Documentation/images/2020-03-11 14_09_25-To Do.png' onmouseOver="showhint('<img src=&quot;data:image/png;base64,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&quot;  />', this, event, '500px', true);"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIHIwWU3GsAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI8SURBVDhPbZJrSNNhFMZ/q4lp5cwuSK6LZX5IbaWFKISSFtmFvoSXUSjS
tLKkSAoCgwqxLL+UUsYi+2CoqTmslqQtU4uUDCGFLLykGfMvpsuVmrjev040th8ceHk4z8M5hxeZ
7m+4tdZwaMNaVNOCndIsVB1lZFZlk7zOh0V22Tnj477HWoyKvtyTVG30xk9IClMJSvNL9J/eu9q+
NLtOVWZTYMxjvzGHyKILhN1OJ/haEgGJ0XhS0BC+9O9E2Md3VUi30hhI3kOjegWB9XkEWE1Yeiqx
DdZgq8imS7cX/VZfLm7fREaQL2ma9aSolxPExJ97Owet/v0Nj5HyMpBOHWQgJoS6Zj2GiXpscrUX
Y/VYwm4xoYuoBfNKIQpGhioSh0fXmOvLRchppMs6hjLjGf7+hMnZkKKrNIpW+V5zxvm0tN1N7+xa
2Wl8QN8NHf2pMfTnn8EyVjcTMPYG2yUtX2+mUN1QTIXF7JlzLl0dKKxzYSGaZaqoSHaEbiFms5rD
ft5om+7QMTvFh4dMno/lZ1YS0ov7DAyPqMxxCatShVWeygE5WdFaQvDv1/ySAwafMxmhoSk+AvOV
o0iGAqTezy59cbGLo+z9jth6UPQayJcDrK+YykykRcih0RoKxUrmZ3qk6qc0enniM+NwwtsifCy1
/Bg1MXX9BO3ubuwT8kJ3FN7iPxSW5tK9K5w0oSmnDc5oe8SRrjKsZ7XUKpVECGl+s5f/auQ1/vvV
Dhw/wDYPNxLEUx7X6eEcgX8MB93QHHZJTQAAAABJRU5ErkJggg==
" width='17' height='12'  />2020-03-11 14_09_25-To Do.png<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAMCAYAAACEJVa/AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAAAd0SU1FB9kKDwIIFtS/BIcAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjEuNWRHWFIAAAI1SURBVDhPlZFfSFNhGMafbdSESmLIwkFNN7DozxEnDJYlLPojDgPLmUGI
JVpJRRlTYUGYLhixmgktukk2oX8Ysgt1E8Vm0MqLabKLZOC02qFzcNuFbcuGp2/HMzC0i37w8PE9
vO/zvS8f/kUFhdyh+2j+8hZmZwe2CTbPscPYFfLBEJiDlDcaKyCzNOLgk1sofdUG3cgD6IfsqPLa
8HIukLManNzK0V7YuAWISLlIo4LG0Qrf7Kg4nEgV1vAhSjlKilW4XFyAaxo1TCVq3LlxGk7PQ3xn
RsF9dYNbHkfMZUa+SoGyqwbMPm0FExgHk07rfe7pE/yU/AtE4nWSUmrUhQaQWJkEl9GIFc4qLaZv
VoN91g72gxtsNEmFV1IOLanfQDYw321DIBsSeoHfbUbEOpsQJZOwH4fBJhJFkXj0jZHvEhA5eovK
lhal9rE+DFouwmNpQDjlWwtJToDruoTYFQPonhZEPP34Nh9WhqZmHE1CP4+k8+6ebiYi/TH4GMy9
erAmI+IzLqSz0wxb4S+Q49wBJc7qKJw6fhKl+7SyXKGfR9R+e0f9YlBMv34E1nwebO0R0HoKU3Ev
VjMhyxNgvHYoMrWCNiLbif3vxxAc6AXbUQu6/BAcxNZZWxBMvQP3i6wWcsFEvM0DBKQXqtHdb8F8
TTl6yD2PSLI9B2fIjywkSdCSB5/9z/HXCpsh36uAnpzrC7dIJKjsasaniBs//X04Kvj/TebbC3fn
oeF6JdRrVgbgD8K63nrr6C+tAAAAAElFTkSuQmCC
" width='17' height='12'  /></span></td></tr>
<tr id='R4'><td n='4'></td><td></td></tr>
<tr id='R5'><td n='5'></td><td>The ToDo server provides a simple Kanban-style todo list, with just enough features to make it useful. Most of it is done in JavaScript.</td></tr>
<tr id='R6'><td n='6'></td><td></td></tr>
<tr id='R7'><td n='7'></td><td>Main Perl file:</td></tr>
<tr id='R8'><td n='8'></td><td>intramine_todolist.pl</td></tr>
<tr id='R9'><td n='9'></td><td></td></tr>
<tr id='R10'><td n='10'></td><td>Main JavaScript files:</td></tr>
<tr id='R11'><td n='11'></td><td>todo.js</td></tr>
<tr id='R12'><td n='12'></td><td>todoEvents.js</td></tr>
<tr id='R13'><td n='13'></td><td>todoGetPutData.js</td></tr>
<tr id='R14'><td n='14'></td><td>jquery.min.js</td></tr>
<tr id='R15'><td n='15'></td><td></td></tr>
<tr id='R16'><td n='16'></td><td><h2 id="ToDo_features">ToDo features</h2></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R18'><td n='18'></td><td>Use the "Add/Edit a Task" area to enter the title, description, and date for a new task. Description and date are optional. Drag an existing task back here to edit it.</td></tr>
<tr id='R19'><td n='19'></td><td></td></tr>
<tr id='R20'><td n='20'></td><td>All tasks can be dragged around, both between lists and within one list. As you start dragging a task a "Drag Here to Delete" box will appear over on the right: drop a task there to delete it.</td></tr>
<tr id='R21'><td n='21'></td><td></td></tr>
<tr id='R22'><td n='22'></td><td>Simple enough, right? If you enthusiastically add a large number of tasks then the view will scroll, but it's best not to have so many tasks that scrolling is needed.</td></tr>
<tr id='R23'><td n='23'></td><td></td></tr>
<tr id='R24'><td n='24'></td><td>I wrote very little of this on the JavaScript side, and so I'll leave it to you to go through todo.js if you want an understanding of the basic ToDo list.</td></tr>
<tr id='R25'><td n='25'></td><td></td></tr>
<tr id='R26'><td n='26'></td><td>However, there's one problem to address that the original doesn't handle, and that's what to do if one person updates the ToDo list and other people are viewing the ToDo list on other computers at the same time. Ideally the views in all open ToDo browser tabs should refresh when anyone does a Save or even just drags items around. This is handled in todoEvents.js, which implements <a class='glossary' href="#" onmouseover="showhint('<p>Server-Sent Events: (SSE for short) basically, a web page subscribes to a service for specific events, and the service publishes messages to the subscribed pages. In IntraMine for example, all open ToDo pages request to be notified of &quot;todochanged&quot; events that are sent when any open ToDo page changes, and in response they reload the ToDo page (see js_for_web_server/todoEvents.js), keeping all open ToDo pages synchronized.</p>', this, event, '500px', false);">Server-Sent Events</a> so that all open ToDo browser tabs can signal a change has happened, and respond to a change by refreshing the view, as outlined below.</td></tr>
<tr id='R27'><td n='27'></td><td></td></tr>
<tr id='R28'><td n='28'></td><td><h2 id="Server-Sent_Events_for_ToDo_changes"><a class='glossary term-seen' href="#" onmouseover="showhint('<p>Server-Sent Events: (SSE for short) basically, a web page subscribes to a service for specific events, and the service publishes messages to the subscribed pages. In IntraMine for example, all open ToDo pages request to be notified of &quot;todochanged&quot; events that are sent when any open ToDo page changes, and in response they reload the ToDo page (see js_for_web_server/todoEvents.js), keeping all open ToDo pages synchronized.</p>', this, event, '500px', false);">Server-Sent Events</a> for ToDo changes</h2></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R30'><td n='30'></td><td><p class="ol-1">1. User saves a ToDo item, or drags a ToDo item around.</p></td></tr>
<tr id='R31'><td n='31'></td><td><p class="ol-1">2. todo.js calls todoGetPutData.js#putData() to save the changes</p></td></tr>
<tr id='R32'><td n='32'></td><td><p class="ol-1">3. putData() calls intramine_todolist.pl#PutData() to write the changed ToDo data to disk</p></td></tr>
<tr id='R33'><td n='33'></td><td><p class="ol-1">4. PutData() also calls swarmserver.pm#BroadcastSSE('todochanged'...) when it's done</p></td></tr>
<tr id='R34'><td n='34'></td><td><p class="ol-1">5. BroadcastSSE() sends a request to the <a class='glossary term-seen' href="#" onmouseover="showhint('<p>Server-Sent Events: (SSE for short) basically, a web page subscribes to a service for specific events, and the service publishes messages to the subscribed pages. In IntraMine for example, all open ToDo pages request to be notified of &quot;todochanged&quot; events that are sent when any open ToDo page changes, and in response they reload the ToDo page (see js_for_web_server/todoEvents.js), keeping all open ToDo pages synchronized.</p>', this, event, '500px', false);">Server-Sent Events</a> server, SSE (intramine_SSE.pl)</p></td></tr>
<tr id='R35'><td n='35'></td><td><p class="ol-1">6. intramine_SSE.pl#HandleBroadcastRequest() is called in response to its only %RequestAction, $RequestAction{'signal'} = \&amp;HandleBroadcastRequest;</p></td></tr>
<tr id='R36'><td n='36'></td><td><p class="ol-1">7. HandleBroadcastRequest() requests an SSE broadcast by calling swarmserver.pm#SendEventToClients()</p></td></tr>
<tr id='R37'><td n='37'></td><td><p class="ol-1">8. Previously when any ToDo browser page was opened it registered to receive <a class='glossary term-seen' href="#" onmouseover="showhint('<p>Server-Sent Events: (SSE for short) basically, a web page subscribes to a service for specific events, and the service publishes messages to the subscribed pages. In IntraMine for example, all open ToDo pages request to be notified of &quot;todochanged&quot; events that are sent when any open ToDo page changes, and in response they reload the ToDo page (see js_for_web_server/todoEvents.js), keeping all open ToDo pages synchronized.</p>', this, event, '500px', false);">Server-Sent Events</a>, with todEvents.js#getSSEPortAndRequestEvents(). That set up a socket on which the page can receive messages</p></td></tr>
<tr id='R38'><td n='38'></td><td><p class="ol-1">9. So SendEventToClients() broadcasts the message out to all clients (browser pages) that have registered to receive <a class='glossary term-seen' href="#" onmouseover="showhint('<p>Server-Sent Events: (SSE for short) basically, a web page subscribes to a service for specific events, and the service publishes messages to the subscribed pages. In IntraMine for example, all open ToDo pages request to be notified of &quot;todochanged&quot; events that are sent when any open ToDo page changes, and in response they reload the ToDo page (see js_for_web_server/todoEvents.js), keeping all open ToDo pages synchronized.</p>', this, event, '500px', false);">Server-Sent Events</a></p></td></tr>
<tr id='R39'><td n='39'></td><td><p class="ol-2">10. The ToDo page's SSE listener, previously set up in getSSEPortAndRequestEvents(), responds to the 'todochanged' message by calling todoGetPutData.js#getToDoData()</p></td></tr>
<tr id='R40'><td n='40'></td><td><p class="ol-2">11. getToDoData() calls back to intramine_todolist.pl#GetData() with an XMLHttpRequest containing "req=getData", and refreshes the displayed ToDo page.</p></td></tr>
<tr id='R41'><td n='41'></td><td></td></tr>
<tr id='R42'><td n='42'></td><td><h2 id="API">API</h2></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R44'><td n='44'></td><td>For details on the refresh that is broadcasted when the ToDo page changes, see the section just above, <a href="#Server-Sent_Events_for_ToDo_changes">"Server-Sent Events for ToDo changes</a>".</td></tr>
<tr id='R45'><td n='45'></td><td></td></tr>
<tr id='R46'><td n='46'></td><td><h3 id="Get_ToDo_items">Get ToDo items</h3></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R48'><td n='48'></td><td><strong>Action</strong>: get JSON for all ToDo items (To Do, Doing, Done)</td></tr>
<tr id='R49'><td n='49'></td><td><strong>Request</strong>: /?req=getData</td></tr>
<tr id='R50'><td n='50'></td><td><strong>Response</strong>: full contents of the ToDo data file (JSON)</td></tr>
<tr id='R51'><td n='51'></td><td><strong>For example</strong>: /?req=getData is it, really</td></tr>
<tr id='R52'><td n='52'></td><td><strong>See also</strong>: intramine_todolist.pl#GetData(), todo.js</td></tr>
<tr id='R53'><td n='53'></td><td></td></tr>
<tr id='R54'><td n='54'></td><td><h3 id="Save_ToDo_items">Save ToDo items</h3></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R56'><td n='56'></td><td><strong>Action</strong>: save JSON for all ToDo items</td></tr>
<tr id='R57'><td n='57'></td><td><strong>Request</strong>: POST (no URL)</td></tr>
<tr id='R58'><td n='58'></td><td>with contents</td></tr>
<tr id='R59'><td n='59'></td><td>data=[all ToDo items in JSON format]</td></tr>
<tr id='R60'><td n='60'></td><td><strong>Response</strong>: empty string, or error message if data could not be saved</td></tr>
<tr id='R61'><td n='61'></td><td><strong>For example</strong>: see todoGetPutData.js#putData()</td></tr>
<tr id='R62'><td n='62'></td><td><strong>See also</strong>: intramine_todolist.pl#PutData(), todo.js</td></tr>
<tr id='R63'><td n='63'></td><td></td></tr>
<tr id='R64'><td n='64'></td><td><h3 id="Broadcast_overdue_count">Broadcast overdue count</h3></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R66'><td n='66'></td><td><strong>Action</strong>: broadcast a signal to all page services, the number of items overdue</td></tr>
<tr id='R67'><td n='67'></td><td><strong>Request</strong>: /?signal=allServersUp or /?signal=dayHasChanged</td></tr>
<tr id='R68'><td n='68'></td><td><strong>Response</strong>: request Main to broadcast "signal=todoCount&amp;count=$overdueCount&amp;name=PageServers"</td></tr>
<tr id='R69'><td n='69'></td><td>where $overdueCount is the number of ToDo items overdue</td></tr>
<tr id='R70'><td n='70'></td><td><strong>For example</strong>: Main broadcasts a "dayHasChanged" at midnight - see intramine_main.pl#HandleDateChange()</td></tr>
<tr id='R71'><td n='71'></td><td><strong>See also</strong>: intramine_todolist.pl#HandleToDoSignal()</td></tr>
<tr id='R72'><td n='72'></td><td></td></tr>
<tr id='R73'><td n='73'></td><td><h3 id="Get_ToDo_timestamp">Get ToDo timestamp</h3></td></tr>
<tr class='shrunkrow'><td></td><td></td></tr>
<tr id='R75'><td n='75'></td><td><strong>Action</strong>: get time of last save of ToDo items</td></tr>
<tr id='R76'><td n='76'></td><td><strong>Request</strong>: /?req=getModDate</td></tr>
<tr id='R77'><td n='77'></td><td><strong>Response</strong>: time of last save of the ToDo data file, as returned by libs\win_wide_filepaths.pm#GetFileModTimeWide()</td></tr>
<tr id='R78'><td n='78'></td><td><strong>For example</strong>: /?req=getModDate is all there is to it</td></tr>
<tr id='R79'><td n='79'></td><td><strong>See also</strong>: intramine_todolist.pl#DataModDate()</td></tr>
<tr id='R80'><td n='80'></td><td></td></tr>
<tr id='R81'><td n='81'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr>
<tr id='R82'><td n='82'></td><td><a href="./contents.html" target="_blank">contents.txt</a></td></tr>
<tr id='R83'><td n='83'></td><td class='vam'><img style='display: block;' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3oAAAADCAIAAABK9Oq7AAAABGdBTUEAALGPC/xhBQAAAAlwSFlz
AAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC45bDN+TgAAADNJREFU
aEPt1rENACAMBDH2ny4lXUZ5hMQIpLN1Q9wKAACMubvZuyRJkqTvvd0EAIARyQF9AZMaj4RsiwAA
AABJRU5ErkJggg==
" width='98%' height='3' /></td></tr></table><p id='bottomShim'></p></div></div>
<script>
let thePath = 'C:/perlprogs/IntraMine/Documentation/ToDo.txt';
let theEncodedPath = 'C:/perlprogs/IntraMine/Documentation/ToDo.txt';
let usingCM = false;
let cmTextHolderName = 'scrollTextRightOfContents';
let specialTextHolderName = 'specialScrollTextRightOfContents';
let theMainPort = '99999';
let mainIP = '99999';
let ourServerPort = '99999';
let peeraddress = '99999';	// ip address of client
let weAreRemote = false;
let errorID = "editor_error";
let highlightItems = [];
let b64ToggleImage = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAYCAYAAAC8/X7cAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFLMAABSzATFtOXUAAAQZSURBVFhH1ZZfTFtVHMd/91/L7VY6/hVG4xgymWUIY5ENkq0jy4wGN3EjMmpI9mCcb0s0PvnnzfiyZCb6YqI+mJCUoRkmc7onXeYSBcxWZkfDMjYR6Ua7Au0dXLn33Hs8pz3BdC1QQpvUT/+l39/J70/POb/+ONggTX1SrQkwBEg/FBgAhcmborEX7CBKvxgAJ4L9+n0mZwXPPrPC/bpwQLTDb3I5NJtWkJi8aagv6rOI+KYxmJwVWRfg9krdWyv4n1s9zU7BSjZuiRlyAfFFfbZ6mpw0Bo3FLOuSVQF7vNK7jh384BHPS/KBbT1MzT3tJb3Q4Tkq01g0JpPXZM0Cmk+DSBx9Xu6Wzr3Q3sXvsrWBai4wa+5ZMmJQbzsIR9uO8WXPiudobJoDM2dk1UvsPgnFgiwNulrkF9t2dUKJ6EroGlbh4vUvITZleEDgYglxsxjY4agRrnUffBMkrighRdE0DN+9AiG/eoU0jJ7VGkbGAnb3WZ6yivj7mlZHU7PrMMicg1kAdFLA9ftDoEYxU3KDXMbBodpuEDkrU8iOkN2+FboKU6PKrWXEHZvo16aZaYW0Ahp6xX0WO3eprq20uq5kH3FoYZYkmDz+MR+vfMslRbydJJSakm4uw+T8Dbg3PB/SFHx8fADdYKYEKasbeqTjshN8dfsrtlTZaomyoS6bNzCYMLs4CZOj0UU1DN7xQf0SM/1XAGldZ4td3PmalhLBLpUztbBQtAhM+RcMZQa/Pe7TP6Ma19EBQni7eL60XjhbWW8DiU9eokJFN1WYvaPC3ITxqfMheodr8IpDlXvFV+0uPu38FSr0Hioz5Fj50Xc8xjCmxck7fZKz9n940VxpzjR34VHAvErO/rS2CJ1bKnmBK/BNwCT/Wb+hK3+ZZ0hH+kSgYiRg3ty2kx9R58yurVW8lUuohYepA4RGkaJG4MTtAfQt1VJ+78ZT4l6xmLtcvV+oFuXC2gqkYgiNGCEUxy8HLiA/k9NvbaPXsoMvwpe3Py80Wh2FUcRyDMOD343Ass51PvlvnDHDei84LKJ0sapFOGJzpi9ZiuC8jBK2igyxwhge3jR+0pB+8o4P0mavVX/inafBYtOlryr2CH2OmtRl4T+MvAxzzudSL19sCkPkttG/JOlv/Pk1aExOYdUCGJz7lPhR6TPCe2W7yVjBVtMC4ve0svFvYC6pbI6G16C0+GlLdKUAsrnRCRPP3zU+Jp3mw6SSmfWGHRy8gN6fmzTOkNaFaAvLN6xNIhLzLZL8B1RKWjKT1bQW9KEv4jO4KzSMHtNWli8SbXIEKfEQfoXGZPKaZD1uBgf0H8jFPfz3r+iBoTIxhyDik/pWH+GOoE//kcnrsqF5mc7i+gLXvhjGY7wAOdsL6ot0mzHq+8l5f20A/gW9of8+fiHTAwAAAABJRU5ErkJggg==';
let selectedTocId = 'tocitup';
//let weAreStandalone = true;
</script>
<script type="text/javascript">
	// Call fn when ready.
	function ready(fn) {
	  if (document.readyState != 'loading'){
	    fn();
	  } else {
	    document.addEventListener('DOMContentLoaded', fn);
	  }
	}

	function getRandomInt(min, max) {
  		return Math.floor(Math.random() * (max - min + 1) + min);
		}
</script>
<script type="text/javascript">
/**
 * debounce.js: //debounce() is (ultimately) from http://underscorejs.org/#debounce.
 */

let JD = {};

JD.debounce = function(func, wait, immediate) {
	let timeout;
	return function() {
		let context = this, args = arguments;
		let later = function() {
			timeout = null;
			if (!immediate)
				{
				func.apply(context, args);
				}
		};
		let callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait || 200);
		if (callNow)
			{
			func.apply(context, args);
			}
	};
};

</script>
<script type="text/javascript">
// tooltip.js: show a "tooltip" with text or an image, the main call is showhint().
/**********************************************************************************************
 * Show Hint script- (c) Dynamic Drive (www.dynamicdrive.com) 
 * This notice MUST stay intact for legal use 
 * Visit http://www.dynamicdrive.com/ for this script and 100s more.
 **********************************************************************************************/
// (Significantly modified from the original 2018-19 for use with IntraMine.)
// IntraMine use, see eg showhint() calls in
// intramine_file_viewer_cm.pl#GetImageFileRep(), intramine_boilerplate.pl#ThePage().

let anchorClassName = "showHintAnchorClass"; 	// applied while mouse over element
let hitAnchorClassName = "invisiblehintanchor"; // applied if not present in element, permanently
let overAnchorTimer = null;
let shMainPort = 0; // See setMainPort() just below.
let shOurServerPort = (typeof ourServerPort !== 'undefined') ? ourServerPort: 0;
let shOnMobile = (typeof window.ontouchstart !== 'undefined') ? true : false;

function setMainPort() {
	shMainPort = (typeof theMainPort !== 'undefined') ? theMainPort: 0;
	}

window.addEventListener("load", setMainPort);


function hasClass(el, className) {
	if (el === null || el.nodeName === "#TEXT" || el.nodeName === "#text")
		{
		return false;
		}
	if (el.classList)
		return el.classList.contains(className)
	else
		return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
}

function addClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.add(className)
		else if (!hasClass(el, className))
			el.className += " " + className
		}
}

function removeClass(el, className) {
	if (el !== null)
		{
		if (el.classList)
			el.classList.remove(className)
		else if (hasClass(el, className))
			{
			let reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
			el.className = el.className.replace(reg, ' ')
			}
		}
}


// Helper function to get an element's exact position
function getPosition(el) {
	"use strict";
	let rect = el.getBoundingClientRect();
	let yPos = rect.top;
	let xPos = rect.left;
	let xScrollTOTAL = 0;
	let yScrollTOTAL = 0;

	while (el)
		{
		if (el.tagName === "BODY")
			{
			// deal with browser quirks with body/window/document and page scroll
			let xScroll = el.scrollLeft || document.documentElement.scrollLeft;
			let yScroll = el.scrollTop || document.documentElement.scrollTop;
			xScrollTOTAL += xScroll;
			yScrollTOTAL += yScroll;
			}
		else
			{
			// for all other non-BODY elements
			xScrollTOTAL += el.scrollLeft;
			yScrollTOTAL += el.scrollTop;
			}

		el = el.offsetParent;
		}
	return {
		x : xPos,
		y : yPos,
		sx : xScrollTOTAL,
		sy : yScrollTOTAL
	};
}

let ie = document.all;
let ns6 = document.getElementById && !document.all;

let dropmenuobj = {};
let loadParams = {};

function positionAndShowHint() {
	"use strict";
	let menucontents = loadParams.menucontents;
	let x = loadParams.x;
	let y = loadParams.y;
	let tipwidth = loadParams.tipwidth;
	let isAnImage = loadParams.isAnImage;
	let gap = 10; // gap between cursor and tip
	let windowHeight = window.innerHeight - gap;
	let windowWidth = window.innerWidth - gap;
	let hintWidth = 450;
	let hintHeight = dropmenuobj.offsetHeight;
	if (isAnImage)
		{
		hintWidth = loadParams.theImage.width;
		hintHeight = loadParams.theImage.height;
		}
	else
		{
		if (tipwidth !== "")
			{
			hintWidth = parseInt(tipwidth, 10);
			}
		}

	// Calculate tip all four ways, pick the way that produces least shrinkage.
	// Preference order below, above, right, left.
	let ds = bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight);
	let bestDirection = ds.bestDirection;
	let scaleFactor = ds.scaleFactor;
	
	// For now, just scale images. Text tips are usually small enough.
	if (isAnImage)
		{
		if (scaleFactor < 1.0)
			{
			let finalScaleFactor = scaleFactor * 0.95;; //temp[bestDirection] * 0.95;
			hintWidth = Math.floor(hintWidth * finalScaleFactor);
			hintHeight = Math.floor(hintHeight * finalScaleFactor);
			}
		}

	// Position tip (and scale if image).
	// Try to keep tip close to mouse x,y position.
	let tl = tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap);
	dropmenuobj.style.top = tl.top;
	dropmenuobj.style.left = tl.left;
	
	if (isAnImage)
		{
		menucontents =
				menucontents.slice(0, -1) + " width='" + hintWidth + "' height='" + hintHeight
						+ "'>";
		}

	dropmenuobj.innerHTML = menucontents;

	// Set width and height for an image. For text, set the desired width and let it flow.
	// dropmenuobj.style.width = hintWidth + "px";
	if (isAnImage)
		{
		dropmenuobj.style.height = hintHeight + "px";
		dropmenuobj.style.width = hintWidth + "px";
		}
	else
		{
		dropmenuobj.style.height = '';
		}

	dropmenuobj.style.visibility = "visible";

}

//Calculate tip all four ways, pick the way that produces least shrinkage.
//Preference order: below, above, right, left.
function bestDirectionAndScale(x, y, hintWidth, hintHeight, windowWidth, windowHeight) {
	// Below:
	let heightAvailable = windowHeight - y;
	let widthAvailable = windowWidth;
	let belowScaleFactor = heightAvailable / hintHeight;
	if (belowScaleFactor > widthAvailable / hintWidth)
		{
		belowScaleFactor = widthAvailable / hintWidth;
		}
	// Above:
	heightAvailable = y;
	let aboveScaleFactor = heightAvailable / hintHeight;
	if (aboveScaleFactor > widthAvailable / hintWidth)
		{
		aboveScaleFactor = widthAvailable / hintWidth;
		}
	// Right:
	heightAvailable = windowHeight;
	widthAvailable = windowWidth - x;
	let rightScaleFactor = heightAvailable / hintHeight;
	if (rightScaleFactor > widthAvailable / hintWidth)
		{
		rightScaleFactor = widthAvailable / hintWidth;
		}
	// Left:
	widthAvailable = x;
	let leftScaleFactor = heightAvailable / hintHeight;
	if (leftScaleFactor > widthAvailable / hintWidth)
		{
		leftScaleFactor = widthAvailable / hintWidth;
		}
	
	// Largest scaleFactor wins, preferring in order below, above, right, left where
	// there's a tie or values are above 1.0.
	let temp = [];
	temp[0] = (belowScaleFactor > 1.0) ? 1.0 : belowScaleFactor;
	temp[1] = (aboveScaleFactor > 1.0) ? 1.0 : aboveScaleFactor;
	temp[2] = (rightScaleFactor > 1.0) ? 1.0 : rightScaleFactor;
	temp[3] = (leftScaleFactor > 1.0) ? 1.0 : leftScaleFactor;
	// bestDirection:
	// 0 == show hint below cursor x,y
	// 1 == show hint above
	// 2 == show hint to right of cursor
	// 3 == show hint to left of cursor
	let bestDirection = -1;
	let i = 0;
	for (i = temp.length - 1; i >= 0; i -= 1)
		{
		if (temp[i] >= 1.0)
			{
			bestDirection = i;
			}
		}
	
	if (bestDirection < 0) // all temp[] are < 1.0
		{
		let curValue = temp[0];
		bestDirection = 0;
		for (i = 1; i < temp.length; i++)
			{
			if (temp[i] > curValue)
				{
				curValue = temp[i];
				bestDirection = i;
				}
			}
		}

	let ds = {};
	ds.bestDirection = bestDirection;
	ds.scaleFactor = temp[bestDirection];
	return(ds);
}

// Position tip (and scale if image).
// Try to keep tip close to mouse x,y position.
function tipTopAndLeft(bestDirection, x, y, hintWidth, hintHeight, windowWidth, windowHeight, gap) {
	let left = 0;
	let top = 0;
	
	if (bestDirection === 0) // below
		{
		top = y + gap + "px";
		left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? "0" : left + "px";
		}
	else if (bestDirection === 1) // above
		{
		if (y - hintHeight - gap >= 0)
			{
			top = y - hintHeight - gap + "px";
			}
		else
			{
			top = "0";
			}
		let left = (x + gap + hintWidth <= windowWidth) ? (x + gap) : windowWidth - hintWidth - gap;
		left = (left < 0) ? "0" : left + "px";
		}
	else if (bestDirection === 2) // right
		{
		left = x + gap + "px";
		let top =
				(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight
						- gap;
		top = (top < 0) ? "0" : top + "px";
		}
	else
		// if (bestDirection === 3) // left
		{
		if (x - hintWidth - gap >= 0)
			{
			left = x - hintWidth - gap + "px";
			}
		else
			{
			dropmenuobj.style.left = "0";
			}
		let top =
				(y + gap + hintHeight <= windowHeight) ? (y + gap) : windowHeight - hintHeight
						- gap;
		top = (top < 0) ? "0" : top + "px";
		}

	let topLeft = {};
	topLeft.top = top;
	topLeft.left = left;

	return(topLeft);
}

function showhint(menucontents, obj, e, tipwidth, isAnImage) {
	"use strict";
	
	setTimeout(function() {
	showWithFreshPort(menucontents, obj, e, tipwidth, isAnImage);
	}, 100);
}

// Special handling for some images: if menucontents looks like
//<img src="http://192.168.1.132:81/Viewer/imagefile.png">
// then we take what's in the "81" position as IntraMine's Main port, and what's in
// the "Viewer" spot as a Short name. Then call back to the Main port requesting a free
// port for the Short name, and replace the "81" in menucontents with the free port number.
// Also strip out the Short name, it was needed only to tell Main which server we wanted.
// For other img src values, just pass them along to showhinAfterDelay unchanged.
// (The fancy footwork with the port is an attempt to get the port number of a service that is
// running and not under maintenance. This allows showhint to show the image if there are two
// or more instances of a service running, even if one is doing maintenance.)
function showWithFreshPort(menucontents, obj, e, tipwidth, isAnImage) {
	if (isAnImage)
		{
		let arrayMatch = /src='([^']+)'/.exec(menucontents);
		if (arrayMatch === null)
			{
			arrayMatch = /src="([^"]+)"/.exec(menucontents);
			}
		if (arrayMatch === null)
			{
			arrayMatch = /src=\&quot\;(.+)\&quot\;/.exec(menucontents);
			}
		if (arrayMatch !== null)
			{
			let image_url = arrayMatch[1];
			let urlMatch = /^http\:\/\/([0-9\.]+)\:(\d+)\/([A-Za-z_]+)\/(.+?)$/.exec(image_url);
			if (urlMatch !== null)
				{
				let ip = urlMatch[1];
				let port = urlMatch[2];
				let shortName = urlMatch[3];
				let path = urlMatch[4];
				
				if (port === shMainPort) // request good port number from shMainPort
					{
					// However, if we're on an iPad (shOnMobile), try to use our current server's
					// port rather than asking Main to supply a fresh one - Apple really doesn't
					// like any hanky panky with the port number.
					if (shOnMobile && port === shMainPort && shOurServerPort !== 0)
						{
						let rePort = new RegExp(port);
						menucontents = menucontents.replace(rePort, shOurServerPort);
						let reName = new RegExp(shortName + "\/");
						menucontents = menucontents.replace(reName, "");
						showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
						}
					else
						{
						let request = new XMLHttpRequest();
						let theRequest = 'http://' + ip + ':' + port + '/' +
											shortName + '/?req=portNumber';
						request.open('get', theRequest, true);
						
						request.onload =
								function() {
									if (request.status >= 200 && request.status < 400)
										{
										// Success?
										let resp = request.responseText; // port number for shortName
										if (!isNaN(resp))
											{
											// Replace port with resp in menucontents. And remove
											// server short name.
											let rePort = new RegExp(port);
											menucontents = menucontents.replace(rePort, resp);
											let reName = new RegExp(shortName + "\/");
											menucontents = menucontents.replace(reName, "");
											showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
											}
										}
								};
						
						request.send();
						}
					}
				else // use supplied port as-is
					{
					showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
					}
				}
			else
				{
				showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
				}
			}
		else
			{
			showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
			}
		}
	else
		{
		showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage);
		}
	}

function showhintAfterDelay(menucontents, obj, e, tipwidth, isAnImage) {
	"use strict";
	
	let image_url = "";
	if (isAnImage)
		{
		let arrayMatch = /src='([^']+)'/.exec(menucontents);
		if (arrayMatch === null)
			{
			arrayMatch = /src="([^"]+)"/.exec(menucontents);
			}
		if (arrayMatch === null)
			{
			arrayMatch = /src=\&quot\;(.+)\&quot\;/.exec(menucontents);
			}
		if (arrayMatch === null)
			{
			arrayMatch = /src=\&apos\;(.+)\&apos\;/.exec(menucontents);
			}
		if (arrayMatch !== null)
			{
			image_url = arrayMatch[1];
			}
		}

	dropmenuobj = document.getElementById("hintbox");
	dropmenuobj.innerHTML = menucontents;
	
	if (overAnchorTimer !== null)
		{
		window.clearTimeout(overAnchorTimer);
		overAnchorTimer = null;
		}

	if (document.getElementById("hintbox"))
		{
		if (!hasClass(obj, hitAnchorClassName))
			{
			addClass(obj, hitAnchorClassName);
			}
		addClass(obj, anchorClassName);

		// Check if mouse is still over element (which must have
		// class hintanchor or plainhintanchor)
		let stillOver = mouseStillOverTipOwner(obj);

		if (!stillOver)
			{
			dropmenuobj.style.visibility = "hidden";
			dropmenuobj.style.left = "-500px";
			removeClass(obj, anchorClassName);
			return;
			}

		dropmenuobj.style.left = "-500px";
		dropmenuobj.style.top = "-500px";
		if (tipwidth === "")
			{
			tipwidth = "300px";
			}
		dropmenuobj.widthobj = dropmenuobj.style;
		if (dropmenuobj.innerHTML.indexOf('<img') == 0)
			{
			dropmenuobj.style.backgroundColor = 'lightyellow';
			dropmenuobj.style.border = 'thin dotted black';
			}
		dropmenuobj.style.width = tipwidth;
		if (!isAnImage)
			{
			// Reset height to 'auto'.
			dropmenuobj.style.height = '';
			}

		loadParams.menucontents = menucontents;
		loadParams.x = e.clientX;
		loadParams.y = e.clientY;
		loadParams.tipwidth = tipwidth;
		loadParams.isAnImage = isAnImage;
		
		if (image_url !== "")
			{
			let my_image = new Image();
			my_image.onload = function() {
				positionAndShowHint();
			};
			my_image.src = image_url;
			loadParams.theImage = my_image;
			}
		else
			{
			positionAndShowHint();
			}

		obj.onmouseout = hidetip;

		if (typeof window.ontouchstart === 'undefined')
			{
			overAnchorTimer = window.setTimeout(function() {
				hideTipIfMouseHasLeft(obj);
			}, 1000);
			}
		}
}

function hideTipIfMouseHasLeft(obj) {
	if (mouseStillOverTipOwner(obj))
		{
		overAnchorTimer = window.setTimeout(function() {
			hideTipIfMouseHasLeft(obj);
		}, 1000);
		}
	else
		{
		hidetip();
		removeClass(obj, anchorClassName);
		}
}

function mouseStillOverTipOwner(obj) {
	let stillOver = false;

	let anks = document.getElementsByClassName(anchorClassName);
	if (anks.length > 0)
		{
		let el = anks[0];
		let c = window.getComputedStyle(el).getPropertyValue('border-top-style');
		stillOver = (c === 'hidden') ? true : false;
		}
	return (stillOver);
}

function hidetip(e) {
	dropmenuobj.style.visibility = "hidden";
	dropmenuobj.style.left = "-500px";
	let anks = document.getElementsByClassName(anchorClassName);
	if (anks.length > 0)
		{
		for (i = anks.length - 1; i >= 0; --i)
			{
			removeClass(anks[i], anchorClassName);
			}
		}
}

function touchhidetip(e) {
	dropmenuobj.style.visibility = "hidden";
	dropmenuobj.style.left = "-500px";
}

function createhintbox() {
	let divblock = document.createElement("div");
	divblock.setAttribute("id", "hintbox");
	document.body.appendChild(divblock);

	dropmenuobj = document.getElementById("hintbox");
	dropmenuobj.style.visibility = "hidden";
	dropmenuobj.style.left = "-500px";
	
	if (shOnMobile)
		{
		dropmenuobj.addEventListener("touchstart", function(e) {touchhidetip();});
		}
}

// For remote iPad "debugging" since remotedebug_ios_webkit_adapter has stopped working.
// For Viewer, errorID element is up near the top of the window.
function writeMessageToWindow(str) {
	let errorElem = document.getElementById(errorID);
	if (errorElem !== null)
		{
		errorElem.innerHTML = "<p>" + str + "</p>";
		}
}

if (window.addEventListener)
	window.addEventListener("load", createhintbox, false);
else if (window.attachEvent)
	window.attachEvent("onload", createhintbox);
else if (document.getElementById)
	window.onload = createhintbox;

</script>
<script type="text/javascript">

// Whitespace (or punctuation) checker. Copied from somewhere, and it works.
function isW(s) {
	return /[ \t\uFFE5\^\+=`~<>{}\[\]|\u3000-\u303F!-#%-\x2A,-/:;\x3F@\x5B-\x5D\x7B}\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/.test(s);
	
	
// return /[ \f\n\r\t\v\u00A0\u2028\u2029]/.test(s);
}

</script>
<script type="text/javascript">
/*!***************************************************
* mark.js v9.0.0
* https://markjs.io/
* Copyright (c) 2014–2018, Julian Kühnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Mark=t()}(this,function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var i=
/* */
function(){function e(n){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5e3;t(this,e),this.ctx=n,this.iframes=r,this.exclude=o,this.iframesTimeout=i}return r(e,[{key:"getContexts",value:function(){var e=[];return(void 0!==this.ctx&&this.ctx?NodeList.prototype.isPrototypeOf(this.ctx)?Array.prototype.slice.call(this.ctx):Array.isArray(this.ctx)?this.ctx:"string"==typeof this.ctx?Array.prototype.slice.call(document.querySelectorAll(this.ctx)):[this.ctx]:[]).forEach(function(t){var n=e.filter(function(e){return e.contains(t)}).length>0;-1!==e.indexOf(t)||n||e.push(t)}),e}},{key:"getIframeContents",value:function(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};try{var o=e.contentWindow;if(n=o.document,!o||!n)throw new Error("iframe inaccessible")}catch(e){r()}n&&t(n)}},{key:"isIframeBlank",value:function(e){var t="about:blank",n=e.getAttribute("src").trim();return e.contentWindow.location.href===t&&n!==t&&n}},{key:"observeIframeLoad",value:function(e,t,n){var r=this,o=!1,i=null,a=function a(){if(!o){o=!0,clearTimeout(i);try{r.isIframeBlank(e)||(e.removeEventListener("load",a),r.getIframeContents(e,t,n))}catch(e){n()}}};e.addEventListener("load",a),i=setTimeout(a,this.iframesTimeout)}},{key:"onIframeReady",value:function(e,t,n){try{"complete"===e.contentWindow.document.readyState?this.isIframeBlank(e)?this.observeIframeLoad(e,t,n):this.getIframeContents(e,t,n):this.observeIframeLoad(e,t,n)}catch(e){n()}}},{key:"waitForIframes",value:function(e,t){var n=this,r=0;this.forEachIframe(e,function(){return!0},function(e){r++,n.waitForIframes(e.querySelector("html"),function(){--r||t()})},function(e){e||t()})}},{key:"forEachIframe",value:function(t,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},a=t.querySelectorAll("iframe"),s=a.length,c=0;a=Array.prototype.slice.call(a);var u=function(){--s<=0&&i(c)};s||u(),a.forEach(function(t){e.matches(t,o.exclude)?u():o.onIframeReady(t,function(e){n(t)&&(c++,r(e)),u()},u)})}},{key:"createIterator",value:function(e,t,n){return document.createNodeIterator(e,t,n,!1)}},{key:"createInstanceOnIframe",value:function(t){return new e(t.querySelector("html"),this.iframes)}},{key:"compareNodeIframe",value:function(e,t,n){if(e.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_PRECEDING){if(null===t)return!0;if(t.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING)return!0}return!1}},{key:"getIteratorNode",value:function(e){var t=e.previousNode();return{prevNode:t,node:null===t?e.nextNode():e.nextNode()&&e.nextNode()}}},{key:"checkIframeFilter",value:function(e,t,n,r){var o=!1,i=!1;return r.forEach(function(e,t){e.val===n&&(o=t,i=e.handled)}),this.compareNodeIframe(e,t,n)?(!1!==o||i?!1===o||i||(r[o].handled=!0):r.push({val:n,handled:!0}),!0):(!1===o&&r.push({val:n,handled:!1}),!1)}},{key:"handleOpenIframes",value:function(e,t,n,r){var o=this;e.forEach(function(e){e.handled||o.getIframeContents(e.val,function(e){o.createInstanceOnIframe(e).forEachNode(t,n,r)})})}},{key:"iterateThroughNodes",value:function(e,t,n,r,o){for(var i,a,s,c=this,u=this.createIterator(t,e,r),l=[],h=[];s=void 0,s=c.getIteratorNode(u),a=s.prevNode,i=s.node;)this.iframes&&this.forEachIframe(t,function(e){return c.checkIframeFilter(i,a,e,l)},function(t){c.createInstanceOnIframe(t).forEachNode(e,function(e){return h.push(e)},r)}),h.push(i);h.forEach(function(e){n(e)}),this.iframes&&this.handleOpenIframes(l,e,n,r),o()}},{key:"forEachNode",value:function(e,t,n){var r=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},i=this.getContexts(),a=i.length;a||o(),i.forEach(function(i){var s=function(){r.iterateThroughNodes(e,i,t,n,function(){--a<=0&&o()})};r.iframes?r.waitForIframes(i,s):s()})}}],[{key:"matches",value:function(e,t){var n="string"==typeof t?[t]:t,r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.oMatchesSelector||e.webkitMatchesSelector;if(r){var o=!1;return n.every(function(t){return!r.call(e,t)||(o=!0,!1)}),o}return!1}}]),e}(),a=
/* */
function(){function e(n){t(this,e),this.opt=o({},{diacritics:!0,synonyms:{},accuracy:"partially",caseSensitive:!1,ignoreJoiners:!1,ignorePunctuation:[],wildcards:"disabled"},n)}return r(e,[{key:"create",value:function(e){return"disabled"!==this.opt.wildcards&&(e=this.setupWildcardsRegExp(e)),e=this.escapeStr(e),Object.keys(this.opt.synonyms).length&&(e=this.createSynonymsRegExp(e)),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),this.opt.diacritics&&(e=this.createDiacriticsRegExp(e)),e=this.createMergedBlanksRegExp(e),(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.createJoinersRegExp(e)),"disabled"!==this.opt.wildcards&&(e=this.createWildcardsRegExp(e)),e=this.createAccuracyRegExp(e),new RegExp(e,"gm".concat(this.opt.caseSensitive?"":"i"))}},{key:"sortByLength",value:function(e){return e.sort(function(e,t){return e.length===t.length?e>t?1:-1:t.length-e.length})}},{key:"escapeStr",value:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}},{key:"createSynonymsRegExp",value:function(e){var t=this,n=this.opt.synonyms,r=this.opt.caseSensitive?"":"i",o=this.opt.ignoreJoiners||this.opt.ignorePunctuation.length?"\0":"";for(var i in n)if(n.hasOwnProperty(i)){var a=Array.isArray(n[i])?n[i]:[n[i]];a.unshift(i),(a=this.sortByLength(a).map(function(e){return"disabled"!==t.opt.wildcards&&(e=t.setupWildcardsRegExp(e)),e=t.escapeStr(e)}).filter(function(e){return""!==e})).length>1&&(e=e.replace(new RegExp("(".concat(a.map(function(e){return t.escapeStr(e)}).join("|"),")"),"gm".concat(r)),o+"(".concat(a.map(function(e){return t.processSynonyms(e)}).join("|"),")")+o))}return e}},{key:"processSynonyms",value:function(e){return(this.opt.ignoreJoiners||this.opt.ignorePunctuation.length)&&(e=this.setupIgnoreJoinersRegExp(e)),e}},{key:"setupWildcardsRegExp",value:function(e){return(e=e.replace(/(?:\\)*\?/g,function(e){return"\\"===e.charAt(0)?"?":""})).replace(/(?:\\)*\*/g,function(e){return"\\"===e.charAt(0)?"*":""})}},{key:"createWildcardsRegExp",value:function(e){var t="withSpaces"===this.opt.wildcards;return e.replace(/\u0001/g,t?"[\\S\\s]?":"\\S?").replace(/\u0002/g,t?"[\\S\\s]*?":"\\S*")}},{key:"setupIgnoreJoinersRegExp",value:function(e){return e.replace(/[^(|)\\]/g,function(e,t,n){var r=n.charAt(t+1);return/[(|)\\]/.test(r)||""===r?e:e+"\0"})}},{key:"createJoinersRegExp",value:function(e){var t=[],n=this.opt.ignorePunctuation;return Array.isArray(n)&&n.length&&t.push(this.escapeStr(n.join(""))),this.opt.ignoreJoiners&&t.push("\\u00ad\\u200b\\u200c\\u200d"),t.length?e.split(/\u0000+/).join("[".concat(t.join(""),"]*")):e}},{key:"createDiacriticsRegExp",value:function(e){var t=this.opt.caseSensitive?"":"i",n=this.opt.caseSensitive?["aàáảãạăằắẳẵặâầấẩẫậäåāą","AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ","cçćč","CÇĆČ","dđď","DĐĎ","eèéẻẽẹêềếểễệëěēę","EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ","iìíỉĩịîïī","IÌÍỈĨỊÎÏĪ","lł","LŁ","nñňń","NÑŇŃ","oòóỏõọôồốổỗộơởỡớờợöøō","OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ","rř","RŘ","sšśșş","SŠŚȘŞ","tťțţ","TŤȚŢ","uùúủũụưừứửữựûüůū","UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ","yýỳỷỹỵÿ","YÝỲỶỸỴŸ","zžżź","ZŽŻŹ"]:["aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ","cçćčCÇĆČ","dđďDĐĎ","eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ","iìíỉĩịîïīIÌÍỈĨỊÎÏĪ","lłLŁ","nñňńNÑŇŃ","oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ","rřRŘ","sšśșşSŠŚȘŞ","tťțţTŤȚŢ","uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ","yýỳỷỹỵÿYÝỲỶỸỴŸ","zžżźZŽŻŹ"],r=[];return e.split("").forEach(function(o){n.every(function(n){if(-1!==n.indexOf(o)){if(r.indexOf(n)>-1)return!1;e=e.replace(new RegExp("[".concat(n,"]"),"gm".concat(t)),"[".concat(n,"]")),r.push(n)}return!0})}),e}},{key:"createMergedBlanksRegExp",value:function(e){return e.replace(/[\s]+/gim,"[\\s]+")}},{key:"createAccuracyRegExp",value:function(e){var t=this,n=this.opt.accuracy,r="string"==typeof n?n:n.value,o="string"==typeof n?[]:n.limiters,i="";switch(o.forEach(function(e){i+="|".concat(t.escapeStr(e))}),r){case"partially":default:return"()(".concat(e,")");case"complementary":return i="\\s"+(i||this.escapeStr("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~¡¿")),"()([^".concat(i,"]*").concat(e,"[^").concat(i,"]*)");case"exactly":return"(^|\\s".concat(i,")(").concat(e,")(?=$|\\s").concat(i,")")}}}]),e}(),s=
/* */
function(){function n(e){t(this,n),this.ctx=e,this.ie=!1;var r=window.navigator.userAgent;(r.indexOf("MSIE")>-1||r.indexOf("Trident")>-1)&&(this.ie=!0)}return r(n,[{key:"log",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"debug",r=this.opt.log;this.opt.debug&&"object"===e(r)&&"function"==typeof r[n]&&r[n]("mark.js: ".concat(t))}},{key:"getSeparatedKeywords",value:function(e){var t=this,n=[];return e.forEach(function(e){t.opt.separateWordSearch?e.split(" ").forEach(function(e){e.trim()&&-1===n.indexOf(e)&&n.push(e)}):e.trim()&&-1===n.indexOf(e)&&n.push(e)}),{keywords:n.sort(function(e,t){return t.length-e.length}),length:n.length}}},{key:"isNumeric",value:function(e){return Number(parseFloat(e))==e}},{key:"checkRanges",value:function(e){var t=this;if(!Array.isArray(e)||"[object Object]"!==Object.prototype.toString.call(e[0]))return this.log("markRanges() will only accept an array of objects"),this.opt.noMatch(e),[];var n=[],r=0;return e.sort(function(e,t){return e.start-t.start}).forEach(function(e){var o=t.callNoMatchOnInvalidRanges(e,r),i=o.start,a=o.end;o.valid&&(e.start=i,e.length=a-i,n.push(e),r=a)}),n}},{key:"callNoMatchOnInvalidRanges",value:function(e,t){var n,r,o=!1;return e&&void 0!==e.start?(r=(n=parseInt(e.start,10))+parseInt(e.length,10),this.isNumeric(e.start)&&this.isNumeric(e.length)&&r-t>0&&r-n>0?o=!0:(this.log("Ignoring invalid or overlapping range: "+"".concat(JSON.stringify(e))),this.opt.noMatch(e))):(this.log("Ignoring invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)),{start:n,end:r,valid:o}}},{key:"checkWhitespaceRanges",value:function(e,t,n){var r,o=!0,i=n.length,a=t-i,s=parseInt(e.start,10)-a;return(r=(s=s>i?i:s)+parseInt(e.length,10))>i&&(r=i,this.log("End range automatically set to the max value of ".concat(i))),s<0||r-s<0||s>i||r>i?(o=!1,this.log("Invalid range: ".concat(JSON.stringify(e))),this.opt.noMatch(e)):""===n.substring(s,r).replace(/\s+/g,"")&&(o=!1,this.log("Skipping whitespace only range: "+JSON.stringify(e)),this.opt.noMatch(e)),{start:s,end:r,valid:o}}},{key:"getTextNodes",value:function(e){var t=this,n="",r=[];this.iterator.forEachNode(NodeFilter.SHOW_TEXT,function(e){r.push({start:n.length,end:(n+=e.textContent).length,node:e})},function(e){return t.matchesExclude(e.parentNode)?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},function(){e({value:n,nodes:r})})}},{key:"matchesExclude",value:function(e){return i.matches(e,this.opt.exclude.concat(["script","style","title","head","html"]))}},{key:"wrapRangeInTextNode",value:function(e,t,n){var r=this.opt.element?this.opt.element:"mark",o=e.splitText(t),i=o.splitText(n-t),a=document.createElement(r);return a.setAttribute("data-markjs","true"),this.opt.className&&a.setAttribute("class",this.opt.className),a.textContent=o.textContent,o.parentNode.replaceChild(a,o),i}},{key:"wrapRangeInMappedTextNode",value:function(e,t,n,r,o){var i=this;e.nodes.every(function(a,s){var c=e.nodes[s+1];if(void 0===c||c.start>t){if(!r(a.node))return!1;var u=t-a.start,l=(n>a.end?a.end:n)-a.start,h=e.value.substr(0,a.start),f=e.value.substr(l+a.start);if(a.node=i.wrapRangeInTextNode(a.node,u,l),e.value=h+f,e.nodes.forEach(function(t,n){n>=s&&(e.nodes[n].start>0&&n!==s&&(e.nodes[n].start-=l),e.nodes[n].end-=l)}),n-=l,o(a.node.previousSibling,a.start),!(n>a.end))return!1;t=a.end}return!0})}},{key:"wrapGroups",value:function(e,t,n,r){return r((e=this.wrapRangeInTextNode(e,t,t+n)).previousSibling),e}},{key:"separateGroups",value:function(e,t,n,r,o){for(var i=t.length,a=1;a<i;a++){var s=e.textContent.indexOf(t[a]);t[a]&&s>-1&&r(t[a],e)&&(e=this.wrapGroups(e,s,t[a].length,o))}return e}},{key:"wrapMatches",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){t.nodes.forEach(function(t){var o;for(t=t.node;null!==(o=e.exec(t.textContent))&&""!==o[a];){if(i.opt.separateGroups)t=i.separateGroups(t,o,a,n,r);else{if(!n(o[a],t))continue;var s=o.index;if(0!==a)for(var c=1;c<a;c++)s+=o[c].length;t=i.wrapGroups(t,s,o[a].length,r)}e.lastIndex=0}}),o()})}},{key:"wrapMatchesAcrossElements",value:function(e,t,n,r,o){var i=this,a=0===t?0:t+1;this.getTextNodes(function(t){for(var s;null!==(s=e.exec(t.value))&&""!==s[a];){var c=s.index;if(0!==a)for(var u=1;u<a;u++)c+=s[u].length;var l=c+s[a].length;i.wrapRangeInMappedTextNode(t,c,l,function(e){return n(s[a],e)},function(t,n){e.lastIndex=n,r(t)})}o()})}},{key:"wrapRangeFromIndex",value:function(e,t,n,r){var o=this;this.getTextNodes(function(i){var a=i.value.length;e.forEach(function(e,r){var s=o.checkWhitespaceRanges(e,a,i.value),c=s.start,u=s.end;s.valid&&o.wrapRangeInMappedTextNode(i,c,u,function(n){return t(n,e,i.value.substring(c,u),r)},function(t){n(t,e)})}),r()})}},{key:"unwrapMatches",value:function(e){for(var t=e.parentNode,n=document.createDocumentFragment();e.firstChild;)n.appendChild(e.removeChild(e.firstChild));t.replaceChild(n,e),this.ie?this.normalizeTextNode(t):t.normalize()}},{key:"normalizeTextNode",value:function(e){if(e){if(3===e.nodeType)for(;e.nextSibling&&3===e.nextSibling.nodeType;)e.nodeValue+=e.nextSibling.nodeValue,e.parentNode.removeChild(e.nextSibling);else this.normalizeTextNode(e.firstChild);this.normalizeTextNode(e.nextSibling)}}},{key:"markRegExp",value:function(e,t){var n=this;this.opt=t,this.log('Searching with expression "'.concat(e,'"'));var r=0,o="wrapMatches";this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),this[o](e,this.opt.ignoreGroups,function(e,t){return n.opt.filter(t,e,r)},function(e){r++,n.opt.each(e)},function(){0===r&&n.opt.noMatch(e),n.opt.done(r)})}},{key:"mark",value:function(e,t){var n=this;this.opt=t;var r=0,o="wrapMatches",i=this.getSeparatedKeywords("string"==typeof e?[e]:e),s=i.keywords,c=i.length;this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),0===c?this.opt.done(r):function e(t){var i=new a(n.opt).create(t),u=0;n.log('Searching with expression "'.concat(i,'"')),n[o](i,1,function(e,o){return n.opt.filter(o,t,r,u)},function(e){u++,r++,n.opt.each(e)},function(){0===u&&n.opt.noMatch(t),s[c-1]===t?n.opt.done(r):e(s[s.indexOf(t)+1])})}(s[0])}},{key:"markRanges",value:function(e,t){var n=this;this.opt=t;var r=0,o=this.checkRanges(e);o&&o.length?(this.log("Starting to mark with the following ranges: "+JSON.stringify(o)),this.wrapRangeFromIndex(o,function(e,t,r,o){return n.opt.filter(e,t,r,o)},function(e,t){r++,n.opt.each(e,t)},function(){n.opt.done(r)})):this.opt.done(r)}},{key:"unmark",value:function(e){var t=this;this.opt=e;var n=this.opt.element?this.opt.element:"*";n+="[data-markjs]",this.opt.className&&(n+=".".concat(this.opt.className)),this.log('Removal selector "'.concat(n,'"')),this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT,function(e){t.unwrapMatches(e)},function(e){var r=i.matches(e,n),o=t.matchesExclude(e);return!r||o?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},this.opt.done)}},{key:"opt",set:function(e){this._opt=o({},{element:"",className:"",exclude:[],iframes:!1,iframesTimeout:5e3,separateWordSearch:!0,acrossElements:!1,ignoreGroups:0,each:function(){},noMatch:function(){},filter:function(){return!0},done:function(){},debug:!1,log:window.console},e)},get:function(){return this._opt}},{key:"iterator",get:function(){return new i(this.ctx,this.opt.iframes,this.opt.exclude,this.opt.iframesTimeout)}}]),n}();return function(e){var t=this,n=new s(e);return this.mark=function(e,r){return n.mark(e,r),t},this.markRegExp=function(e,r){return n.markRegExp(e,r),t},this.markRanges=function(e,r){return n.markRanges(e,r),t},this.unmark=function(e){return n.unmark(e),t},this}});

</script>
<script type="text/javascript">
// wordAtInsertionPt.js
// See https://stackoverflow.com/questions/2444430/how-to-get-a-word-under-cursor-using-javascript 
// soln by Drakes https://stackoverflow.com/users/1938889/drakes
// (Modified from the original.)
// In IntraMine, getFullWord() is called by viewerStart.js#expandSelectionToWordIfPossible(),
// the goal being to select a whole word with one click when in a non-Editable view of a file.

// Get the full word the cursor is over regardless of span breaks
function getFullWord(event) {
let i, begin, end, range, textNode, offset;

// Internet Explorer
if (document.body.createTextRange) {
   try {
	 range = document.body.createTextRange();
	 range.moveToPoint(event.clientX, event.clientY);
	 range.select();
	 range = getTextRangeBoundaryPosition(range, true);
  
	 textNode = range.node;
	 offset = range.offset;
   } catch(e) {
   return(document.createRange()); // Sigh, IE
   }
}

// Firefox, Safari
// REF: https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint
else if (document.caretPositionFromPoint) {
  range = document.caretPositionFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.offsetNode;
	  offset = range.offset;
	  }
  else
	  {
	  return(document.createRange());
	  }

  // Chrome
  // REF: https://developer.mozilla.org/en-US/docs/Web/API/document/caretRangeFromPoint
} else if (document.caretRangeFromPoint) {
  range = document.caretRangeFromPoint(event.clientX, event.clientY);
  if (range !== null)
	  {
	  textNode = range.startContainer;
	  offset = range.startOffset;
	  }
  else
	  {
	  return(document.createRange());
	  }
}

// Only act on text nodes
if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
	return(document.createRange());
}

let data = textNode.textContent;

// Sometimes the offset can be at the 'length' of the data.
// It might be a bug with this 'experimental' feature - 
// compensate for this below
if (offset >= data.length) {
  offset = data.length - 1;
}

// Scan behind the current character until whitespace or punct is found, or beginning
i = begin = end = offset;
// Don't scan behind if we're at the end of a line and last char is not a word char.
let blockedAtLineEnd = ( offset === data.length - 1 && isW(data[offset]) );
if (!blockedAtLineEnd)
	{
	while ( previousCharIsAWordChar(data, i - 1) ) {
	  //while (i > 0 && !isW(data[i - 1])) {
	  i--;
	  }
	}
begin = i;

// Scan ahead of the current character until whitespace or punct is found, or end
// unless char at offset is not a word char.
i = offset;
let offsetIsWordChar = nextCharIsAWordChar(data, offset);
if (nextCharIsAWordChar(data, i))
	{
	while ( nextCharIsAWordChar(data, i + 1) ) {
	//while (i < data.length - 1 && !isW(data[i + 1])) {
	  i++;
	}
	}
end = i;

// This is our temporary word
let word = data.substring(begin, end + 1);

// If at a node boundary, cross over and see what 
// the next word is and check if this should be added to our temp word
if (end === data.length - 1 || begin === 0) {

  let nextNode = getNextNode(textNode);
  let prevNode = getPrevNode(textNode);

  // Get the next node text
  if (end == data.length - 1 && nextNode) {
  let nextText = nextNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = 0;
	while ( nextCharIsAWordChar(nextText, i) ) {
	  word += nextText[i++];
	}

  } else if (begin === 0 && prevNode) {
	// Get the previous node text
  let prevText = prevNode.textContent;

	// Add the letters from the next text block until a whitespace or punct, or end
	i = prevText.length - 1;
	while ( previousCharIsAWordChar(prevText, i) ) {
	  word = prevText[i--] + word;
	}
  }
}

// Sometimes a bad last char is tacked on?
if (word.length)
	{
	word = remove_linebreaks(word);
//	if (isW(word[ word.length - 1]))
//		{
//		word = word.substring(0, word.length - 1);
//		}
	}

// Return the word, and its start and end offsets. Kill selection of '.' or other non-word
// if click happened past end of line and the line ends in non-word char such as '.'.
if (blockedAtLineEnd)
	{
	word = '';
	begin = end;
	}
else
	{
	if (offsetIsWordChar)
		{
		++end;
		}
	}

let obj = {
		theWord: word,
		theBegin: begin,
		theEnd: end
		};

return(obj);

//return word;
} // getFullWord()


// Helper functions

function remove_linebreaks(str ) { 
return str.replace( /[\r\n]+/gm, "" ); 
} 

// Looking in the forward direction, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the following char is not white or punctuation.
function nextCharIsAWordChar(theText, i) {
	let result = ( i < theText.length 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && (i+1) < theText.length && !isW(theText[i+1])))
		  );
	return(result);
	}

// Looking in reverse, either char is not white or punctuation,
// or it is an apostrophe or hyphen and the previous char is not white or punctuation.
function previousCharIsAWordChar(theText, i) {
	let result = ( i >= 0 
		&& (!isW(theText[i])
		  || ((theText[i] === "'" || theText[i] === "-") && i > 0 && !isW(theText[i-1])))
		  );
	return(result);
	}


// Barrier nodes are BR, DIV, P, PRE, TD, TR, ... 
function isBarrierNode(node) {
return node ? /^(BR|DIV|P|PRE|TD|TR|TABLE)$/i.test(node.nodeName) : true;
}

// Try to find the next adjacent node
function getNextNode(node) {
let n = null;
// Does this node have a sibling?
if (node.nextSibling) {
n = node.nextSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.nextSibling) {
n = node.parentNode.nextSibling;
}
return isBarrierNode(n) ? null : n;
}

// Try to find the prev adjacent node
function getPrevNode(node) {
var n = null;

// Does this node have a sibling?
if (node.previousSibling) {
n = node.previousSibling;

// Doe this node's container have a sibling?
} else if (node.parentNode && node.parentNode.previousSibling) {
n = node.parentNode.previousSibling;
}
return isBarrierNode(n) ? null : n;
}

// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getChildIndex(node) {
var i = 0;
while( (node = node.previousSibling) ) {
i++;
}
return i;
}

// All this code just to make this work with IE, OTL
// REF: http://stackoverflow.com/questions/3127369/how-to-get-selected-textnode-in-contenteditable-div-in-ie
function getTextRangeBoundaryPosition(textRange, isStart) {
var workingRange = textRange.duplicate();
workingRange.collapse(isStart);
var containerElement = workingRange.parentElement();
var workingNode = document.createElement("span");
var comparison, workingComparisonType = isStart ?
"StartToStart" : "StartToEnd";

var boundaryPosition, boundaryNode;

// Move the working range through the container's children, starting at
// the end and working backwards, until the working range reaches or goes
// past the boundary we're interested in
do {
containerElement.insertBefore(workingNode, workingNode.previousSibling);
workingRange.moveToElementText(workingNode);
} while ( (comparison = workingRange.compareEndPoints(
workingComparisonType, textRange)) > 0 && workingNode.previousSibling);

// We've now reached or gone past the boundary of the text range we're
// interested in so have identified the node we want
boundaryNode = workingNode.nextSibling;
if (comparison == -1 && boundaryNode) {
// This must be a data node (text, comment, cdata) since we've overshot.
// The working range is collapsed at the start of the node containing
// the text range's boundary, so we move the end of the working range
// to the boundary point and measure the length of its text to get
// the boundary's offset within the node
workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

boundaryPosition = {
  node: boundaryNode,
  offset: workingRange.text.length
};
} else {
// We've hit the boundary exactly, so this must be an element
boundaryPosition = {
  node: containerElement,
  offset: getChildIndex(workingNode)
};
}

// Clean up
workingNode.parentNode.removeChild(workingNode);

return boundaryPosition;
}

</script>
<script type="text/javascript">
// LightRange.js - A simple and lightweight selection, range and caret information library in native JavaScript, with an additional selection save & restore system. - https://github.com/n457/LightRange.js
// Version 2.2.0
// MIT License - Copyright (c) 2015 Bertrand Vignaud-Lerouge / n457 - https://github.com/n457
var LightRange=function(){};
LightRange.prototype.getSelectionInfo=function(){var a={};if(window.getSelection){var b=window.getSelection(),e=document.body.scrollTop,f=document.body.scrollLeft;if(0<b.rangeCount){var d=b.getRangeAt(0).cloneRange(),c=d.getBoundingClientRect();0===c.height&&(c=d.getClientRects()[0]);c&&(a.width=c.width,a.height=c.height,a.xStart=c.left+f,a.yStart=c.top+e);a.text=b.toString();a.charStart=d.startOffset;a.charEnd=d.endOffset;d.collapse(!1);if(c=d.getClientRects()[0])a.xEnd=c.left+f,a.yEnd=c.top+e}}else if(document.selection)b=
document.selection.createRange(),e=document.documentElement.scrollTop,f=document.documentElement.scrollLeft,a.width=b.boundingWidth,a.height=b.boundingHeight,a.xStart=b.boundingLeft+f,a.yStart=b.boundingTop+e,a.text=b.text,b.collapse(!1),a.xEnd=b.boundingLeft+f,a.yEnd=b.boundingTop+e;else return null;a.text?(a.characters=a.text.replace(/\s/g,"").length,a.charactersAll=a.text.replace(/[\n\r]/g,"").length):(a.characters=0,a.charactersAll=0);return a};
LightRange.prototype.saveSelection=function(){if(window.getSelection){var a=window.getSelection();if(a.getRangeAt&&a.rangeCount)return a.getRangeAt(0)}else return document.selection&&document.selection.createRange?document.selection.createRange():null};LightRange.prototype.restoreSelection=function(a){if(a){if(window.getSelection){var b=window.getSelection();b.removeAllRanges();b.addRange(a)}else if(document.selection&&a.select)a.select();else return null;return a}};var lightrange=new LightRange;

</script>
<script type="text/javascript">
/* glossstubs.js: stubs for functions that gloss2html.pl doesn't need.
*/

function addAutoLinks() {
}

</script>
<script type="text/javascript">
// viewerStart.js: used for non-CodeMirror views in intramine_file_viewer_cm.pl.
// Manage layout changes on resize, jump to an anchor
// Put highlight hits in text and on scrollbar.
// Show/hide any initial search hits provided in highlightitems.
// Preserve user selection when marking, by remembering selection range, removing selected
// text before marking, then restoring text and selection range after marking (patent not pending).

let markerMainElement = document.getElementById(cmTextHolderName);
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById("scrollText");
	}
if (markerMainElement === null)
	{
	markerMainElement = document.getElementById(specialTextHolderName);
	}

let tocMainElement = document.getElementById("scrollContentsList");

let onMobile = false; // Set below, true if we have touch events.
if (typeof window.ontouchstart !== 'undefined')
	{
	onMobile = true;
	}

window.addEventListener("load", reJumpAndHighlight);
window.addEventListener("resize", JD.debounce(doResize, 100));

//let doingStandalone = false;
//if (typeof weAreStandalone !== 'undefined')
//	{
//	doingStandalone = weAreStandalone;
//	}

// Adjust some element heights so scrolling works properly.
function doResize() {
	let rule = document.getElementById("rule_above_editor");
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;

	let windowHeight = window.innerHeight;
	let elHeight = windowHeight - pos.y - ruleHeight - 8;
	let newHeightPC = (elHeight / windowHeight) * 100;
	let el = document.getElementById("scrollAdjustedHeight");
	el.style.height = newHeightPC + "%";

	if (tocMainElement !== null)
		{
		let tocMarginTop =
				parseInt(window.getComputedStyle(tocMainElement).getPropertyValue('margin-top'));
		let tocHeight = elHeight - tocMarginTop;
		if (onMobile)
			{
			tocHeight -= 20;
			}
		else
			{
			tocHeight -= 16;
			}
		let newTocHeightPC = (tocHeight / elHeight) * 100;
		tocMainElement.style.height = newTocHeightPC + "%";
		}

	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		highlightInitialItems();
		}

	if (!onMobile)
		{
		scrollIndicator();
		}
	else
		{
		scrollMobileIndicator(); // if mobile
		}
	
	updateToggleBigMoveLimit();
}

// On "load", scroll any location.hash position into view, and put highlights on any
// words that formed part of a search that produced this file as a hit.
// See intramine_file_viewer_cm.pl#InitialHighlightItems().
function reJumpAndHighlight() {
	reJump();
	updateToggleBigMoveLimit();
	updateTogglePositions();
	highlightInitialItems();
	addAutoLinks();
}

// Set top of nav to zero, fixes an iPad scroll problem where nav goes off the top.
function resetTopNavPosition() {
	let nav = document.getElementById("nav"); // nope nav.style.top = 0;
	if (nav !== null)
		{
		nav.parentNode.scrollTop = 0;
		}
}

// Scroll element into view, based on ID named in location.hash.
function reJump() {
	let h = location.hash;
	if (h.length > 1)
		{
		// strip leading '#'
		h = h.replace(/^#/, '');
		
		if (isNaN(h))
			{
			let el = getElementForHash(h);
			
			if (el !== null)
				{
				el.scrollIntoView();
				resetTopNavPosition();
				if (!onMobile)
					{
					scrollIndicator();
					}
				else
					{
					scrollMobileIndicator(); // if mobile
					}
				}
			}
		else
			{
			reJumpToLineNumber(h);
			}
		}
}

// Progressively shorten 'h' word by word as necessary until an anchor id is found. If the
// remaining part of 'h' is a number, though, jump to that line. If an anchor id is found,
// return the corresponding element in the html text.
//
// This "shortening" approach is needed because 'h' may be too long, if it was part of a link
// in a text file where the link was not quoted: when making the link, we didn't know where
// the hash stopped, and just grabbed a hundred or so characters after the '#'.
// [See intramine_file_viewer_cm.pl#RememberTextOrImageFileMention().]
function getElementForHash(h) {
	let hCopy = h;
	hCopy = hCopy.replace(/ /g, '_');
	hCopy = hCopy.replace(/\%20/g, '_');
	hCopy = hCopy.replace(/\(\)$/, '');
	let el = document.getElementById(hCopy);
	
	while(el === null && h.length > 0)
		{
		let lastIndexOfSpace = h.lastIndexOf(" ");
		let lastIndexOfPct = h.lastIndexOf("%");
		let trimIndex = (lastIndexOfSpace > lastIndexOfPct) ? lastIndexOfSpace: lastIndexOfPct;
		if (trimIndex > 0)
			{
			h = h.substring(0, trimIndex);
			let hCopy = h;
			hCopy = hCopy.replace(/ /g, '_');
			hCopy = hCopy.replace(/\%20/g, '_');
			el = document.getElementById(hCopy);
			if (el === null)
				{
				if (!isNaN(hCopy))
					{
					reJumpToLineNumber(hCopy);
					break;
					}
				}
			}
		else
			{
			break;
			}
		}
	
	return(el);
}

// Scroll a line into view, based on line number.
function reJumpToLineNumber(h) {
	let lineNum = parseInt(h, 10) - 1;
	if (lineNum <= 0)
		{
		lineNum = 0;
		}
	// Look for row number lineNum.
	let rows = markerMainElement.getElementsByTagName('tr');
	if (lineNum < rows.length)
		{
		let el = rows[lineNum];
		if (el !== null)
			{
			el.scrollIntoView();
			resetTopNavPosition();
			if (!onMobile)
				{
				scrollIndicator();
				}
			else
				{
				scrollMobileIndicator(); // if mobile
				}
			}
		}
}

// Adust the top of "id" (the main text holder) so scrolling will work properly etc.
function setTextViewPosition(rule_id, id) {
	let el = document.getElementById(id);
	if (el === null)
		{
		return;
		}
	let rule = document.getElementById(rule_id);
	let pos = getPosition(rule);
	let rect = rule.getBoundingClientRect();
	let ruleHeight = rect.height;
	let yPos = pos.y + ruleHeight + 8;
	el.style.top = yPos + "px";
}

// Position the main text-holding element.
function positionViewItems() {
	let viewElement = document.getElementById(cmTextHolderName);
	if (viewElement !== null)
		{
		setTextViewPosition("rule_above_editor", cmTextHolderName);
		}
	else
		{
		viewElement = document.getElementById(specialTextHolderName);
		if (viewElement !== null)
			{
			setTextViewPosition("rule_above_editor", specialTextHolderName);
			}
		}
	doResize();
}

function finishStartup() {
	hideIt("search-button");
	hideIt("small-tip");
	positionViewItems();
	reJump();
}

function createElementFromHTML(htmlString) {
	let div = document.createElement('div');
	div.innerHTML = htmlString.trim();

	// Change this to div.childNodes to support multiple top-level nodes
	return div.firstChild; // or div.firstElementChild?
}

function hideIt(id) {
	let el = document.getElementById(id);
	if (el !== null)
		{
		el.style.display = 'none';
		}
}

// Set up for highlighting text, with marks in scrollbar, keeping user's selection
// or expanding it to a word. mark.js (mark.min.js) does the actual marking.
// Marks are used for both the initial highlight items and a user text selection.
let markerInstance = null;
let mouseEvt;

let textMarkerClass = "marker-highlight";
let scrollMarkerClass = "scroll-hilite";
let initialHitsTextMarkersClass = "initial-hits-highlight";
let initialHitsScrollMarkerClass = "initial-scroll-hl";
let toggleHitsButtonID = "sihits";
let initialSearchHitsAreShowing = false;
let currentTextForHighlighting = '';
let justUpdateScrollbar = false;


// Selection management: on a single click, expand to a word. If selection is on one row,
// the <td> holding it is removed before marking, and then restored, complete with selection.
// Done because marking the current selection will collapse it to an insertion point.
let theSelection = {};
theSelection.selectionIsTooBig = false;
theSelection.isDoubleClick = false;
theSelection.userDragged = false;
//For LightRange.min.js range representing text selection.
theSelection.ltRange = null;
theSelection.currentSelectionElem = null; // Hide/show this element when marking
theSelection.currentSelPreviousSibling = null; // The target for re-insertion of currentSelectionElem
theSelection.selChildren = []; // Contents of TD containing current selection
theSelection.startNodeIndexes = [];
theSelection.startNodeOffset = 0;
theSelection.endNodeIndexes = [];
theSelection.endNodeOffset = 0;
theSelection.topStartNode = null;
theSelection.topEndNode = null;

let linkClicked = false;
let hintboxClicked = false;
let cmCursorPos = {
	line : -1,
	ch : -1
};

// mark.js mark/unmark options, "done" is fired at the end of the mark/unmark. Normally
// one calls unmark, with unmarkOptions "done" calling the mark function.
let markerOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
	}
};
let markerOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"separateWordSearch" : false,
	"acrossElements" : true,
	"done" : function(counter) {
		markHitsInScrollbar(initialHitsTextMarkersClass, initialHitsScrollMarkerClass);
	}
};

let unmarkOptions = {
	// "element": "span",
	"className" : textMarkerClass,
	"done" : function() {
		removeAllScrollbarHighlights(scrollMarkerClass);
		markCurrentSelection();
	}
};
let unmarkOptionsInitialHits = {
	// "element": "span",
	"className" : initialHitsTextMarkersClass,
	"done" : function() {
		removeAllScrollbarHighlights(initialHitsScrollMarkerClass);
	}
};

if (markerMainElement !== null)
	{
	markerInstance = new Mark(markerMainElement);
	}

// After a click, update markers in text and scroll corresponding TOC element into view.
function delayedUpdateMarkersAndTOC(evt) {
	setTimeout(function() {
		updateMarkers(evt);
	}, 1000);
	
	scrollTocEntryIntoView(evt, false);
}

// Highlight user's selection, unless it was a click on a link or in the scrollbar, or the
// first click in a double-click, or there's too much text selected to be worth higlighting.
function updateMarkers(evt) {
	if (linkClicked)
		{
		return;
		}
	if (theSelection.isDoubleClick)
		{
		theSelection.isDoubleClick = false;
		return;
		}
	if (markerMainElement === null || evtIsInScrollbar(evt))
		{
		return;
		}

	// No marking if selection is "too big" (spreads over more than on line).
	theSelection.selectionIsTooBig = selectionIsTooBig();
	
	if (!justUpdateScrollbar && currentSelectionTouchesLink())
		{
		return;
		}

	mouseEvt = evt;
	
	theSelection.userDragged = false;

	// full highlight, selection, and scrollbar marking
	if (!justUpdateScrollbar && !theSelection.selectionIsTooBig) 
		{
		storeSelection();
		// Get current text to highlight, or set theSelection.selectionTooBig = true.
		// Also set current text to "" if it's fewer than three characters, meaning remove
		// all markers and don't mark anything new or change the selection (this is a way to
		// clear markers).
		currentTextForHighlighting = getCurrentTextForMarkup();
		
		hideSelectionRow(); // Don't mark up row where text is selected
		
		markerInstance.unmark(unmarkOptions);
		}
	else if (justUpdateScrollbar)
		{
		removeAllScrollbarHighlights(scrollMarkerClass);
		markHitsInScrollbar(textMarkerClass, scrollMarkerClass);
		}
	justUpdateScrollbar = false;
}

//See intramine_file_viewer_cm.pl#InitialHighlightItems().
function highlightInitialItems() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.mark(highlightItems[i], markerOptionsInitialHits);
			}
		initialSearchHitsAreShowing = true;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Hide Initial Hits";
			}
		}
}

//function decodeSpecialWordCharacters() {
//	if (markerMainElement !== null && highlightItems.length > 0)
//		{
//		for (let i = 0; i < highlightItems.length; ++i)
//			{
//			highlightItems[i] = highlightItems[i].replace(/ *__D_ */g, ".");
//			highlightItems[i] = highlightItems[i].replace(/__DS_([A-Za-z])/g, "\$$1");
//			highlightItems[i] = highlightItems[i].replace(/__PC_([A-Za-z])/g, "\%$1");
//			highlightItems[i] = highlightItems[i].replace(/__AT_([A-Za-z])/g, "\@$1");
//			}
//		}
//}

function removeInitialHighlights() {
	if (markerMainElement !== null && highlightItems.length > 0)
		{
		for (let i = 0; i < highlightItems.length; ++i)
			{
			markerInstance.unmark(unmarkOptionsInitialHits);
			}
		initialSearchHitsAreShowing = false;
		let toggleButton = document.getElementById(toggleHitsButtonID);
		if (toggleButton !== null)
			{
			toggleButton.value = "Show Initial Hits";
			}
		}
}

function toggleInitialSearchHits() {
	if (initialSearchHitsAreShowing)
		{
		removeInitialHighlights();
		}
	else
		{
		highlightInitialItems();
		}
}

function noteWasDoubleClick(evt) {
	let nons = '';
	theSelection.isDoubleClick = true;
}

function updateScrollbarMarkers() {
	justUpdateScrollbar = true;
	updateMarkers(null);
}

// This is called by mark.js after an unmark, see unmarkOptions above.
function markCurrentSelection() {

	if (currentTextForHighlighting !== "")
		{
		markerInstance.mark(currentTextForHighlighting, markerOptions);
		}
	
	showSelectionRow(); // Restore visibiliy of element containing current user selecton.
	
	showStoredSelections();

	theSelection.userDragged = false;
}

function getCurrentTextForMarkup() {
	let result = getSelectionText();

	return (result);
}

// Get text for marking, unless it's too big to be worth marking. This is a bit of a gamble,
// but a "too big" selection usually means the user is just intending to copy some text,
// not see other instances of it in the same file.
function getSelectionText() {
	let text = "";
	
	theSelection.userDragged = false;
	
	if (window.getSelection)
		{
		let currSelection = window.getSelection();
		if (!theSelection.selectionTooBig)
			{
			text = currSelection.toString();
			if (text !== '')
				{
				theSelection.userDragged = true;
				}
			}
		else
			{
			theSelection.userDragged = true;
			}
		}

	
	if (!theSelection.selectionTooBig && !theSelection.userDragged)
		{
		// Empty selection: expand to nearest word.
		if (text === '')
			{
			//text = expandSelectionToWordIfPossible();
			let wordObj = expandSelectionToWordIfPossible();
			text = wordObj.theWord;
			if (typeof text === 'undefined')
				{
				text = '';
				}
			if (text !== '')
				{
				let beginOffset = wordObj.theBegin;
				let endOffset = wordObj.theEnd;
				// Re-capture the selection for later restoration.
				if (typeof theSelection.ltRange !== 'undefined')
					{
					let startContainer = theSelection.ltRange.startContainer;
					theSelection.ltRange.setStart(startContainer, beginOffset);
					theSelection.ltRange.setEnd(startContainer, endOffset);
					}
				}
			}

		// If it's a single word with a single trailing space, trim any trailing space.
		if (text !== '')
			{
			let numSpaces = (text.match(/\s/g) || []).length;
			if (numSpaces === 1)
				{
				let lastChar = text.substring(text.length - 1);
				if (lastChar === " " || lastChar === "\t")
					{
					text = text.substring(0, text.length - 1);
					}
				}
			}

		}

	// Avoid highlighting just one or two characters.
	if (text.length <= 2)
		{
		text = "";
		}

	return text;
}


// "Too big" means selected text spreads across two or more lines.
// Revision, this affects the actual current selection so stop doing it.
function selectionIsTooBig() {
	let selectionTooBig = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		}

	return (selectionTooBig);
}

function currentSelectionTouchesLink() {
	let result = false;
	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let nodes = getNodesInRange(currRange);
		for (let i = 0; i < nodes.length; ++i)
			{
			if (nodes[i].nodeName === "A")
				{
				result = true;
				break;
				}
			}
		}
	
	return(result);
}

function getNextNode(node) {
    if (node.firstChild)
        return node.firstChild;
    while (node)
    {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
}

function getNodesInRange(range) {
    var start = range.startContainer;
    var end = range.endContainer;
    var commonAncestor = range.commonAncestorContainer;
    var nodes = [];
    var node;

    // walk parent nodes from start to common ancestor
    for (node = start.parentNode; node; node = node.parentNode)
    {
        nodes.push(node);
        if (node == commonAncestor)
            break;
    }
    nodes.reverse();

    // walk children and siblings from start until end is found
    for (node = start; node; node = getNextNode(node))
    {
        nodes.push(node);
        if (node == end)
            break;
    }

    return nodes;
}

function expandSelectionToWordIfPossible() {
	return (getFullWord(mouseEvt)); // see wordAtInsertionPt.js

}

// Add handlers for marker updating etc.
if (markerMainElement !== null)
	{
	markerMainElement.addEventListener("click", delayedUpdateMarkersAndTOC);
	markerMainElement.addEventListener("dblclick", noteWasDoubleClick);
	window.addEventListener("resize", updateScrollbarMarkers);

	markerMainElement.addEventListener("mouseup", resetTopNavPosition);
	if (tocMainElement !== null)
		{
		tocMainElement.addEventListener("mouseup", resetTopNavPosition);
		}
	}

// Show/hide highlight markers on scroll bar.

function removeAllScrollbarHighlights(mClass) {
	removeElementsByClass(mClass);
}

function removeElementsByClass(className) {
	let elements = document.getElementsByClassName(className);
	while (elements.length > 0)
		{
		elements[0].parentNode.removeChild(elements[0]);
		}
}

// Put little rectangles in the scrollbar region, placed vertically in proportion to
// where the selected text occurrences happen in the document.
function markHitsInScrollbar(textClassName, scrollHitClassName) {	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	// Fine-tuning: gray area of scrollbar is shortened by the up and down arrows, and starts
	// after the top arrow. There are no arrows on an iPad.
	let mainScrollY = markerMainElement.scrollTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	// let usableTextHeight = textViewableHeight - 2*arrowHeight;

	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowHeight = 18;
	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				//arrowHeight = Math.round(widthDifference) + 1;
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}
	
	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	// indicatorHeight: ideal height of the thumb. In practice the actual thumb height
	// needs to be a minimum of about 18 pixels.
	////let indicatorHeight = (textViewableHeight / mainScrolllHeight) * textViewableHeight;

	let elements = document.getElementsByClassName(textClassName);
	for (let i = 0; i < elements.length; ++i)
		{
		let hitElement = elements[i];
		let elementBoundRect = hitElement.getBoundingClientRect();
		let textHitY = elementBoundRect.top;
		let positionInDoc = mainScrollY + textHitY - yTop;
		let positionRatio = positionInDoc / mainScrolllHeight;
		let relativeMarkerPos = positionRatio * usableTextHeight;
		let absMarkerPos = relativeMarkerPos + yTop + arrowHeight;

		let mk = document.createElement("mark");
		mk.setAttribute("class", scrollHitClassName);
		mk.style.top = absMarkerPos + "px";
		markerMainElement.appendChild(mk);
		}
}

function evtIsInScrollbar(evt) {
	let result = false;
	if (evt !== null)
		{
		if (evt.offsetX >= markerMainElement.clientWidth
				|| evt.offsetY >= markerMainElement.clientHeight)
			{
			// Mouse down over scroll element
			result = true;
			}
		}
	return (result);
}

// Remember the element that starts the selection.
function storeSelection() {
	theSelection.ltRange = lightrange.saveSelection();
}

// Look at siblings of startElement, advance until element does not contain a <mark> subelement.
function showStoredSelections() {
	lightrange.restoreSelection(theSelection.ltRange);
}

function saveSelection() {
	if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.getRangeAt && sel.rangeCount) {
	        return sel.getRangeAt(0);
	    }
	} else if (document.selection && document.selection.createRange) {
	    return document.selection.createRange();
	}
return null;
}

// Set theSelection.currentSelectionElem to TD holding selection, 
// and clone and remove the TD - only if not "too big".
function hideSelectionRow() {
	theSelection.currentSelectionElem = null;
	theSelection.currentSelPreviousSibling = null;
	if (theSelection.selectionIsTooBig)
		{
		return;
		}

	let currSelection = window.getSelection();
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.commonAncestorContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem === null)
			{
			selectionTooBig = true;
			}
		else
			{
			theSelection.currentSelectionElem = tdElem;
			theSelection.currentSelPreviousSibling = theSelection.currentSelectionElem.previousSibling;
			}
		}

	if (theSelection.currentSelectionElem !== null)
		{
		let currSelTD = theSelection.currentSelectionElem;
		let i = 0;
		theSelection.selChildren = [];
		
		findRangeTopContainers();
		
		let tdChildNodes = currSelTD.childNodes;
		for  (let j = 0; j < tdChildNodes.length; ++j)
			{
			
			if (tdChildNodes[j] === theSelection.topStartNode)
				{
				recordStartSelIndexes(j, tdChildNodes[j]);
				}

			if (tdChildNodes[j] === theSelection.topEndNode)
				{
				recordEndSelIndexes(j, tdChildNodes[j]);
				}
			}
		
		
		while (theSelection.currentSelectionElem.firstChild)
			{
			theSelection.selChildren[i++] = theSelection.currentSelectionElem.firstChild.cloneNode(true);
			theSelection.currentSelectionElem.removeChild(theSelection.currentSelectionElem.firstChild);
			}
		}
	}

function findRangeTopContainers() {
	let topStartNode = theSelection.ltRange.startContainer;
	while (topStartNode !== null && topStartNode.parentNode !== null && topStartNode.parentNode.nodeName !== "TD")
		{
		topStartNode = topStartNode.parentNode;
		}
	
	let topEndNode = theSelection.ltRange.endContainer;
	while (topEndNode !== null && topEndNode.parentNode !== null && topEndNode.parentNode.nodeName !== "TD")
		{
		topEndNode = topEndNode.parentNode;
		}
	
	theSelection.topStartNode = topStartNode;
	theSelection.topEndNode = topEndNode;
}

function recordStartSelIndexes(topIdx, topNode) {
	theSelection.startNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.startNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.startNodeIndexes.unshift(topIdx);
	theSelection.startNodeOffset = theSelection.ltRange.startOffset;
}

function recordEndSelIndexes(topIdx, topNode) {
	theSelection.endNodeIndexes = [];
	let topStartNode = theSelection.ltRange.startContainer;
	
	while (topStartNode !== null && topStartNode !== topNode
			&& topStartNode.parentNode.nodeName !== "TD")
		{
		// Figure out where we are in list of parent's children
		let parentNode = topStartNode.parentNode;
		let kids = parentNode.childNodes;
		for (let i = 0; i < kids.length; ++i)
			{
			if (kids[i] === topStartNode)
				{
				theSelection.endNodeIndexes.unshift(i);
				}
			}
		topStartNode = topStartNode.parentNode;
		}
	theSelection.endNodeIndexes.unshift(topIdx);
	theSelection.endNodeOffset = theSelection.ltRange.endOffset;
}

// Restore display of any TD element holding the current selection.
function showSelectionRow() {
	if (theSelection.currentSelectionElem !== null && theSelection.selChildren.length)
		{
		for (let i = 0; i < theSelection.selChildren.length; ++i)
			{
			theSelection.currentSelectionElem.appendChild(theSelection.selChildren[i]);
			
			
			if (i === theSelection.startNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setStart(node, theSelection.startNodeOffset);
				}
			if (i === theSelection.endNodeIdx)
				{
				let node = theSelection.currentSelectionElem.lastChild;
				theSelection.ltRange.setEnd(node, theSelection.endNodeOffset);
				}
			}
		
		restoreRangeStartsAndEnds();
		}
}

function restoreRangeStartsAndEnds() {
	let topNode = theSelection.currentSelectionElem;
	
	let drillDownNode = topNode;
	for (let i = 0; i < theSelection.startNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.startNodeIndexes[i]];
		}
	theSelection.ltRange.setStart(drillDownNode, theSelection.startNodeOffset);
	
	drillDownNode = topNode;
	for (let i = 0; i < theSelection.endNodeIndexes.length; ++i)
		{
		drillDownNode = drillDownNode.childNodes[theSelection.endNodeIndexes[i]];
		}
	theSelection.ltRange.setEnd(drillDownNode, theSelection.endNodeOffset);
}

// Skip along through childNodes until we hit a MARK and accumulated offset is
// >= targetOffset.
// Returns MARK node or null in [0], accumulated textLength in [1].
function markToSelect(node, textLength, targetOffset, markerNode) {
	if (markerNode !== null)
		{
		return ([ markerNode, textLength ]);
		}
	let lengthSoFar = textLength;
	let tagName = node.nodeName;
	if (tagName === "MARK")
		{
		let markLength = node.textContent.length;
		if (lengthSoFar + markLength >= targetOffset)
			{
			return ([ node, lengthSoFar + markLength ]);
			}
		}

	// Still here, go deeper.
	let numChildren = node.childNodes.length;
	if (numChildren == 0)
		{
		lengthSoFar += node.textContent.length;
		}
	else
		{
		for (let i = 0; i < node.childNodes.length; ++i)
			{
			let markNodeToSelectArray =
					markToSelect(node.childNodes[i], lengthSoFar, targetOffset, markerNode);
			lengthSoFar = markNodeToSelectArray[1];
			if (markNodeToSelectArray[0] !== null)
				{
				markerNode = markNodeToSelectArray[0];
				break;
				}
			}
		}

	return ([ markerNode, lengthSoFar ]);
}

// Link clicked means don't update markers for user's text selection.
function notelinkClicked(evt) {
	if (hintboxClicked)
		{
		hintboxClicked = false;
		return;
		}
	linkClicked = false;

	let target = evt.target || null;
	// Click might be on an "edit" pencil (edit1.png), move up to parent.
	if (target !== null && target.nodeName === "IMG")
		{
		target = target.parentNode;
		}
	if (target !== null && target.nodeName === "A")
		{
		linkClicked = true;
		}
	else
		{
		if (typeof target.id !== 'undefined')
			{
			if (target.id === "hintbox")
				{
				linkClicked = true;
				}
			}
		}
}

// The "hint" box shows a possibly reduced view of an image in text views. On an iPad,
// it's clickable. If clicked, we treat it as a click on a link and don't change the
// marked text.
function noteHintboxClicked() {
	hintboxClicked = true;
	linkClicked = true;
}

let addHintTimer; // onMobile, to keep trying addHintboxListener() until it succeeds.

function addHintboxListener() {
	let tooltipElement = document.getElementById("hintbox");
	if (tooltipElement !== null)
		{
		tooltipElement.addEventListener("touchstart", noteHintboxClicked);
		clearInterval(addHintTimer);
		}
}

if (onMobile)
	{
	addHintTimer = setInterval(addHintboxListener, 200);
	}

document.addEventListener("mousedown", notelinkClicked);

ready(finishStartup);

</script>
<script type="text/javascript">
// showHideTOC.js: shrink/expand the Table Of Contents via a "#tocShrinkExpand" element
// at top of the Table Of Contents. The TOC isn't shrunk away to nothing, a bit is left
// visible (which reminds one that it's there, and makes the design easier:).
// TODO this is a bit fragile, scrollContentsList and scrollTextRightOfContents are hard-coded.
// However, any ambitious person who changes those has bought the rights to full maintenance.
// This is used in the Viewer (intramine_file_viewer_cm.pl) where a view has a table of contents,
// and in gloss2html.pl (which generates HTML from .txt, and there is always a table of contents).

// Shrink/expand the Table Of Contents when the "#tocShrinkExpand" element is clicked.
function toggleTOC(toggleElem) {
	// Avoid spurious highlighting after TOC toggle causes redraw.
	if (document.activeElement !== null)
		{
		document.activeElement.blur();
		}

	let elementToAdjust = document.getElementById('scrollContentsList');
	let textElement = document.getElementById('scrollTextRightOfContents');
	let divContainer = elementToAdjust.parentElement;
	if (elementToAdjust !== null && textElement !== null)
		{
		let theTopPos = firstVisibleLineNumber(textElement);
		let widthStrTOC = window.getComputedStyle(elementToAdjust, null).getPropertyValue('width');
		let widthStrParent = window.getComputedStyle(divContainer, null).getPropertyValue('width');
		let widthTOC = parseInt(widthStrTOC, 10);
		let widthParent = parseInt(widthStrParent, 10);
		let oldTocWidthPC = 100 * widthTOC / widthParent;
		let shrinkIt = (oldTocWidthPC < 10) ? false : true;
		let newWidthTOCPC, newWidthTextPC, newTextLeftPC;
		if (shrinkIt)
			{
			newWidthTOCPC = 5;
			newWidthTextPC = 93.5;
			newTextLeftPC = 6;
			}
		else
			{
			newWidthTOCPC = 23;
			newWidthTextPC = 75.5;
			newTextLeftPC = 24;
			}
		elementToAdjust.style.width = newWidthTOCPC + "%";
		textElement.style.width = newWidthTextPC + "%";
		textElement.style.left = newTextLeftPC + "%";
		restoreTopPosition(textElement, theTopPos);

		// Especially for CodeMirror, force a recalc.
		window.dispatchEvent(new Event('resize'));

		// Redo initial scrollbar markers
		if (initialSearchHitsAreShowing)
			{
			removeInitialHighlights();
			highlightInitialItems();
			}

		}

	return (false);
}

function addTocToggle(idToggle) {
	let scrollContentsElement = document.getElementById('scrollContentsList');
	if (scrollContentsElement !== null)
		{
		// Add in the shrink/expand element at top of Table Of Contents.
		let toggleElem;
		if (b64ToggleImage !== '')
			{
			toggleElem = createElementFromHTML("<img src=\"data:image/png;base64,"
						+ b64ToggleImage + "\" id='" + idToggle + "'>");
			}
		else
			{
			toggleElem = createElementFromHTML("<img src='707788g4.png' id='" + idToggle + "'>");
			}
		// scrollContentsElement.insertBefore(toggleElem, elementToAdjust.childNodes[0]);
		document.body.insertBefore(toggleElem, document.body.firstChild);
		toggleElem.addEventListener('click', function() {
			toggleTOC(toggleElem);
		});

		// Default position is absolute relative to the page. We want to set the top so that it
		// nestles down in the Table of Contents at the top, where 20px of margin has been
		// left for it. Top should be just below the horizontal rule that divides upper part
		// of page from content proper.
		let rule = document.getElementById("rule_above_editor");
		let pos = getPosition(rule);
		let toggleTop = pos.y + 4;

		toggleElem.style.top = toggleTop + "px";
		}
}

// Get line number of first visible line in text.
// For non-codemirror, look for table row with bounding rect top that is
// >= elem bounding rect top. On that row, <td n="(\d+)" gives the line number.
function firstVisibleLineNumber(elem) {
	let topPos = 0;
	let undefCounter = 0;

	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let firstVisibleLineNum = myCodeMirror.lineAtHeight(rect.top, "window");
		topPos = firstVisibleLineNum;
		}
	else
		{
		topPos = quickGetPosition(elem, true);
		}

	return (topPos);
}

// For non-CodeMirror files, the text of the document is in one or more consecutive <table>s.
// - find first table whose top is too far, look at the one before that - or if top
// is dead on, use that one.
// - check every 100th or 10th entry for element that is too far or dead on
// - if checked 100, now check every 10th starting from the "100" row just found
// - step through from there to find the exact number, skipping shrunk rows that have no number.
// "elem" is the main text holder, having tables as direct children (at least one).
function quickGetPosition(elem, getTop) {
	if (elem === null)
		{
		return;
		}
	let topPos = 0;
	let undefCounter = 0;
	let enclosingRect = elem.getBoundingClientRect();
	let enclosingRectTopOrBot = (getTop) ? enclosingRect.top : enclosingRect.bottom;
	
	let kids = null;
	for (; undefCounter < 100; ++undefCounter)
		{
		if (typeof(elem.children) !== 'undefined')
			{
			kids = elem.children;
			break;
			}
		}
	
	if (typeof(elem.children) === 'undefined')
		{
		//console.log("ERROR could not get children!");
		return(0);
		}
	
	let done = false;
	
	// If "kids" doesn't have a table, try going down one more level - this is needed
	// with "index.txt" for example, which has a "special-index-wrapper" holding its one table
	if (!elementHasTableAsChild(kids))
		{
		kids = elem.children[0].children;
		}
	
	// - find first table whose BOTTOM is past the top or bottom of the view.
	let table = wantedTableForPosition(kids, enclosingRectTopOrBot, getTop);
	
	if (table !== null)
		{
		let tableBody = getTableBody(table);
		
		if (tableBody !== null)
			{
			let rowNum = getRowCandidateAbovePosition(table, 100, 10, enclosingRectTopOrBot);
			topPos = rowTopPosition(table, rowNum, 10, enclosingRectTopOrBot);
			}
		}
	
	return (topPos);
}

function getTableBody(table) {
	let tableBody = null;
	
	if (table !== null)
		{
		let tableKids = table.children; // there should be only one TBODY
		for (let m = 0; m < tableKids.length; ++m)
			{
			if (tableKids[m].nodeName === "TBODY")
				{
				tableBody = tableKids[m];
				break;
				}
			}
		}
	
	return(tableBody);
}

//Look at last row bottom in each table body, return current table if its bottom is
// at or past enclosingRectTopOrBot.
// // Sometimes rounding errors get in the way, hence the "Math.ceil()"
function wantedTableForPosition(topChildren, enclosingRectTopOrBot, getTop) {
	let wantedTable = null;
	
	
	//enclosingRectTopOrBot -= 1;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		if (!getTop)
			{
			//console.log("Checking table " + i);
			}
		
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = getTableBody(topChildren[i]);
			
			if (tableBody !== null)
				{
				let rows = tableBody.children;
				if (rows.length > 0)
					{
					let rowToCheck = rows.length - 1;
					let bounding = rows[rowToCheck].getBoundingClientRect();
					let bottomCeiling = Math.ceil(bounding.bottom);
					
					if (!getTop)
						{
						//console.log("Checking table " + i + " row " + rowToCheck + " bottom " + bottomCeiling + " of " + rows.length + " against " + enclosingRectTopOrBot);
						}
					
					if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			} // if (tagName === "TABLE")
		}
		
	if (wantedTable === null)
		{
		if (!getTop)
			{
			//console.log("Did NOT find bottom!");
			}
		
		if (topChildren.length > 0)
			{
			if (getTop)
				{
				for (let i = 0; i < topChildren.length; ++i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			else // bottom
				{
				for (let i = topChildren.length - 1; i >= 0; --i)
					{
					let tagName = topChildren[i].nodeName;
					if (tagName === "TABLE")
						{
						wantedTable = topChildren[i];
						break;
						}
					}
				}
			}
		else
			{
			console.log("ERROR no tables in document!");
			}
		}
	
	return(wantedTable);
}

function elementHasTableAsChild(topChildren) {
	let result = false;
	
	for (let i = 0; i < topChildren.length; ++i)
		{
		let tagName = topChildren[i].nodeName;
		if (tagName === "TABLE")
			{
			result = true;
			break;
			}
		}
	
	return(result);
}

// We are looking for a row with bottom above or at enclosingRectTopOrBot.
// 
// Starting at table bottom, look upwards rowInc at a time for the row bottom
// that is <= enclosingRectTopOrBot. If none found, the default 0 is returned.
// There are two passes, crude (100 row jumps) and fine (10 row jumps).
function getRowCandidateAbovePosition(table, majorInc, minorInc, enclosingRectTopOrBot) {
	let wantedRow = 0;
	let lastRowCheckedInFirstPass = 0;
	let tableBody = getTableBody(table);
	
	if (tableBody !== null)
		{
		let rows = tableBody.children;
		let rowToCheck = rows.length - 1;
		
		// Look backwards in big jumps, from end of table.
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= majorInc;
				}
			}
		
		// Look backwards in small jumps, from wantedRow just found plus majorInc.
		rowToCheck = wantedRow + majorInc;
		if (rowToCheck > rows.length - 1)
			{
			rowToCheck = rows.length - 1;
			}
		while (rowToCheck >= wantedRow)
			{
			let bounding = rows[rowToCheck].getBoundingClientRect();
			if (bounding.bottom <= enclosingRectTopOrBot)
				{
				wantedRow = rowToCheck;
				break;
				}
			else
				{
				rowToCheck -= minorInc;
				}
			}
		}
	
	return(wantedRow);
}

// startRow should have a bottom that is <= enclosingRectTopOrBot, and not be too far
// above one that's >. Look down from startRow for a row with bottom >= enclosingRectTopOrBot.
// Try to adjust down slightly from that to a row with TOP >= enclosingRectTopOrBot.
// On a complete fail, which can happen when scrolling to bottom of document, take
// the last line number in the table. What can I say, it works.
function rowTopPosition(table, startRow, minorInc, enclosingRectTopOrBot) {
	let topPos = 0;
	let tableBody = getTableBody(table);
	
	enclosingRectTopOrBot = Math.ceil(enclosingRectTopOrBot);
	
	if (tableBody !== null)
		{
		let foundIt = false;
		let rows = tableBody.children;
		let lastToCheck = startRow + minorInc + 1;
		if (lastToCheck > rows.length)
			{
			lastToCheck = rows.length;
			}
		
		for (let j = startRow; j < lastToCheck; ++j)
			{
			let bounding = rows[j].getBoundingClientRect();
			let bottomCeiling = Math.ceil(bounding.bottom);
			if (bottomCeiling >= enclosingRectTopOrBot) // too far, or just far enough
				{
				let lastToCheck_K =  j + 3;
				if (lastToCheck_K > rows.length)
					{
					lastToCheck_K = rows.length;
					}
				for (let k = j; k < lastToCheck_K; ++k)
					{
					let bounding_K = rows[k].getBoundingClientRect();
					let bottomCeiling_K = Math.ceil(bounding_K.bottom);
					if (bottomCeiling_K > enclosingRectTopOrBot)
						{
						let contents = rows[k].innerHTML;
						let lineNumMatch = /^<td n="(\d+)/.exec(contents);
						if (lineNumMatch !== null)
							{
							topPos = parseInt(lineNumMatch[1], 10);
							foundIt = true;
							break;
							}
						}
					}
				
				// For the very last line, it's possible that the bottom of the last row
				// won't be visible (perhaps by only a pixel or so) or that it's a shrunk
				// row with no line number. If so, look up starting at row j for a row
				// with visible top and a line number.
				if (!foundIt)
					{
					for (let k = j; k < lastToCheck_K; ++k)
						{
						let bounding_K = rows[k].getBoundingClientRect();
						if (bounding_K.top >= enclosingRectTopOrBot)
							{
							let contents = rows[k].innerHTML;
							let lineNumMatch = /^<td n="(\d+)/.exec(contents);
							if (lineNumMatch !== null)
								{
								topPos = parseInt(lineNumMatch[1], 10);
								foundIt = true;
								break;
								}
							}
						}
					}
				
				break;
				}
			}
		
		if (!foundIt)
			{
			// Find last row with a line number.
			let k = rows.length - 1;
			while (k >= 0)
				{
				let contents = rows[k].innerHTML;
				let lineNumMatch = /^<td n="(\d+)/.exec(contents);
				if (lineNumMatch !== null)
					{
					topPos = parseInt(lineNumMatch[1], 10);
					foundIt = true;
					break;
					}
				--k;
				}
			}
		} // if (tableBody !== null)
	
	return (topPos);
}

function lastVisibleLineNumber(elem) {
	let bottomPos = 0;
	let undefCounter = 0;
	
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let lastVisibleLineNum = myCodeMirror.lineAtHeight(rect.bottom, "window");
		bottomPos = lastVisibleLineNum;
		}
	else
		{
		bottomPos = quickGetPosition(elem, false);
		}

	return (bottomPos);
}

// Not used.
// Mainly for Non-CodeMirror, calculate an average line height in pixels.
function getAverageLineHeight(elem) {
	let averageHeight = 14; // Use an arbitrary but not horrible default.
	if (usingCM)
		{
		averageHeight = myCodeMirror.defaultTextHeight();
		}
	else
		{
		let enclosingRect = elem.getBoundingClientRect();
		let visiblePixels = enclosingRect.bottom - enclosingRect.top;
		let firstVisibleLineNum = firstVisibleLineNum(elem);
		let lastVisibleLineNum = lastVisibleLineNumber(elem);
		let numVisibleLines = lastVisibleLineNum - firstVisibleLineNum;
		if (numVisibleLines > 0 && visiblePixels > 0)
			{
			averageHeight = visiblePixels / numVisibleLines;
			}
		}
	
	return(averageHeight);
}

// Calc a rough value for nonCM, based on average line height in pixels.
function getNumVisibleLines(elem) {
	let numVisibleLines = 0;
	
	if (usingCM)
		{
		let rect = myCodeMirror.getWrapperElement().getBoundingClientRect();
		let firstVisibleLineNum = myCodeMirror.lineAtHeight(rect.top, "window");
		let lastVisibleLineNum = myCodeMirror.lineAtHeight(rect.bottom, "window");
		numVisibleLines = lastVisibleLineNum - firstVisibleLineNum + 1;
		}
	else
		{
		let enclosingRect = elem.getBoundingClientRect();
		let enclosingRectTop = enclosingRect.top;
		let enclosingRectBottom = enclosingRect.bottom;
		let numVisiblePixels = enclosingRectBottom - enclosingRectTop;
		
		}
	return(numVisibleLines);
}

function restoreTopPosition(elem, topPos) {
	if (usingCM)
		{
		jumpToLine(topPos + 2, false);
		}
	else
		{
		restoreTopPositionNonCM(elem, topPos);
		}
}

// Find <tr> in elem with <td n="topPos"..., scroll it into view.
function restoreTopPositionNonCM(elem, topPos) {
	let children = elem.children;
	let done = false;

	for (let i = 0; i < children.length; ++i)
		{
		let tagName = children[i].nodeName;
		if (tagName === "TABLE")
			{
			let tableBody = children[i].children;
			for (let k = 0; k < tableBody.length; ++k)
				{
				let tableChildren = tableBody[k].children;
				for (let j = 0; j < tableChildren.length; ++j)
					{
					let contents = tableChildren[j].innerHTML;
					let lineNumMatch = /^<td n="(\d+)/.exec(contents);
					if (lineNumMatch !== null)
						{
						let currentLine = lineNumMatch[1];
						if (currentLine == topPos)
							{
							tableChildren[j].scrollIntoView();
							// Set top of nav to zero, fixes an iPad scroll problem where nav
							// goes off the top.
							let nav = document.getElementById("nav"); // nope nav.style.top = 0;
							if (nav !== null)
								{
								nav.parentNode.scrollTop = 0;
								}
							done = true;
							break;
							}
						}
					}
				if (done)
					{
					break;
					}
				}
			}
		if (done)
			{
			break;
			}
		}
}

window.addEventListener("load", function() {
	addTocToggle('tocShrinkExpand');
});

</script>
<script type="text/javascript">
/**
 * indicator.js: Mainly a scroll indicator for PCs and iPads in non-codemirror views (text, perl etc).
 */

// 'indicator is for mobile', 'indicatorPC' is for a regular Windows box.
let indicatorElem = onMobile ? document.getElementById('indicator') : document.getElementById('indicatorPC');
let otherIndicatorElem = onMobile ? document.getElementById('indicatorPC') : document.getElementById('indicator');
//let indicatorElem = document.getElementById('indicator');
let indicatorM = 0; // for mobile and non-mobile
let lazySetUpMobileIndicator = JD.debounce(setUpMobileIndicator, 100);
let lazyMobileScroll = JD.debounce(scrollMobileIndicator, 500);
let lazyResetTopNavPosition = JD.debounce(resetTopNavPosition, 400);

let lazySetUpIndicator = JD.debounce(setUpIndicator, 100);
let lazyScroll = JD.debounce(scrollIndicator, 500);
let arrowHeight = 18; // Needed for PC only.

otherIndicatorElem.style.display = 'none';


if (onMobile) // iPad only supported for now....
	{
	//console.log("WE ARE MOBILE.");
	window.addEventListener("load", lazySetUpMobileIndicator);
	window.addEventListener("resize", lazySetUpMobileIndicator);
	markerMainElement.addEventListener("scroll", scrollMobileIndicator);
	markerMainElement.addEventListener("touchend", lazyResetTopNavPosition);

	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement !== null)
		{
		tocElement.addEventListener("touchend", lazyMobileScroll);
		tocElement.addEventListener("touchend", lazyResetTopNavPosition);
		}
	}
else
	{
	window.addEventListener("load", lazySetUpIndicator);
	window.addEventListener("resize", lazySetUpIndicator);
	
	markerMainElement.addEventListener("scroll", scrollIndicator);
	window.addEventListener("load", addHideIndicatorScrollListener);
	
	hideIt("search-button");
	hideIt("small-tip");
	hideIt("undo-button");
	hideIt("redo-button");
	}

// Mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;

	if (mainScrolllHeight > textViewableHeight)
		{
		let indicatorHeight = (textViewableHeight / mainScrolllHeight) * textViewableHeight;
		indicatorM =
				(textViewableHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);

		if (indicatorHeight < 2.0)
			{
			indicatorHeight = 2.0;
			}
		indicatorElem.style.height = indicatorHeight + "px";
		}

	lazyMobileScroll();
}

// Non-mobile, mainly set indicatorM. "M" as in y = Mx + b.
function setUpIndicator() {
	if (onMobile)
		{
		return;
		}
	
	let rect = markerMainElement.getBoundingClientRect();
	let yTop = rect.top;
	let yBottom = rect.bottom;
	let textViewableHeight = yBottom - yTop;
	let mainScrolllHeight = markerMainElement.scrollHeight;
	
	let viewWidth = rect.right - rect.left;
	let widthDifference = viewWidth - markerMainElement.clientWidth;
	let heightDifference = textViewableHeight - markerMainElement.clientHeight;
	let haveVerticalScroll = (widthDifference > 2) ? true : false;
	let haveHorizontalScroll = (heightDifference > 2) ? true : false;

	let arrowMultiplier = 2;
	if (typeof window.ontouchstart !== 'undefined')
		{
		arrowHeight = 2;
		}
	else
		{
		if (haveVerticalScroll)
			{
			if (widthDifference > 6.0 && widthDifference < 30.0)
				{
				arrowHeight = widthDifference;
				}
			if (haveHorizontalScroll)
				{
				arrowMultiplier = 3;
				}
			}
		else
			{
			arrowHeight = 0;
			}
		}

	let usableTextHeight = textViewableHeight - arrowMultiplier * arrowHeight;
	
	if (mainScrolllHeight > usableTextHeight)
		{
		let indicatorHeight = usableTextHeight * (textViewableHeight/(mainScrolllHeight));
		
		// Show the indicator only if thumb is too small to reflect actual page size.
		if (indicatorHeight <= 20)
			{
			indicatorM =
					(usableTextHeight - indicatorHeight) / (mainScrolllHeight - textViewableHeight);
	
			if (indicatorHeight < 2.0)
				{
				indicatorHeight = 2.0;
				}
			indicatorElem.style.height = indicatorHeight + "px";
			}
		else
			{
			indicatorM = 0;
			}
		}
	else
		{
		indicatorM = 0;
		}

	lazyScroll();
	
	setTimeout(function() {
				hideIndicator();
			}, 1000);
}

// Mobile, set indicatorElem.top
function scrollMobileIndicator() {
	if (!onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop;
		indicatorElem.style.top = newThumbTop + "px";
		}
}

// Non-mobile, set indicatorElem.top
function scrollIndicator() {
	if (onMobile)
		{
		return;
		}

	if (indicatorM > 0)
		{
		indicatorElem.style.display = 'block';
		
		let mainScrollY = markerMainElement.scrollTop;
		let rect = markerMainElement.getBoundingClientRect();
		let yTop = rect.top;
		let newThumbTop = indicatorM * mainScrollY + yTop + arrowHeight;
		indicatorElem.style.top = newThumbTop + "px";
		}
}

// Add a scroll listener that hides the 'indicatorPC' box after a few seconds.
let isScrollingIndicator = null;
function addHideIndicatorScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrollingIndicator );
	
			// Set a timeout to run after scrolling ends
			isScrollingIndicator = setTimeout(function() {
				// Run the callback
				hideIndicator();
			}, 3000);
			});
		}
}

function hideIndicator() {
	indicatorElem.style.display = 'none';
}

</script>
<script type="text/javascript">
// toggle.js: toggle between two positions in a document.
// Track "proximal" (current) and "distal" (previous) positions
// in response to all changes in scrolled position.
// If it's a small move, update the proximal position.
// If it's a big move, call the new position proximal, and the old
// proximal becomes distal.
// Toggle: scroll distal into view, and switch proximal with distal.

let proximalLineNumber = 1;	// "here"
let distalLineNumber = 1;	// "there"
let bigMoveLineLimit = 100; // Big move vs small move

function toggle() {
	//console.log("Toggle click");
	//console.log("Toggle, before: here " + proximalLineNumber + ", there " + distalLineNumber);
	let tempNum = proximalLineNumber;
	proximalLineNumber = distalLineNumber;
	distalLineNumber = tempNum;
	let el = document.getElementById(cmTextHolderName);
	//console.log("Toggle, AFTER: here " + proximalLineNumber + ", there " + distalLineNumber);
	restoreTopPositionNonCM(el, proximalLineNumber);
}

function updateTogglePositions() {
	let el = document.getElementById(cmTextHolderName);
	let myStartLine = firstVisibleLineNumber(el);
	//console.log("update myStartLine " + myStartLine);
	if (myStartLine < 1)
		{
		myStartLine = 1;
		}
	//console.log("update here " + proximalLineNumber);
	let linesScrolled = proximalLineNumber - myStartLine;
	//console.log("update lines scrolled: " + linesScrolled);
	if (linesScrolled < 0)
		{
		linesScrolled = -linesScrolled;
		}
	if (linesScrolled <= bigMoveLineLimit)
		{
		//console.log("small move, here " + proximalLineNumber + ", there " + distalLineNumber + " before update");
		proximalLineNumber = myStartLine;
		//console.log(" here is " + proximalLineNumber + " after update.)");
		}
	else
		{
		//console.log("Big move! here " + proximalLineNumber + ", there " + distalLineNumber + " before update")
		distalLineNumber = proximalLineNumber;
		proximalLineNumber = myStartLine;
		//console.log("AFTER BIG MOVE: here "+ proximalLineNumber + ", there " + distalLineNumber);
		}
	//console.log("Toggle position update top line " + myStartLine);
}

// Borrowed from
//https://gomakethings.com/detecting-when-a-visitor-has-stopped-scrolling-with-vanilla-javascript/
let isScrolling = null;
function addToggleScrollListener() {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function() {
			// Clear our timeout throughout the scroll
			window.clearTimeout( isScrolling );
	
			// Set a timeout to run after scrolling ends
			isScrolling = setTimeout(function() {
				// Run the callback
				updateTogglePositions();
			}, 66);
			});
		}
}

// Set the number of lines that counts as a "big move"
// (meaning a real change of position, not just an adjustment
// of current position).
// Called by viewerStart.js#doResize() and on load by
// viewerStart.js#reJumpAndHighlight().
function updateToggleBigMoveLimit() {
	let el = document.getElementById(cmTextHolderName);
	let firstVisibleLineNum = firstVisibleLineNumber(el);
	let lastVisibleLineNum = lastVisibleLineNumber(el);
	
	// Problem, sometimes lastVisibleLineNumber() can return 0.
	if (lastVisibleLineNum === 0)
		{
		lastVisibleLineNum = lastVisibleLineNumber(el);
		if (lastVisibleLineNum === 0)
			{
			//console.log("EARLY EXIT in updateToggleBigMoveLimit!");
			return;
			}
		}
	
	let numVisibleLines = lastVisibleLineNum - firstVisibleLineNum;
	if (numVisibleLines <= 10)
		{
		bigMoveLineLimit = 20;
		//console.log("TINY WINDOW!");
		}
	else
		{
		bigMoveLineLimit = numVisibleLines + 10;
		}
	
	//console.log("First vis: " + firstVisibleLineNum);
	//console.log("LAST vis: " + lastVisibleLineNum);
	//console.log("Big move limit: " + bigMoveLineLimit);
}

window.addEventListener("load", addToggleScrollListener);


</script>
<script type="text/javascript">
/**
 * scrollTOC.js: when a heading is clicked in text, scroll corresponding Table of Contents
 * entry into view. Non-CodeMirror files only. See cmScrollTOC.js for CodeMirror handling.
 */

// Scroll the Table of Contents:
// if click was in text content, to heading at or just before line clicked.
// if scrolling, to heading at or just after first visible line.
function scrollTocEntryIntoView(evt, weAreScrolling) {
	let tocElem = null;

	if (!weAreScrolling)
		{
		let lineNum = lineNumberforAnchor();
		if (lineNum >= 0)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}
		else
			{
			// Treat as for scrolling.
			weAreScrolling = true;
			}
		}
	
	if (weAreScrolling)
		{
		let el = document.getElementById(cmTextHolderName);
		let limitLineNum = lastVisibleLineNumber(el) + 1;
		let lineNum = firstVisibleLineNumber(el);
		tocElem = getTocElemAfterLineNumber(lineNum, limitLineNum);
		if (tocElem === null)
			{
			tocElem = getTocElemForLineNumber(lineNum);
			}
		}
		
	if (tocElem !== null)
		{
		tocElem.scrollIntoView({block: 'center'});
		updateTocHighlight(tocElem);
		}
}


// Get text line number for current selection anchor, or -1.
function lineNumberforAnchor() {
	let currSelection = window.getSelection();
	if (currSelection === null)
		{
		return(-1);
		}
	
	let lineNum = -1;
	let rangeCount = currSelection.rangeCount;
	if (rangeCount > 0)
		{
		let currRange = currSelection.getRangeAt(0);
		let commonA = currRange.startContainer;
		let tdElem = commonA;
		
		while (tdElem !== null && tdElem.nodeName !== "TD")
			{
			tdElem = tdElem.parentNode;
			}
		if (tdElem !== null)
			{
			let previousElem = tdElem.previousSibling;
			if (previousElem !== null)
				{
				let tdLineNum = previousElem.getAttribute("n");
				if (tdLineNum !== null)
					{
					lineNum = tdLineNum;
					}
				}
			}
		}
	
	return (lineNum);
}

// Return TOC element that is at or closest above the text line number.
// Called for mouse/touch in actual text content.
// Typical non-CodeMirror TOC entry:
// <li class="h2" im-text-ln="123">
function getTocElemForLineNumber(lineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let previousTocElem = null;
	let previousTocElemLineNum = 0;
	let lowestNumberedElem = null;
	let lowestNumberedElemNumber = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum <= lineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (previousTocElemLineNum <  tocLineNum)
				{
				previousTocElemLineNum = tocLineNum;
				previousTocElem = tocEntries[i];
				}
			
			if (lowestNumberedElemNumber == 0 || lowestNumberedElemNumber > tocLineNum)
				{
				lowestNumberedElemNumber = tocLineNum;
				lowestNumberedElem = tocEntries[i];
				}
			}
		}
	
	if (tocElem === null && previousTocElem !== null)
		{
		tocElem = previousTocElem;
		}
	else if (tocElem === null && lowestNumberedElem !== null)
		{
		tocElem = lowestNumberedElem;
		}
	
	return(tocElem);
}

// Return TOC element that is at or closest *below* the text line number.
// Called after a scroll. Element must be before the visible bottom of the page,
// otherwise we should be looking upwards from the top of page for the heading
// that applies to the current position.
function getTocElemAfterLineNumber(lineNum, limitLineNum) {
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocElem = null;
	let nextTocElem = null;
	let nextTocElemLineNum = 999999;
	let lastTocElem = null;
	let lastTocElemLineNum = 0;
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		let li = tocEntries[i];
		let tocLineNum = parseInt(li.getAttribute("im-text-ln"), 10); // IntraMine line number of heading in main text
		if (!isNaN(tocLineNum) && tocLineNum >= lineNum && tocLineNum <= limitLineNum)
			{
			if (tocLineNum == lineNum)
				{
				tocElem = tocEntries[i];
				break;
				}
			else if (nextTocElemLineNum >  tocLineNum)
				{
				nextTocElemLineNum = tocLineNum;
				nextTocElem = tocEntries[i];
				}
			
			if (lastTocElemLineNum < tocLineNum)
				{
				lastTocElemLineNum = tocLineNum;
				lastTocElem = tocEntries[i];
				}
			}
		}

	
	if (tocElem === null && nextTocElem !== null)
		{
		tocElem = nextTocElem;
		}
	else if (tocElem === null && lastTocElem !== null)
		{
		tocElem = lastTocElem;
		}
	
	return(tocElem);
}

let scrollingForToc = null;
function addTocScrollListener(evt) {
	let el = document.getElementById(cmTextHolderName);
	if (el !== null)
		{
		el.addEventListener("scroll", function(evt) {
			// Clear our timeout throughout the scroll
			window.clearTimeout( scrollingForToc );
	
			// Set a timeout to run after scrolling ends
			scrollingForToc = setTimeout(function() {
				// Run the callback.
				scrollTocEntryIntoView(evt, true);
			}, 66);
			});
		}
}

// Not used.
function addTocAndToggleListeners(evt) {
	let el = document.getElementById(cmTextHolderName);
	el.addEventListener("scroll", function(evt) {
		// Clear our timeout throughout the scroll
		window.clearTimeout( scrollingForToc );
	
		// Set a timeout to run after scrolling ends
		scrollingForToc = setTimeout(function() {
			// Run the callbacks.
			scrollTocEntryIntoView(evt, true);
			updateTogglePositions();
		}, 66);
	});
}

function updateTocHighlight(elem) {
	if (elem === null)
		{
		return;
		}
	let tocElement = document.getElementById("scrollContentsList");
	if (tocElement === null)
		{
		return(null);
		}
	
	let tocEntries = tocElement.getElementsByTagName("li");
	for (let i = 0; i < tocEntries.length; i++)
		{
		if (hasClass(tocEntries[i], selectedTocId))
			{
			removeClass(tocEntries[i], selectedTocId);
			}
		}
	
	addClass(elem, selectedTocId);
}

window.addEventListener("load", addTocScrollListener);
//window.addEventListener("load", addTocAndToggleListeners);


</script>
</body></html>
