Linker
========

The Linker service turns text into hyperlinks on file names or paths, in text and source files. It returns either a new version of the text with links in place, or a JSON summary of the links and where they should go.

This is an IntraMine server, so it uses the swarmserver.pm module together with "%RequestAction" entries to handle requests from users and other servers, and JavaScript XMLHttpRequest calls. However, it does not display web pages, and has no JavaScript.

Although the Linker can handle any number of lines of text, it's used by IntraMine's Viewer as an "on demand" service, to add links to text that is newly shown, either when a view of a file is brought up or after a scroll. Typically the view of a source or text file shows under 100 lines at a time, so the load on the Linker is fairly minimal.

Main back-end Perl files
========================
 - intramine_linker.pl
 - reverse_filepaths.pm provides full file links for file names or partial or full paths to files.
 - win_wide_filepaths.pm is included here and in many other servers, to properly handle file names and paths that contain non-ASCII characters of the UTF-16 sort that Windows uses.
 
There are no associated JavaScript files.
 
Calling the Linker
==================
There are three main subs that respond to JavaScript requests: one for CodeMirror views, one for non-CodeMirror (mainly .txt and Perl) views, and a "one shot" that turns a single partial path into a full path.

intramine_linker.pl#CmLinks() is used for CodeMirror-based file displays, and expects its $formH->{'text'} argument to hold the text that wants links. It returns an array in JSON format that summarizes the links it finds. The structure of each array entry can be seen in intramine_linker.pl#DoCodeMirrorReps() - basically where in the text the link should go, and the replacement link proper.

intramine_linker.pl#NonCmLinks() also expects the text to be marked up in its its $formH->{'text'} argument. But it returns a copy of the text with the links in place. You can see how the replacement is done in intramine_linker.pl#DoTextReps(). In-place replacement is used for text, Perl, .md (standard markdown), .log, and .bat files.

Both CmLinks() and NonCmLinks() examine one line of text at a time from the perhaps multi-line text passed in, and then look especially for file extensions such as ".pl" that almost always identify the end of a file name. From there, they looks backwards in the text for a maximal string that can be identified as the rightmost part of a known file path. intramine_linker.pl#GetLongestGoodPath() calls reverse_filepaths.pm#FullPathInContextNS() on each candidate string to see if the string corresponds to a known file path, and as mentioned the longest candidate string wins.

In IntraMine, the Linker is called only through JavaScript. The routine is to call back to the Linker using an XMLHttpRequest() with a "req=cmLinks" argument for text in a CodeMirror view, and "req=nonCmLinks" for text from a non-CodeMirror view.

Here's a summary of the main Linker subs and how they are triggered from JavaScript.
TABLE Linker subs and their JavaScript callers
Linker subroutine       	Linker %RequestAction	Called by	Purpose						JavaScript example
CmLinks				req|cmLinks	Viewer	Links for CodeMirror views	cmAutoLinks.js#addAutoLinks()
NonCmLinks			req|nonCmLinks		Viewer	Links for .txt and Perl views etc	autoLinks.js#addAutoLinks()
FullPathForPartial	req|autolink		Files	Single link for a partial path	files.js#openAutoLink()

Under the hood
==============

Autolink sequence overview
------------------
1. New lines of text come into view in a text view of a file generated by IntraMine's Viewer, either on load or after a scroll.
2. (JS) addAutoLinks() is called in response, and sends an XMLHttpRequest to retrieve link markup for all visible lines. Note there are two instances of addAutoLinks, one in cmAutoLinks.js for CodeMirror-based displays, and one in autoLinks.js for all other views that can have links.
2.1 For CodeMirror file displays, cmAutoLinks.js#addAutoLinks() sends a request containing "req=cmLinks". This calls intramine_viewer.pl#CmLinks(), passing all the lines of text received in $formH->{'text'}.
2.2 For non-CodeMirror displays, autoLinks.js#addAutoLinks() sends a request containing "req=nonCmLinks". This calls intramine_viewer.pl#NonCmLinks(), again passing all the text received.
3. Both CmLinks() and nonCmLinks() ultimately call AddWebAndFileLinksToLine(), which in turn eventually calls reverse_filepaths.pm#FullPathInContextNS() on each link candidate, with links constructed if a full path is found.
3.1 For CodeMirror displays, the links are returned as JSON and added as a markup overlay on top of the CodeMirror view - see cmAutoLinks.js#requestLinkMarkupWithPort().
3.2 For non-CodeMirror displays, the links replace file path mentions in the returned text - see autoLinks.js#requestLinkMarkupWithPort().
4. For all views the line numbers that have received links are remembered, and lines are only marked up or altered once. This is managed by autoLinks.js#rememberLinesSeen() and cmAutoLinks.js#rememberLinesSeen() etc, using the "lineSeen" array.

Stepping through text to find links
----------------------------------
We get down to brass tacks in intramine_linker.pl#AddWebAndFileLinksToLine() which looks for linkable text on a single line.
AddWebAndFileLinksToLine() calls EvaluateLinkCandidates() to identify text that looks like links, and replacement links for the text. Then DoTextReps() or DoCodeMirrorReps() is called to do the replacement: DoTextReps() puts the links directly in the text to be returned, whereas DoCodeMirrorReps() constructs an array of positions and link text that will be returned as JSON to the calling JavaScript function, with links done in an overlay layer.

EvaluateLinkCandidates() loops over a line of text looking for text in quotes, or a potential file extension, or the http etc that can start a web link. Unquoted file links can all be identified easily enough by finding the file extension first, and then working backwards to accumulate the longest partial path that represents a valid file mention.

For a path to be "valid" it needs to be either a full path or a partial path that's a good match for an indexed path. Expansion of link text being checked to the longest compatible partial path is handled by RememberTextOrImageFileMention(), which in turn calls GetLongestGoodPath() to extend the link text leftwards from the file extension, calling FullPathInContextNS() at each step to see if it's a good path. GetLongestGoodPath() typically checks as far left as it can, to pick up the longest file mention.

reverse_filepaths.pm#FullPathInContextNS() sequence
---------------------------------------------------
reverse_filepaths.pm#FullPathInContextNS() is just a "clean up" wrapper on FullPathFromPartialOrFullPath(), which does the real work of identifying the best matching full path.

reverse_filepaths.pm#FullPathFromPartialOrFullPath() sequence
-------------------------------------------------------------
In reverse_filepaths.pm#FullPathFromPartialOrFullPath() the work of collecting full paths finally pays off. FullPathFromPartialOrFullPath() receives a partial path in "$partialPath", and the path of a context folder in "$contextDir", and returns either the best matching full path or an empty string. Recognition of a partial path happens in five steps:
1. Is $partialPath ($partialPath) a full path? Return  it.
2. ExactInContext(): Does $partialPath match fully on the right with a full path, and is there some overlap on the left between full path and $contextDir? Return the full path that has best overlap, shortest on a tie.
3. ExactFullPath(): Does $partialPath match fully on the right with a full path, ignoring context? Return first one found.
4. RelaxedInContext(): Do $partialPath folder names all match those in a full path, regardless of position, with some overlap on the left between full path and $contextDir? Return the full path that has best overlap, shortest on a tie.
5. RelaxedFullPath(): Do $partialPath folder names all match those in a full path, regardless of position, ignoring context? Return first one found.
If all of the above checks fail, return ''.
Note where the supplied $partialPath is ambiguous, the wrong path can be returned.

For a couple of examples of how links are detected, see
 - "Stealing from IntraMine.txt#Full path for partial path example"
 - "Stealing from IntraMine.txt#Another partial path example, without help from context"


---
contents.txt
---


