# tocmaker.pm: generate a "table of contents" for a directory, and its subdirectories,
# intended for viewing with IntraMine.
# (Well, I left this in for a while and never consulted the "table of contents", so it's
# not currently implemented by IntraMine. Play with it if you like :)
# File names are listed alphabetically, with full paths on the right, slapped in a table to make it look pretty.
# When IntraMine is running, intramine_filewatcher.pl#IndexChangedFiles() eventually calls ReMakeTocForDir() here
# to rebuild any tables of contents affected by new or deleted files in watched directories.

package tocmaker;
require Exporter;
@ISA = qw(Exporter);

use strict;
use warnings;
use utf8;
use FileHandle;
use File::Find;
use Path::Tiny qw(path);
#use lib path($0)->absolute->parent->child('libs')->stringify;
use lib ".";
use common;
use win_wide_filepaths;

#my $Extensions = '(p[lm]|pod|txt|js|css|cpp?|c|cc|h|go|bat|html?|log|out|qdoc|textile|cs|vb|java|class|py|php)';
#my $IMAGEEXTLIST = qr,(png|gif|jpe?g|ico)$,;

my %NameForFullFilePath;

# Rebuild a table of contents, but only if it already exists.
sub ReMakeTocForDir {
	my ($dirPath, $tocFileName) = @_;
	$dirPath =~ s!\\!/!g;
	$dirPath =~ s!/$!!g;
	my $tocPath = $dirPath . '/' . $tocFileName;
	if (FileOrDirExistsWide($tocPath) == 1)
	#if (-f $tocPath)
		{
		MakeTocForDir($dirPath, $tocFileName);
		}
	}

# Make a '---toc---.txt' file for a directory.
sub MakeTocForDir {
	my ($dirPath, $tocFileName) = @_;
	$dirPath =~ s!\\!/!g;
	$dirPath =~ s!/$!!g;
	if (FileOrDirExistsWide($dirPath) == 0)
	#if (!(-d $dirPath))
		{
		return;
		}

	%NameForFullFilePath = ();
	finddepth(\&_DoOne, $dirPath);
	my $tocPath = $dirPath . '/' . $tocFileName;
	$NameForFullFilePath{$tocPath} = $tocFileName;
	DumpToc($tocPath, \%NameForFullFilePath);
	}

sub DumpToc {
	my ($tocPath, $nameForFullPathH) = @_;
	my $fileH = new FileHandle("> $tocPath") or
		return;
	binmode($fileH, ":utf8");
	my $dirProper = DirectoryFromPathTS($tocPath);
	print $fileH "$dirProper\n===================\n";
	print $fileH "(autogenerated - do not edit)\n";
	print $fileH "TABLE\n";
	print $fileH "File\tFull path\n";
	foreach my $fullPath (sort keys %$nameForFullPathH)
		{
		print $fileH "$nameForFullPathH->{$fullPath}\t$fullPath\n";
		# Quotes are no longer needed with Zero Overhead Linking: print $fileH "\"$nameForFullPathH->{$fullPath}\"\t\"$fullPath\"\n";
		}
	close($fileH);
	}

use ExportAbove;

sub _DoOne {
	my $sourceFileName = $_;
    my $sourceFileFullPath = $File::Find::name;
    if ($_ eq "." || FileOrDirExistsWide($sourceFileFullPath) != 1)
    #if ($_ eq "." || ! -f $sourceFileFullPath)
		{
		;# not a file
		return;
		}
    # else it's a file.
    else
        {
		my $pathForwardSlashes = $sourceFileFullPath;
		$pathForwardSlashes =~ s![\\]!/!g;
        $NameForFullFilePath{$pathForwardSlashes} = $sourceFileName;
        }
	}


1;

