# html2gloss.pm: convert HTML to Gloss.
# Intended for converting HTML from Pod::Simple::HTML.
# Really not suitable for any other use, there are too
# many special issues when translating from HTML with its
# many different nested elements to Gloss, where every
# line of output is going to end up in a table cell.
# Called by intramine_viewer.pl#GetPrettyPod().

package html2gloss;
use strict;
use warnings;

# We'll be entertaining ourselves with an "event" parser,
# where the events are start tag, text, end tag.
# Gosh it's so much more fun than using a pull parser.
use HTML::Parser();
our @ISA = qw(HTML::Parser);

my %blockTag;
# Text is accumulated as ordinary, main <li> entry, or
# an <li> continuation paragraph (of which there may be several).
# Anchors and <pre> also get some special handling.
# But there are only two top-level types of text,
# remembered in in $self->{'TEXT_TYPE'}:
my $kMain = 1; # Anything not in a <li> item at any depth
my $kLi = 2;

# Make a new html2gloss parser, and init some variables.
# Actual parsing is done by htmlToGloss() just below.
sub new {
    my ($proto) = @_;
    my $class = ref($proto) || $proto;

	# Register the event handlers
    my $self = HTML::Parser->new( api_version => 3,
        start_h => [\&startHandler, "self, tagname, attr"],
        end_h => [\&endHandler, "self, tagname"],
        text_h => [\&textHandler, "self, dtext, is_cdata"]
        );

    bless ($self, $class);
    $self->utf8_mode(1);

	$self->{'TEXT_TYPE'} = $kMain; 		# Everything but text in list items
    #$self->{DEPTH} = 0; 				# HTML tag nesting depth
    @{$self->{LINES}} = ();				# Final output lines
    $self->{CURRENT_LINE} = '';			# $kMain text accumulator.
	@{$self->{LI_PENDING_LINES}} = ();	# <li> item accumulator.
	@{$self->{LI_DEPTH}} = ();			# Depth of each list line, 1 for main item,  2 for sub item.
    @{$self->{TAG}} = ();				# HTML start tags
    @{$self->{CLASS}} = ();				# class attribute or ''
    @{$self->{HREF}} = ();				# href, from <a>
	@{$self->{NAME}} = ();				# name, from <a>
    @{$self->{LIST_TYPE}} = ();			# 'ul' or 'ol'
    $self->{OLNUMBER} = 1; 				# post increment
    $self->{HEADING_LEVEL} = 0;			# h2 h3 h4
    $self->{IN_PRE} = 0; 				# in a <pre> element.
	$self->{AT_PARA_START} = 0; 		# At the start of a <p>, no text seen yet.
	$self->{IN_PARAGRAPH} = 0;			# We are anywhere in a <p>
	$self->{LI_STARTED_BLANK} = 0; 		# Stay on same line if <li> starts with spaces
	$self->{AT_START_OF_LI} = 0;		# but start new line always if at start of a list item
	# Track last indent used and last close tag, for indenting <pre> element lines.
	$self->{LAST_INDENT} = '';			# Last set of indents used ()
	$self->{DD_FORCED_CLOSED} = '';		# Recalculate LAST_INDENT for a main 'pre' if 'dd' is forced closed.
	$self->{LAST_CLOSED_TAG} = '';		# Well, that's the last closed HTML tag.

    InitBlockTags(); # block (vs inline) element names
    
    return $self;
    }

# Do the actual conversion from HTML (generated by Pod::Simple::HTML)
# to Gloss.
sub htmlToGloss {
	my ($self, $inTextR, $outTextR) = @_;

	$$outTextR = '';
    $self->{OUT} = $outTextR;
    $self->parse($$inTextR);

    $$outTextR = join("\n", @{$self->{LINES}});

	#print("TAG stack at end: |@{$self->{TAG}}|\n");
    }

# Track tag name, class, name, id, and href attributes.
# Note those must be pushed and popped together.
sub startHandler {
    my ($self, $tag, $attr) = @_;

	my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';

	# Set text accumulator. Mainly about <li> items.
	if ($tag eq 'li')
		{
		$self->{'TEXT_TYPE'} = $kLi;
		$self->{AT_START_OF_LI} = 1;
		}

	# Some cleanup: sometimes </dd> is missing.
	if ($tag eq 'dt' || $tag eq 'dd')
		{
		if ($toptag eq 'dd')
			{
			# Invoke endHandler for 'dd', </dd> is missing
			endHandler($self, 'dd');
			$self->{DD_FORCED_CLOSED} = 1;
			}
		}


	# Push the things we need onto stack, all synchronized.
	# endHandler pops them all at once.
    push @{$self->{TAG}}, $tag;
    my $class = defined($attr->{'class'}) ? $attr->{'class'}: '';
    push @{$self->{CLASS}}, $class;
    my $href = defined($attr->{'href'}) ? $attr->{'href'}: '';
    push @{$self->{HREF}}, $href;
	my $name = defined($attr->{'name'}) ? $attr->{'name'}: '';
    push @{$self->{NAME}}, $name;
	my $id = defined($attr->{'id'}) ? $attr->{'id'}: '';
    push @{$self->{ID}}, $id;

	# Put list type on the LIST_TYPE stack. Lists and
	# sublists are handled, but not deeper.
	# Note there aren't any 'ol' lists to handle at this time.
    if ($tag eq 'ul' || $tag eq 'ol')
        {
		
        push @{$self->{LIST_TYPE}}, $tag;
        }
    elsif ($tag eq 'pre')
        {
		# <pre> elements are emitted all at once, broken
		# into separate lines. See EmitPre().
        $self->{IN_PRE} = 1;
        }

	# <code> start
	elsif ($tag eq 'code' || $tag eq 'codehere')
		{
		AddText($self, '*!*');
		}
	# <a> anchor start
	elsif ($tag eq 'a')
		{
		# Sometimes, alas, anchors are unnecissarily nested.
		# We don't like that, end any old anchor before
		# starting a new one.
		if ($toptag eq 'a')
			{
			my $textA = EndAnchor($self->{HEADING_LEVEL});
			AddText($self, $textA);
			}
		StartAnchor($href, $name, $id);
		}
	# <p> start
	elsif ($tag eq 'p')
		{
		$self->{AT_PARA_START} = 1;
		$self->{IN_PARAGRAPH} = 1;
		}
    }

sub endHandler {
    my ($self, $tag) = @_; # $tag isn't needed

    if (!defined(${$self->{TAG}}[-1]))
        {
		# Could there be text accumulated?
        return;
        }
    
	# All tracking stackes are pushed and popped as one.
    my $ptag = pop @{$self->{TAG}};
    my $class = pop @{$self->{CLASS}};
    my $href = pop @{$self->{HREF}};
	my $name = pop @{$self->{NAME}};
	my $id = pop @{$self->{ID}};

	# LAST_CLOSED_TAG is used when emitting a <pre> element,
	# to avoid indenting in some cases. See EmitPre().
	$self->{LAST_CLOSED_TAG} = $ptag;

	# A "push" tag signals it's time to output one or more lines.
	# These are all block-level tags. Some few tags are set to
	# not push, eg 'ul', because all text is handled before
	# those tags are seen. See InitBlockTags().
    if (IsPushTag($ptag))
        {
		# "Ordinary" text, held in $self->{CURRENT_LINE}.
		if ($self->{'TEXT_TYPE'} == $kMain)
			{
			# Avoid dumping empty or just \s*\-\s* lines if in <li>.
			if ($self->{CURRENT_LINE} !~ m!^(_INDT_)*\s*\-?\s*$!)
			#if ($self->{CURRENT_LINE} !~ m!^\s*\-?\s*$!)
				{
				# Convert all newlines to spaces
				$self->{CURRENT_LINE} =~ s!\n! !g;
				# Strip leading spaces.
				$self->{CURRENT_LINE} =~ s!((_INDT_)+)\s+!$1!;
				$self->{CURRENT_LINE} =~ s!^\s+!!;

				# Remove _INDT_ from headings.
				if ($self->{HEADING_LEVEL})
					{
					$self->{CURRENT_LINE} =~ s!_INDT_!!g;
					}

				push @{$self->{LINES}}, $self->{CURRENT_LINE};

				# Add appropriate underline for headings (for Gloss).
				if ($self->{HEADING_LEVEL})
					{
					my $headingLevel = $self->{HEADING_LEVEL};
					if ($headingLevel == 1)
						{
						push @{$self->{LINES}}, '=====';
						}
					elsif ($headingLevel == 2)
						{
						push @{$self->{LINES}}, '-----';
						}
					else
						{
						push @{$self->{LINES}}, '~~~~~';
						}
					}
				}
			$self->{HEADING_LEVEL} = 0;
			$self->{CURRENT_LINE} = '';
			}
		# End of a list item. Lines for it are stacked
		# in the LI_PENDING_LINES array.
		# Note there may be a sublist.
		elsif ($self->{TEXT_TYPE} == $kLi && $ptag eq 'li')
			{
			my $numPendingLines = @{$self->{LI_PENDING_LINES}};
			if ($numPendingLines)
				{
				EmitListItem($self);
				@{$self->{LI_PENDING_LINES}} = ();
				@{$self->{LI_DEPTH}} = ();
				}
			$self->{'TEXT_TYPE'} = $kMain;
			}

		if ($ptag eq 'p')
			{
			$self->{AT_PARA_START} = 0;
			$self->{IN_PARAGRAPH} = 0;
			}
        }
    elsif ($ptag eq 'ul' || $ptag eq 'ol')
        {
		# Pod doesn't do 'ol', but I've left it in for now.
        pop @{$self->{LIST_TYPE}};
        if ($ptag eq 'ol')
            {
            $self->{OLNUMBER} = 1;
            }
        }
    elsif ($ptag eq 'pre') # Note 'pre' is not a push tag.
        {
        $self->{IN_PRE} = 0;
        }
	# <code>text</code> is transformed to *!*text*!*for Gloss.
	elsif ($ptag eq 'code' || $ptag eq 'codehere')
		{
		AddText($self, '*!*');
		}
	# Attributes for <a> elements are picked up in the startHandler
	# above, text is accumulated in textHandler, and the final
	# anchor for Gloss goes out to the CURRENT_LINE or LI_PENDING_LINES
	# on seeing </a> here.
	elsif ($ptag eq 'a')
		{
		my $textA = EndAnchor($self->{HEADING_LEVEL});
		AddText($self, $textA);
		}

	# Clear $self->{AT_START_OF_LI} unconditionally
	$self->{AT_START_OF_LI} = 0;
	# Clear notice that 'dd' was forced to close, if we're not closing a 'dd'.
	if ($ptag ne 'dd')
		{
		$self->{DD_FORCED_CLOSED} = 0;
		}
    }

# Text is accumulated here by calls to AddText().
#
# A <pre> element, however, comes in all at once as one chunk of text, and
# is immediately put on the main output array
# of lines (LINES) or on the stack of pending list item lines
# (LI_PENDING_LINES) by EmitPre().
#
# All headings in Pod have anchors <a> inside with a class of 'u',
# and the anchor contains the actual text of the heading.
sub textHandler {
    my ($self, $text, $iscdata) = @_;
    if ($iscdata)
        {
        return;
        }

    my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';
    my $tagAbove = defined(${$self->{TAG}}[-2]) ? ${$self->{TAG}}[-2]: '';
    my $topClass = defined(${$self->{CLASS}}[-1]) ? ${$self->{CLASS}}[-1]: '';
    my $topHref = defined(${$self->{HREF}}[-1]) ? ${$self->{HREF}}[-1]: '';

	# Translate '*'' in text to '__A__' (translated back in intramine_viewer.pl#AddWEmphasis()).
	# '*' is used to signal *italic*, **bold**, and *!*code*!* for Gloss.
	$text =~ s!\*!__A__!g;

	# If we're in a <pre> don't process any contained tags.
    if ($self->{IN_PRE})
        {
		EmitPre($self, $text);
		return;
        }

	# Skip if we're not in a tag.
	if ($toptag eq '')
		{
		return;
		}
    
	if ($toptag eq 'a')
		{
		# Clean out embedded new lines.
		$text =~ s!\n! !g;

		if ($tagAbove =~ m!^h(\d)$!)
			{
			my $headingLevel = $1;
			
			if (index($topClass, 'u') == 0)
				{
				$self->{HEADING_LEVEL} = $headingLevel;
				}
			# Just dump out the heading, an underline will be added
			# above in endHandler so Gloss will pick up on it as a heading.
			AddText($self, $text);
			}
		elsif ($tagAbove eq 'dt')
			{
			# Have to rep trailing space, otherwise Gloss won't pick up on the text.
			# This will be turned back into a space by intramine_viewer.pl#GetPrettyTextContents().
			$text =~ s!\s$!_NBS_!;
			AddText($self, '**' . $text . '**');
			}
		else
			{
			AddText($self, $text);
			}
		}
	elsif ($toptag eq 'em' || $toptag eq 'i')
		{
		# Have to rep trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s$!_NBS_!;
		AddText($self, "*$text*");
		}
	elsif ($toptag eq 'strong' || $toptag eq 'b')
		{
		# Have to rep trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s$!_NBS_!;
		AddText($self, "**$text**");
		}
	# <code>: also see start and end handlers. <code> can contain <em> or <strong>
	elsif ($toptag eq 'code' || $toptag eq 'codehere')
		{
		# Experimental, replace newlines.
		$text =~ s!\n! !g;
		AddText($self, $text);
		}
	elsif ($toptag eq 'dt')
		{
		# Have to rep trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s$!_NBS_!;
		AddText($self, '**' . $text . '**');
		}
	else
		{
		AddText($self, $text);
		}
     }

# Anchor text is tracked separately (see AddAnchorText() below).
# List text is tracked in the @{$self->{LI_PENDING_LINES}} array.
# For text in <pre> elements see EmitPre().
# Other "ordinary" text is tracked in $self->{CURRENT_LINE}.
# Some attempt at indenting is donehere , for "ordinary" text: zero of more of _INDT_
# is added at line beginnings, and intramine_viewer.pl#GetPrettyTextContents()
# removes them while adding an appropriate class to the HTML such as 'onePodIndent'.
# Lists get ' - ' at the line start, which GetPrettyTextContents() converts to bullets.
# Note <pre> elements are indented separately according to the indent on
# the line above, in EmitPre().
sub AddText {
	my ($self, $text) = @_;

	if (InAnchor())
		{
		$text =~ s!\n!!g;
		AddAnchorText($text);
		}
	else
		{
		my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';

		my $stayOnSameLine = ($self->{'TEXT_TYPE'} == $kMain || $self->{AT_PARA_START} == 0 || $toptag eq 'li');
		#my $stayOnSameLine = ($self->{'TEXT_TYPE'} == $kMain || $self->{AT_PARA_START} == 0);

		# If we see text for a list item and we're at the start of the item, put
		# all of the text on one line. Pod::Simple::HTML will send it to us
		# in one chunk, but with embedded newlines. Other Pod converters take them out.
		my $dumpLiTextOnNewLine = 0; #($self->{'TEXT_TYPE'} == $kLi && $toptag eq 'li');
		if ($self->{AT_START_OF_LI})
			{
			$dumpLiTextOnNewLine = 1;
			# Just make sure we're at start of a list item only once:)
			$self->{AT_START_OF_LI} = 0;
			}

		if ($self->{IN_PARAGRAPH})
			{
			$text =~ s!\n! !g;
			}

		# Break $text into separate lines.
		my @lines;
		if ($dumpLiTextOnNewLine || $toptag eq 'li')
			{
			$text =~ s!\n! !g;
			$lines[0] = $text;
			}
		else
			{
			@lines = split(/\n/, $text);
			if (!defined($lines[0]))
				{
				$lines[0] = '';
				}
			}

		# List text, stacked up in the LI_PENDING_LINES array.
		if ($self->{'TEXT_TYPE'} == $kLi)
			{
			my $listDepth = @{$self->{LIST_TYPE}};
			if (($stayOnSameLine || $self->{LI_STARTED_BLANK}) && !$dumpLiTextOnNewLine)
				{
				my $numPendingLines = @{$self->{LI_PENDING_LINES}};

				if ($numPendingLines)
					{
					${$self->{LI_PENDING_LINES}}[$numPendingLines - 1] .= $lines[0];
					for (my $i = 1; $i < @lines; ++$i)
						{
						push @{$self->{LI_PENDING_LINES}}, $lines[$i];
						push @{$self->{LI_DEPTH}}, $listDepth;
						}
					}
				else
					{
					if ($text =~ m!^\s*$!)
						{
						$text =~ s!\n! !g;
						push @{$self->{LI_PENDING_LINES}}, $text;
						push @{$self->{LI_DEPTH}}, $listDepth;
						$self->{LI_STARTED_BLANK} = 2;
						}
					else
						{
						push @{$self->{LI_PENDING_LINES}}, $lines[0];
						push @{$self->{LI_DEPTH}}, $listDepth;
						for (my $i = 1; $i < @lines; ++$i)
							{
							push @{$self->{LI_PENDING_LINES}}, $lines[$i];
							push @{$self->{LI_DEPTH}}, $listDepth;
							}
						}
					}
				}
			else
				{
				for (my $i = 0; $i < @lines; ++$i)
					{
					push @{$self->{LI_PENDING_LINES}}, $lines[$i];
					push @{$self->{LI_DEPTH}}, $listDepth;
					}
				}

			# Clear AT_PARA_START, we have received text.
			$self->{AT_PARA_START} = 0;
			}
		# Main "ordinary" text: put in in the CURRENT_LINE, together
		# with an indent marker (zero of more of '_INDT_').
		else
			{
			# Add an indent marker, Gloss will add a class to do the indent.
			my $indentMarker = '';
			my $doingBlank = (($toptag eq 'dd' && $text =~ m!^\s*$!) || $toptag eq 'dl');
			if ($self->{CURRENT_LINE} =~ m!^\s*$! && !$doingBlank)
				{
				# If a paragraph 'p' follows a 'pre' or 'p', keep the same indent.
				if (   $toptag eq 'p'
					&& ($self->{LAST_CLOSED_TAG} eq 'pre' || $self->{LAST_CLOSED_TAG} eq 'p'))
					{
					$indentMarker = $self->{LAST_INDENT};
					}
				else
					{
					$indentMarker = IndentMarker($self);
					}
				}

			$self->{CURRENT_LINE} .= $indentMarker . $text;
			}
		}

	# Allow $self->{LI_STARTED_BLANK} to survive for two
	# trips through here.
	if ($self->{LI_STARTED_BLANK})
		{
		--$self->{LI_STARTED_BLANK};
		}
	}

# Emit all text in a <pre>, either straight to the LINES array
# for non-list text, or stacked on LI_PENDING_LINES for a list item.
# A <pre> text set of lines begins with '_SPR_' and ends with  '_EPR_'
# (Start PRe and End PRe).
# intramine_viewer.pl#GetPrettyTextContents() converts those markers to horizontal
# rules, and adds a bit of background color to the actual pre lines.
sub EmitPre {
	my ($self, $text) = @_;
	if (!$self->{IN_PRE})
		{
		return;
		}
	
	my $doingList = ($self->{TEXT_TYPE} == $kLi) ? 1: 0;

	# If we're in a list item, push lines on the LI_PENDING_LINES array.
	if ($doingList)
		{
		my $listDepth = @{$self->{LIST_TYPE}};

		push @{$self->{LI_PENDING_LINES}}, '_SPR_';
		push @{$self->{LI_DEPTH}}, $listDepth;
		my @lines = split(/\n/, $text);
		for (my $i = 0; $i < @lines; ++$i)
			{
			# Avoid triggering an unordered list or heading.
			# There's a zero width unicode space between $1 and $2.
			$lines[$i] =~ s!^(\s*)([=~+*-])!$1​$2!g;
			# Preserve whitespace in HTML without <pre>, as will
			# be the case in Gloss.
			$lines[$i] =~ s! ! !g;

			push @{$self->{LI_PENDING_LINES}}, $lines[$i];
			push @{$self->{LI_DEPTH}}, $listDepth;
			}
		push @{$self->{LI_PENDING_LINES}}, '_EPR_';
		push @{$self->{LI_DEPTH}}, $listDepth;
		}
	else # push lines out to the final LINES array immediately
		{
		# Indent lines of pre to match the line above the pre element.
		my $indentMarker = '';
		my $tagAbove = defined(${$self->{TAG}}[-2]) ? ${$self->{TAG}}[-2]: '';
		if ($tagAbove eq 'dd')
			{
			$indentMarker = IndentMarker($self);
			$self->{LAST_INDENT} = $indentMarker;
			$self->{DD_FORCED_CLOSED} = 0;
			}
		elsif ($self->{LAST_CLOSED_TAG} ne 'ul')
			{
			$indentMarker = $self->{LAST_INDENT};
			}
		push @{$self->{LINES}}, $indentMarker. '_SPR_';
		#push @{$self->{LINES}}, '---';
		my @lines = split(/\n/, $text);
		for (my $i = 0; $i < @lines; ++$i)
			{
			# Avoid triggering an unordered list or heading.
			# There's a zero width unicode space between $1 and $2.
			$lines[$i] =~ s!^(\s*)([=~+*-])!$1​$2!g;
			# Preserve whitespace in HTML without <pre>, as will
			# be the case in Gloss.
			# There's probably a non-breaking space in the line below.
			$lines[$i] =~ s! ! !g;
			push @{$self->{LINES}}, $indentMarker. $lines[$i];
			}
		push @{$self->{LINES}}, $indentMarker. '_EPR_';
		#push @{$self->{LINES}}, '---';
		}
	}

# List item:
# Unordered list item starts with ' - ', or ' -- ' for a subitem.
# Ordered list item starts with 'N. ' where N is one or more digits.
# Lines following the first line of a list item start with a space.,
# elsewhere called a "continuation paragraph".
# There may be main items (depth 1) or sub items (depth 2):
# issue a new list starter whenever the depth changes.
# As mentioned above, Pod::Simple::HTML doesn't produce <ol>.
sub EmitListItem {
	my ($self) = @_;
	
	my $previousDepth = 0;
	my $line;
	while (defined($line = shift @{$self->{LI_PENDING_LINES}}))
		{
		my $listDepth = shift @{$self->{LI_DEPTH}};
		if ($listDepth != $previousDepth)
			{
			my $starter = GetListStarter($self, $listDepth);
			push @{$self->{LINES}}, $starter . $line;
			}
		else
			{
			push @{$self->{LINES}}, " $line";
			}

		$previousDepth = $listDepth;
		}
	}

# For the first line in a list item only.
# Return ' - ' for a top-level list item,
# ' -- ' for a sub-item.
# See intramine_viewer.pl#UnorderedList() for the resulting HTML.
sub GetListStarter {
	my ($self, $listDepth) = @_;
	my $listType = defined(${$self->{LIST_TYPE}}[-1]) ? ${$self->{LIST_TYPE}}[-1]: 'ul';
	#my $listDepth = @{$self->{LIST_TYPE}};
	my $starter = '';

	if ($listType eq 'ul')
		{
		if ($listDepth == 1)
			{
			$starter = ' - ';
			}
		else # We only support two levels for lists.
			{
			$starter = ' -- ';
			}
		}
	else # 'ol'
		{
		$starter = "$self->{OLNUMBER}. ";
		$self->{OLNUMBER} += 1;
		}
	
	return($starter);
	}

# Return zero or more _INDT_ in a row, to be added at start of current line
# as an indentation level signal.
# These are counted, removed, and converted to a class when converting Gloss to HTML in
# intramine_viewer.pl#GetPrettyTextContents().
sub IndentMarker {
	my ($self) = @_;
	if ($self->{'TEXT_TYPE'} != $kMain)
		{
		return('');
		}
	
	my $indentMarker = '';
	if ($self->{CURRENT_LINE} =~ m!^\s*$!)
		{
		my $dlDepth = NestingDepth($self);
		if ($dlDepth >= 1)
			{
			if ($dlDepth == 1)
				{
				$indentMarker = '_INDT_';
				}
			elsif ($dlDepth == 2)
				{
				$indentMarker = '_INDT__INDT_';
				}
			elsif ($dlDepth == 3)
				{
				$indentMarker = '_INDT__INDT__INDT_';
				}
			else
				{
				$indentMarker = '_INDT__INDT__INDT__INDT_';
				}
			}
		}
	
	$self->{LAST_INDENT} = $indentMarker;

	return($indentMarker);
	}

# A count of how many 'dl', 'dd' are on the TAG stack.
# Add one for a 'p', don't ask me why it just works. Mostly.
sub NestingDepth {
	my ($self) = @_;
	my $numDlTags = 0;

	my $numTags = @{$self->{TAG}};
	my $sawParaOrPre = 0;
	for (my $i = 0; $i < $numTags; ++$i)
		{
		if (${$self->{TAG}}[$i] eq 'dl' || ${$self->{TAG}}[$i] eq 'dd')
			{
			++$numDlTags;
			}
		elsif (index(${$self->{TAG}}[$i], 'h') == 0)
			{
			$numDlTags = 0;
			last;
			}
		elsif (${$self->{TAG}}[$i] eq 'p' || ${$self->{TAG}}[$i] eq 'pre')
			{
			$sawParaOrPre = 1;
			}
		}

	if ($numDlTags && $sawParaOrPre)
		{
		$numDlTags += 1;
		}
	
	return($numDlTags);
	}

{ ##### Anchor handling
my $InAnchor;
my $AnchorText;
my $Href;
my $Name;
my $Id;

sub InitAnchorHandling {
	$InAnchor = 0;
	$AnchorText = '';
	$Href = '';
	$Name = '';
	$Id = '';
	}

sub InAnchor {
	return($InAnchor);
	}

sub StartAnchor {
	my ($href, $name, $id) = @_;
	$InAnchor = 1;
	$AnchorText = '';
	$Href = $href;
	$Name = $name;
	$Id = $id;
	}

sub AddAnchorText {
	my ($text) = @_;
	$AnchorText .= $text;
	}

# On </a>, return entire <a...>text</a> element.
# Or just the text if doing a heading or there are no attributes.
sub EndAnchor {
	my ($headingLevel) = @_;

	$InAnchor = 0;

	# If we're in a heading, just return the text.
	# Same if no attributes (it's Pod, there are not many rules).
	if ($headingLevel || ($Name eq '' && $Id eq '' && $Href eq ''))
		{
		return($AnchorText);
		}
	
	my $wholeAnchor = '';

	if ($Name ne '' || $Id ne '')
		{
		my $refOrId = '';

		if ($Name ne '')
			{
			# Encode to match href elsewhere.
			$Name =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02X", ord $1 /eg;
			$refOrId = 'id=' . $Name;
			}
		else
			{
			# Encode to match href elsewhere.
			$Id =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02X", ord $1 /eg;
			$refOrId = 'id=' . $Id;
			}

		$wholeAnchor = '_ALB_' . $AnchorText . '_ARB_' . '_ALP_' . $refOrId . '_ARP_';
		}
	elsif ($Href ne '')
		{
		# Convert underscores to hyphens in metacpan #anchors
		if ((my $metaIdx = index($Href, 'metacpan')) > 0)
			{
			my $hashIdx =  index($Href, '#');
			if ($hashIdx > $metaIdx)
				{
				my $upToHash = substr($Href, 0, $hashIdx);
				my $after = substr($Href, $hashIdx);
				$after =~ s!_!-!g;
				$Href = $upToHash . $after;
				}
			}
		my $refOrId = 'href=' . $Href;
		$wholeAnchor = '_LB_' . $AnchorText . '_RB_' . '_LP_' . $refOrId . '_RP_';
		}
	#else - unreachable, see above
	
	return($wholeAnchor);
	}
} ##### Anchor handling

# HTML block tags, from (blush) https://www.w3schools.com/html/html_blocks.asp.
# Note values are 0 for "list containers", we don't push a line in endHandler() for them
# because the actual text is in their contained elements.
# <pre> is also not a push tag, because its text is emitted all at once rather
# than being accumulated - see EmitPre() as I've mentioned a thousand times.
sub InitBlockTags {
    $blockTag{'address'} = 1;
    $blockTag{'article'} = 1;
    $blockTag{'aside'} = 1;
    $blockTag{'blockquote'} = 1;
    $blockTag{'canvas'} = 1;
    $blockTag{'dd'} = 1;
    $blockTag{'div'} = 1;
    $blockTag{'dl'} = 0;
    $blockTag{'dt'} = 1;
    $blockTag{'fieldset'} = 1;
    $blockTag{'figcaption'} = 1;
    $blockTag{'figure'} = 1;
    $blockTag{'footer'} = 1;
    $blockTag{'form'} = 1;
    $blockTag{'h1'} = 1;
    $blockTag{'h2'} = 1;
    $blockTag{'h3'} = 1;
    $blockTag{'h4'} = 1;
    $blockTag{'h5'} = 1;
    $blockTag{'h6'} = 1;
    $blockTag{'header'} = 1;
    $blockTag{'hr'} = 1;
    $blockTag{'li'} = 1;
    $blockTag{'main'} = 1;
    $blockTag{'nav'} = 1;
    $blockTag{'noscript'} = 1;
    $blockTag{'ol'} = 0;
    $blockTag{'p'} = 1;
    $blockTag{'pre'} = 0;
    $blockTag{'section'} = 1;
    $blockTag{'table'} = 1;
    $blockTag{'tfoot'} = 1;
    $blockTag{'ul'} = 0;
    $blockTag{'video'} = 1;
    }

sub IsBlockTag {
    my ($tag) = @_;
    my $result = defined($blockTag{$tag}) ? 1 : 0;
    return($result);
    }

# We don't want to emit a line for "list containers" or pre.
sub IsPushTag {
    my ($tag) = @_;
    my $result = defined($blockTag{$tag}) ? $blockTag{$tag} : 0;
    return($result);
    }

{ ##### Log HTML tags to a file
# For testing only, not used at the moment.
my $TagFilePath;
my $FileH;

sub StartLoggingTags {
	$TagFilePath = "C:/perlprogs/IntraMine/test/podtags.txt";
	$FileH = FileHandle->new("> $TagFilePath") or die("Could not make |$TagFilePath|!");
	}

sub LogItNow {
	my ($text) = @_;
	print $FileH "$text";
	}

sub StopLoggingTags {
	close($FileH);
	}
} ##### Log HTML tags to a file

1;

