# html2gloss.pm: convert HTML to Gloss.
# Intended for converting HTML from Pos::Simple::HTML.
# Really not suitable for any other use, there are too
# many special issues when translating from HTML with its
# many different nested elements to Gloss, where every
# line of output is going to end up in a table cell.
# Called by intramine_viewer.pl#GetPrettyPod().

package html2gloss;
use strict;
use warnings;

# We'll be entertaining ourselves with an "event" parser,
# where the events are start tag, text, end tag.
# Gosh it's so much more fun than using a pull parser.
use HTML::Parser();
our @ISA = qw(HTML::Parser);

my %blockTag;
# Text is accumulated as ordinary, main <li> entry, or
# an <li> continuation paragraph (of which there may be several).
# Used in $self->{'TEXT_TYPE'}.
my $kMain = 1; # Anything not in a <li> item at any depth
my $kLi = 2;

# Make a new html2gloss parser, and init some variables.
# Actual parsing is done by htmlToGloss() just below.
sub new {
    my ($proto) = @_;
    my $class = ref($proto) || $proto;

	# Register the event handlers
    my $self = HTML::Parser->new( api_version => 3,
        start_h => [\&startHandler, "self, tagname, attr"],
        end_h => [\&endHandler, "self, tagname"],
        text_h => [\&textHandler, "self, dtext, is_cdata"]
        );

    bless ($self, $class);
    $self->utf8_mode(1);

	$self->{'TEXT_TYPE'} = $kMain; 		# Everything but text in list items
    #$self->{DEPTH} = 0; 				# HTML tag nesting depth
    @{$self->{LINES}} = ();				# Final output lines
    $self->{CURRENT_LINE} = '';			# $kMain text accumulator.
	@{$self->{LI_PENDING_LINES}} = ();	# <li> item accumulator.
    @{$self->{TAG}} = ();				# HTML start tags
    @{$self->{CLASS}} = ();				# class attribute or ''
    @{$self->{HREF}} = ();				# href, from <a>
	@{$self->{NAME}} = ();				# name, from <a>
    @{$self->{LIST_TYPE}} = ();			# 'ul' or 'ol'
    $self->{OLNUMBER} = 1; 				# post increment
    $self->{HEADING_LEVEL} = 0;			# h2 h3 h4
    $self->{IN_PRE} = 0; 				# in a <pre> element.
	$self->{AT_PARA_START} = 0; 		# At the start of a <p>, no text seen yet.
	$self->{IN_PARAGRAPH} = 0;			# We are anywhere in a <p>
	$self->{LI_STARTED_BLANK} = 0; 		# Stay on same line if <li> starts with spaces

    InitBlockTags(); # block (vs inline) element names
    
    return $self;
    }

# Do the actual conversion from HTML (generated by Pod::Simple::HTML)
# to Gloss.
sub htmlToGloss {
	my ($self, $inTextR, $outTextR) = @_;

	$$outTextR = '';
    $self->{OUT} = $outTextR;
    $self->parse($$inTextR);
    $$outTextR = join("\n", @{$self->{LINES}});

	#print("TAG stack at end: |@{$self->{TAG}}|\n");
    }

# Track tag name, class, name, id, and href attributes.
# Note those must be pushed and popped together.
sub startHandler {
    my ($self, $tag, $attr) = @_;

	# Set text accumulator. Mainly about <li> items.
	if ($tag eq 'li')
		{
		$self->{'TEXT_TYPE'} = $kLi;
		}

	# Some cleanup: sometimes </dd> is missing.
	if ($tag eq 'dt' || $tag eq 'dd')
		{
		my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';
		if ($toptag eq 'dd')
			{
			# Invoke endHandler for 'dd', </dd> is missing
			endHandler($self, 'dd');
			}
		}


	# Push the things we need onto stack, all synchronized.
	# endHandler pops them all at once.
    push @{$self->{TAG}}, $tag;
    my $class = defined($attr->{'class'}) ? $attr->{'class'}: '';
    push @{$self->{CLASS}}, $class;
    my $href = defined($attr->{'href'}) ? $attr->{'href'}: '';
    push @{$self->{HREF}}, $href;
	my $name = defined($attr->{'name'}) ? $attr->{'name'}: '';
    push @{$self->{NAME}}, $name;
	my $id = defined($attr->{'id'}) ? $attr->{'id'}: '';
    push @{$self->{ID}}, $id;

    if ($tag eq 'ul' || $tag eq 'ol')
        {
        push @{$self->{LIST_TYPE}}, $tag;
        }
    elsif ($tag eq 'pre')
        {
        $self->{IN_PRE} = 1;
        }

	# <code> start
	elsif ($tag eq 'code' || $tag eq 'codehere')
		{
		AddText($self, '*!*');
		}
	# <a> anchor start
	elsif ($tag eq 'a')
		{
		StartAnchor($href, $name, $id);
		}
	elsif ($tag eq 'p')
		{
		$self->{AT_PARA_START} = 1;
		$self->{IN_PARAGRAPH} = 1;
		}
    }

sub endHandler {
    my ($self, $tag) = @_; # $tag isn't needed

    if (!defined(${$self->{TAG}}[-1]))
        {
		# Could there be text accumulated?
        return;
        }
    
    my $ptag = pop @{$self->{TAG}};
    my $class = pop @{$self->{CLASS}};
    my $href = pop @{$self->{HREF}};
	my $name = pop @{$self->{NAME}};
	my $id = pop @{$self->{ID}};

    if (IsPushTag($ptag))
        {
		if ($self->{'TEXT_TYPE'} == $kMain)
			{
			# Avoid dumping empty or just \s*\-\s* lines if in <li>.
			if ($self->{CURRENT_LINE} !~ m!^(_INDT_)*\s*\-?\s*$!)
			#if ($self->{CURRENT_LINE} !~ m!^\s*\-?\s*$!)
				{
				# Convert all newlines to spaces
				$self->{CURRENT_LINE} =~ s!\n! !g;
				# Strip leading spaces.
				$self->{CURRENT_LINE} =~ s!((_INDT_)+)\s+!$1!;
				$self->{CURRENT_LINE} =~ s!^\s+!!;

				# Remove _INDT_ from headings.
				if ($self->{HEADING_LEVEL})
					{
					$self->{CURRENT_LINE} =~ s!_INDT_!!g;
					}

				push @{$self->{LINES}}, $self->{CURRENT_LINE};

				# Add appropriate underline for headings (for Gloss).
				if ($self->{HEADING_LEVEL})
					{
					my $headingLevel = $self->{HEADING_LEVEL};
					if ($headingLevel == 1)
						{
						push @{$self->{LINES}}, '=====';
						}
					elsif ($headingLevel == 2)
						{
						push @{$self->{LINES}}, '-----';
						}
					else
						{
						push @{$self->{LINES}}, '~~~~~';
						}
					}
				}
			$self->{HEADING_LEVEL} = 0;
			$self->{CURRENT_LINE} = '';
			}
		elsif ($self->{TEXT_TYPE} == $kLi && $ptag eq 'li')
			{
			my $numPendingLines = @{$self->{LI_PENDING_LINES}};
			if ($numPendingLines)
				{
				EmitListItem($self);
				@{$self->{LI_PENDING_LINES}} = ();
				}
			$self->{'TEXT_TYPE'} = $kMain;
			}

		if ($ptag eq 'p')
			{
			$self->{AT_PARA_START} = 0;
			$self->{IN_PARAGRAPH} = 0;
			}
        }
    elsif ($ptag eq 'ul' || $ptag eq 'ol')
        {
		# Pod doesn't do 'ol', but I've left it in for now.
        pop @{$self->{LIST_TYPE}};
        if ($ptag eq 'ol')
            {
            $self->{OLNUMBER} = 1;
            }
        }
    elsif ($ptag eq 'pre') # Note 'pre' is not a push tag.
        {
        $self->{IN_PRE} = 0;
        }
	elsif ($ptag eq 'code' || $ptag eq 'codehere')
		{
		AddText($self, '*!*');
		}
	elsif ($ptag eq 'a')
		{
		my $textA = EndAnchor($self->{HEADING_LEVEL});
		AddText($self, $textA);
		}
    }

sub textHandler {
    my ($self, $text, $iscdata) = @_;
    if ($iscdata)
        {
        return;
        }

    my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';
    my $tagAbove = defined(${$self->{TAG}}[-2]) ? ${$self->{TAG}}[-2]: '';
    my $topClass = defined(${$self->{CLASS}}[-1]) ? ${$self->{CLASS}}[-1]: '';
    my $topHref = defined(${$self->{HREF}}[-1]) ? ${$self->{HREF}}[-1]: '';

	# If we're in a <pre> don't process any contained tags.
    if ($self->{IN_PRE})
        {
		EmitPre($self, $text);
		return;
        }

	# Skip if we're not in a tag.
	if ($toptag eq '')
		{
		return;
		}
    
	if ($toptag eq 'a')
		{
		# Clean out embedded new lines.
		$text =~ s!\n! !g;

		if ($tagAbove =~ m!^h(\d)$!)
			{
			my $headingLevel = $1;
			
			if (index($topClass, 'u') == 0)
				{
				$self->{HEADING_LEVEL} = $headingLevel;
				}
			# Just dump out the heading, an underline will be added
			# above in endHandler so Gloss will pick up on it as a heading.
			AddText($self, $text);
			}
		elsif ($tagAbove eq 'dt')
			{
			# Have to trim trailing space, otherwise Gloss won't pick up on the text.
			$text =~ s!\s+$!!;
			AddText($self, '**' . $text . '**');
			}
		else
			{
			AddText($self, $text);
			}
		}
	elsif ($toptag eq 'em' || $toptag eq 'i')
		{
		# Have to trim trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s+$!!;
		# Translate * in text to __A__ (translated back in intramine_viewer.pl#GetPrettyTextContent())
		$text =~ s!\*!__A__!g;
		AddText($self, "*$text*");
		}
	elsif ($toptag eq 'strong' || $toptag eq 'b')
		{
		# Have to trim trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s+$!!;
		# Translate * in text to __A__ (translated back in intramine_viewer.pl#GetPrettyTextContent())
		$text =~ s!\*!__A__!g;
		AddText($self, "**$text**");
		}
	# <code>: also see start and end handlers. <code> can contain <em> or <strong>
	elsif ($toptag eq 'code' || $toptag eq 'codehere')
		{
		# Translate * in text to __A__ (translated back in intramine_viewer.pl#GetPrettyTextContent())
		$text =~ s!\*!__A__!g;
		AddText($self, $text);
		}
	elsif ($toptag eq 'dt')
		{
		# Have to trim trailing space, otherwise Gloss won't pick up on the text.
		$text =~ s!\s+$!!;
		AddText($self, '**' . $text . '**');
		}
	else
		{
		AddText($self, $text);
		}
     }

# Anchor text is tracked separately (see AddAnchorText() below).
# List text is tracked in the @{$self->{LI_PENDING_LINES}} array.
# For text in <pre> elements see EmitPre().
# Other text is tracked in $self->{CURRENT_LINE}.
# Some attempt at indenting is done, for "other" text: zero of more of _INDT_
# is added at line beginnings, and intramine_viewer.pl#GetPrettyTextContents()
# removes them while adding an appropriate class to the HTML such as 'onePodIndent'.
# Lists get ' - ' at the line start, which GetPrettyTextContents() converts to bullets.
sub AddText {
	my ($self, $text) = @_;

	if (InAnchor())
		{
		$text =~ s!\n!!g;
		AddAnchorText($text);
		}
	else
		{
		my $stayOnSameLine = ($self->{'TEXT_TYPE'} == $kMain || $self->{AT_PARA_START} == 0);

		if ($self->{IN_PARAGRAPH})
			{
			$text =~ s!\n! !g;
			}

		# Break $text into separate lines.
		my @lines = split(/\n/, $text);
		if (!defined($lines[0]))
			{
			$lines[0] = '';
			}

		# List text, stacked up in the LI_PENDING_LINES array.
		if ($self->{'TEXT_TYPE'} == $kLi)
			{
			if ($stayOnSameLine || $self->{LI_STARTED_BLANK})
				{
				my $numPendingLines = @{$self->{LI_PENDING_LINES}};

				if ($numPendingLines)
					{
					${$self->{LI_PENDING_LINES}}[$numPendingLines - 1] .= $lines[0];
					for (my $i = 1; $i < @lines; ++$i)
						{
						push @{$self->{LI_PENDING_LINES}}, $lines[$i];
						}
					}
				else
					{
					if ($text =~ m!^\s*$!)
						{
						$text =~ s!\n! !g;
						push @{$self->{LI_PENDING_LINES}}, $text;
						$self->{LI_STARTED_BLANK} = 2;
						}
					else
						{
						push @{$self->{LI_PENDING_LINES}}, $lines[0];
						for (my $i = 1; $i < @lines; ++$i)
							{
							push @{$self->{LI_PENDING_LINES}}, $lines[$i];
							}
						}
					}
				}
			else
				{
				for (my $i = 0; $i < @lines; ++$i)
					{
					push @{$self->{LI_PENDING_LINES}}, $lines[$i];
					}
				}

			# Clear AT_PARA_START, we have received text.
			$self->{AT_PARA_START} = 0;
			}
		else
			{
			my $toptag = defined(${$self->{TAG}}[-1]) ? ${$self->{TAG}}[-1]: '';

			# Add an indent marker, Gloss will add a class to do the indent.
			my $indentMarker = '';
			my $doingBlank = (($toptag eq 'dd' && $text =~ m!^\s*$!) || $toptag eq 'dl');
			if ($self->{CURRENT_LINE} =~ m!^\s*$! && !$doingBlank)
				{
				$indentMarker = IndentMarker($self);
				}

			$self->{CURRENT_LINE} .= $indentMarker . $text;
			}
		}

	# Allow $self->{LI_STARTED_BLANK} to survive for two
	# trips through here.
	if ($self->{LI_STARTED_BLANK})
		{
		--$self->{LI_STARTED_BLANK};
		}
	}

# Emit all text in a <pre>.
# Add a space to the start of each line if we're in <li> (Gloss wants that
# for continuation paragraphs in a list item).
sub EmitPre {
	my ($self, $text) = @_;
	if (!$self->{IN_PRE})
		{
		return;
		}
	
	my $doingList = ($self->{TEXT_TYPE} == $kLi) ? 1: 0;

	# If we're in a list item, push lines into list item continuation paragraph accumulator.
	# A pre text set of lines begins with a _SPR_ and ends with  _EPR_.
	# intramine_viewer.pl#GetPrettyTextContents() converts those markers to horizontal
	# rules, and adds a bit of background color to the actual pre lines.
	if ($doingList)
		{
		push @{$self->{LI_PENDING_LINES}}, ' _SPR_';
		#push @{$self->{LI_PENDING_LINES}}, '﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘';
		my @lines = split(/\n/, $text);
		for (my $i = 0; $i < @lines; ++$i)
			{
			# Avoid triggering an unordered list or heading.
			# There's a zero width unicode space between $1 and $2.
			$lines[$i] =~ s!^(\s*)([=~+*-])!$1​$2!g;
			# Preserve whitespace in HTML without <pre>, as will
			# be the case in Gloss. '_NBS_' will be converted
			# to &nbsp; in intramine_viewer.pl#GetPrettyTextContents().
			$lines[$i] =~ s! ! !g;
			push @{$self->{LI_PENDING_LINES}}, $lines[$i];
			}
		push @{$self->{LI_PENDING_LINES}}, ' _EPR_';
		#push @{$self->{LI_PENDING_LINES}}, '﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘﹘';
		}
	else # push lines out to LINES immediately
		{
		push @{$self->{LINES}}, '_SPR_';
		#push @{$self->{LINES}}, '---';
		my @lines = split(/\n/, $text);
		for (my $i = 0; $i < @lines; ++$i)
			{
			# Avoid triggering an unordered list or heading.
			# There's a zero width unicode space between $1 and $2.
			$lines[$i] =~ s!^(\s*)([=~+*-])!$1​$2!g;
			# Preserve whitespace in HTML without <pre>, as will
			# be the case in Gloss.
			# There's probably a non-breaking space in the line below.
			$lines[$i] =~ s! ! !g;
			push @{$self->{LINES}}, $lines[$i];
			}
		push @{$self->{LINES}}, '_EPR_';
		#push @{$self->{LINES}}, '---';
		}
	}

# List item:
# Unordered list item starts with ' - '.
# Ordered list item starts with 'N. ' where N is one or more digits.
# Subsequent lines start with a space.
# As mentioned above, Pod::Simple::HTML doesn't produce <ol>.
sub EmitListItem {
	my ($self) = @_;
	my $listType = defined(${$self->{LIST_TYPE}}[-1]) ? ${$self->{LIST_TYPE}}[-1]: 'ul';
	
	my $lineCount = 0;
	my $line;
	while (defined($line = shift @{$self->{LI_PENDING_LINES}}))
	#while (my $line = shift @{$self->{LI_PENDING_LINES}})
		{
		if (!$lineCount)
			{
			my $starter = GetListStarter($self);
			push @{$self->{LINES}}, $starter . $line;
			}
		else
			{
			push @{$self->{LINES}}, " $line";
			}
		++$lineCount;
		}
	}

sub GetListStarter {
	my ($self) = @_;
	my $listType = defined(${$self->{LIST_TYPE}}[-1]) ? ${$self->{LIST_TYPE}}[-1]: 'ul';
	my $starter = '';

	if ($listType eq 'ul')
		{
		$starter = ' - ';
		}
	else # 'ol'
		{
		$starter = "$self->{OLNUMBER}. ";
		$self->{OLNUMBER} += 1;
		}
	
	return($starter);
	}

# Return zero or more _INDT_ in a row, to be added at start of current line
# as an indentation level signal.
sub IndentMarker {
	my ($self) = @_;
	if ($self->{'TEXT_TYPE'} != $kMain)
		{
		return('');
		}
	
	my $indentMarker = '';
	if ($self->{CURRENT_LINE} =~ m!^\s*$!)
		{
		my $dlDepth = NestingDepth($self);
		if ($dlDepth >= 1)
			{
			if ($dlDepth == 1)
				{
				$indentMarker = '_INDT_';
				}
			elsif ($dlDepth == 2)
				{
				$indentMarker = '_INDT__INDT_';
				}
			elsif ($dlDepth == 3)
				{
				$indentMarker = '_INDT__INDT__INDT_';
				}
			else
				{
				$indentMarker = '_INDT__INDT__INDT__INDT_';
				}
			}
		}
	
	return($indentMarker);
	}

# A count of how many 'dl' are on the TAG stack.
sub NestingDepth {
	my ($self) = @_;
	my $numDlTags = 0;

	my $numTags = @{$self->{TAG}};
	my $sawPara = 0;
	for (my $i = 0; $i < $numTags; ++$i)
		{
#		if (${$self->{TAG}}[$i] eq 'dl' || ${$self->{TAG}}[$i] eq 'dt')
		if (${$self->{TAG}}[$i] eq 'dl' || ${$self->{TAG}}[$i] eq 'dd')
			{
			++$numDlTags;
			}
		elsif (index(${$self->{TAG}}[$i], 'h') == 0)
			{
			$numDlTags = 0;
			last;
			}
		elsif (${$self->{TAG}}[$i] eq 'p')
			{
			$sawPara = 1;
			}
		}

	if ($numDlTags && $sawPara)
		{
		# TEST ONLY
		#print("SAW PARA\n");

		$numDlTags += 1;
		}
	
	return($numDlTags);
	}

{ ##### Anchor handling
my $InAnchor;
my $AnchorText;
my $Href;
my $Name;
my $Id;

sub InitAnchorHandling {
	$InAnchor = 0;
	$AnchorText = '';
	$Href = '';
	$Name = '';
	$Id = '';
	}

sub InAnchor {
	return($InAnchor);
	}

sub AnchorTextIsEmpty {
	return($AnchorText eq '');
	}

sub StartAnchor {
	my ($href, $name, $id) = @_;
	$InAnchor = 1;
	$AnchorText = '';
	$Href = $href;
	$Name = $name;
	$Id = $id;
	}

sub AddAnchorText {
	my ($text) = @_;
	$AnchorText .= $text;
	}

# On </a>, return entire <a...>text</a> element.
# Or just the text if doing a heading or there are no attributes.
sub EndAnchor {
	my ($headingLevel) = @_;

	$InAnchor = 0;

	# If we're in a heading, just return the text.
	# Same if no attributes (it's Pod, there are not many rules).
	if ($headingLevel || ($Name eq '' && $Id eq '' && $Href eq ''))
		{
		return($AnchorText);
		}
	
	my $wholeAnchor = '';

	if ($Name ne '' || $Id ne '')
		{
		my $refOrId = '';

		if ($Name ne '')
			{
			# Encode to match href elsewhere.
			$Name =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02X", ord $1 /eg;
			$refOrId = 'id=' . $Name;
			}
		else
			{
			# Encode to match href elsewhere.
			$Id =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02X", ord $1 /eg;
			$refOrId = 'id=' . $Id;
			}

		$wholeAnchor = '_ALB_' . $AnchorText . '_ARB_' . '_ALP_' . $refOrId . '_ARP_';
		}
	elsif ($Href ne '')
		{
		# Convert underscores to hyphens in metacpan #anchors
		if ((my $metaIdx = index($Href, 'metacpan')) > 0)
			{
			my $hashIdx =  index($Href, '#');
			if ($hashIdx > $metaIdx)
				{
				my $upToHash = substr($Href, 0, $hashIdx);
				my $after = substr($Href, $hashIdx);
				$after =~ s!_!-!g;
				$Href = $upToHash . $after;
				}
			}
		my $refOrId = 'href=' . $Href;
		$wholeAnchor = '_LB_' . $AnchorText . '_RB_' . '_LP_' . $refOrId . '_RP_';
		}
	#else - unreachable, see above
	
	return($wholeAnchor);
	}
} ##### Anchor handling

# HTML block tags, from (blush) https://www.w3schools.com/html/html_blocks.asp.
# Note some values are 0, we don't push a line for those.
sub InitBlockTags {
    $blockTag{'address'} = 1;
    $blockTag{'article'} = 1;
    $blockTag{'aside'} = 1;
    $blockTag{'blockquote'} = 1;
    $blockTag{'canvas'} = 1;
    $blockTag{'dd'} = 1;
    $blockTag{'div'} = 1;
    $blockTag{'dl'} = 0;
    $blockTag{'dt'} = 1;
    $blockTag{'fieldset'} = 1;
    $blockTag{'figcaption'} = 1;
    $blockTag{'figure'} = 1;
    $blockTag{'footer'} = 1;
    $blockTag{'form'} = 1;
    $blockTag{'h1'} = 1;
    $blockTag{'h2'} = 1;
    $blockTag{'h3'} = 1;
    $blockTag{'h4'} = 1;
    $blockTag{'h5'} = 1;
    $blockTag{'h6'} = 1;
    $blockTag{'header'} = 1;
    $blockTag{'hr'} = 1;
    $blockTag{'li'} = 1;
    $blockTag{'main'} = 1;
    $blockTag{'nav'} = 1;
    $blockTag{'noscript'} = 1;
    $blockTag{'ol'} = 0;
    $blockTag{'p'} = 1;
    $blockTag{'pre'} = 0;
    $blockTag{'section'} = 1;
    $blockTag{'table'} = 1;
    $blockTag{'tfoot'} = 1;
    $blockTag{'ul'} = 0;
    $blockTag{'video'} = 1;
    }

sub IsBlockTag {
    my ($tag) = @_;
    my $result = defined($blockTag{$tag}) ? 1 : 0;
    return($result);
    }

# We don't want to emit a line for dl dt or pre.
sub IsPushTag {
    my ($tag) = @_;
    my $result = defined($blockTag{$tag}) ? $blockTag{$tag} : 0;
    return($result);
    }

{ ##### Log HTML tags to a file
my $TagFilePath;
my $FileH;

sub StartLoggingTags {
	$TagFilePath = "C:/perlprogs/IntraMine/test/podtags.txt";
	$FileH = FileHandle->new("> $TagFilePath") or die("Could not make |$TagFilePath|!");
	}

sub LogItNow {
	my ($text) = @_;
	print $FileH "$text";
	}

sub StopLoggingTags {
	close($FileH);
	}
} ##### Log HTML tags to a file

1;

